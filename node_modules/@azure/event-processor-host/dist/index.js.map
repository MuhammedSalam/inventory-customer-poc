{"version":3,"file":"index.js","sources":["../../../../common/temp/node_modules/.pnpm/registry.npmjs.org/uuid/3.3.3/node_modules/uuid/lib/rng.js","../../../../common/temp/node_modules/.pnpm/registry.npmjs.org/uuid/3.3.3/node_modules/uuid/lib/bytesToUuid.js","../../../../common/temp/node_modules/.pnpm/registry.npmjs.org/uuid/3.3.3/node_modules/uuid/v4.js","../src/log.ts","../src/util/utils.ts","../src/checkpointInfo.ts","../src/partitionContext.ts","../src/modelTypes.ts","../src/partitionPump.ts","../src/pumpManager.ts","../src/partitionScanner.ts","../src/partitionManager.ts","../src/util/constants.ts","../src/blobService.ts","../src/azureBlob.ts","../src/baseLease.ts","../src/completeLease.ts","../src/azureBlobLease.ts","../src/azureStorageCheckpointLeaseManager.ts","../src/hostContext.ts","../src/eventProcessorHost.ts"],"sourcesContent":["// Unique ID creation requires a high quality random # generator.  In node.js\n// this is pretty straight-forward - we use the crypto API.\n\nvar crypto = require('crypto');\n\nmodule.exports = function nodeRNG() {\n  return crypto.randomBytes(16);\n};\n","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4\n  return ([bth[buf[i++]], bth[buf[i++]], \n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]], '-',\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]],\n\tbth[buf[i++]], bth[buf[i++]]]).join('');\n}\n\nmodule.exports = bytesToUuid;\n","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport debugModule from \"debug\";\n/**\n * @ignore\n * log statements for error\n */\nexport const error = debugModule(\"azure:eph:error\");\n/**\n * @ignore\n * log statements for lease\n */\nexport const baseLease = debugModule(\"azure:eph:baseLease\");\n/**\n * @ignore\n * log statements for lease\n */\nexport const completeLease = debugModule(\"azure:eph:completeLease\");\n/**\n * @ignore\n * log statements for azurebloblease\n */\nexport const azurebloblease = debugModule(\"azure:eph:azurebloblease\");\n/**\n * @ignore\n * log statements for leaseManager\n */\nexport const leaseManager = debugModule(\"azure:eph:leaseManager\");\n/**\n * @ignore\n * log statements for partitionManager\n */\nexport const partitionManager = debugModule(\"azure:eph:partitionManager\");\n/**\n * @ignore\n * log statements for partitionManager\n */\nexport const partitionPump = debugModule(\"azure:eph:partitionPump\");\n/**\n * @ignore\n * log statements for pumpManager\n */\nexport const pumpManager = debugModule(\"azure:eph:pumpManager\");\n/**\n * @ignore\n * log statements for partitionScanner\n */\nexport const partitionScanner = debugModule(\"azure:eph:partitionScanner\");\n/**\n * @ignore\n * log statements for host\n */\nexport const host = debugModule(\"azure:eph:host\");\n/**\n * @ignore\n * log statements for blobService\n */\nexport const blobService = debugModule(\"azure:eph:blobService\");\n/**\n * @ignore\n * log statements for partitionContext\n */\nexport const partitionContext = debugModule(\"azure:eph:partitionContext\");\n/**\n * @ignore\n * log statements for checkpointLeaseMgr\n */\nexport const checkpointLeaseMgr = debugModule(\"azure:eph:checkpointLeaseMgr\");\n/**\n * @ignore\n * log statements for checkpointLeaseMgr\n */\nexport const checkpoint = debugModule(\"azure:eph:checkpointInfo\");\n\n/**\n * @ignore\n * log statements for checkpointLeaseMgr\n */\nexport const util = debugModule(\"azure:eph:util\");\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"../log\";\nimport { StorageError } from \"azure-storage\";\nimport { EPHDiagnosticInfo } from \"../modelTypes\";\n\n/**\n * Generates a random number between the given interval\n * @param {number} min Min number of the range (inclusive).\n * @param {number} max Max number of the range (inclusive).\n */\nexport function randomNumberFromInterval(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * Validates the type and requiredness of a given parameter.\n * @param paramName The name of the parameter.\n * @param paramValue The parameter value\n * @param type The type of the parameter\n */\nexport function validateType(\n  paramName: string,\n  paramValue: any,\n  required: boolean,\n  type: \"string\" | \"number\" | \"boolean\" | \"Array\" | \"object\" | \"Date\" | \"function\"\n): void {\n  if (required && paramValue == undefined) {\n    throw new TypeError(\n      `${paramName} is required. Given value: ${paramValue}. Hence it cannot be null or undefined.`\n    );\n  }\n  if (paramValue != undefined) {\n    if (type === \"Array\") {\n      if (!Array.isArray(paramValue)) {\n        throw new TypeError(`${paramName} must be of type \"${type}\".`);\n      }\n    } else if (type === \"Date\") {\n      if (!(paramValue instanceof Date)) {\n        throw new TypeError(`${paramName} must be of type \"${type}\".`);\n      }\n    } else if (\n      type === \"string\" ||\n      type === \"number\" ||\n      type === \"boolean\" ||\n      type === \"object\" ||\n      type === \"function\"\n    ) {\n      if (typeof paramValue !== type) {\n        throw new TypeError(`${paramName} must be of type \"${type}\".`);\n      }\n    } else {\n      throw new Error(\n        `Invalid argument. type \"${type}\" is not a valid type. Valid values are: ` +\n          `\"string\", \"number\", \"boolean\", \"Array\", \"object\", \"Date\", \"function\"`\n      );\n    }\n  }\n}\n\n/**\n * @ignore\n */\nexport interface StorageErrorInfo {\n  name: string;\n  message: string;\n  statusCode: number;\n  code: string;\n  requestId: string;\n}\n\n/**\n * @ignore\n */\nexport function getStorageError(err: StorageError): StorageErrorInfo {\n  return {\n    name: err.name,\n    message: err.message,\n    statusCode: err.statusCode!,\n    code: err.code!,\n    requestId: err.requestId!\n  };\n}\n\n/**\n * @ignore\n */\nexport interface RetryConfig<T> {\n  hostName: string;\n  operation: () => Promise<T>;\n  partitionId?: string;\n  retryMessage: string;\n  finalFailureMessage: string;\n  action: string;\n  maxRetries: number;\n}\n\n/**\n * @ignore\n */\nexport enum EPHActionStrings {\n  acquireLease = \"Acquire Lease\",\n  gettingPartitionIds = \"Getting PartitionIds\",\n  gettingAllLeases = \"Getting All Leases\",\n  creatingAllLeases = \"Creating All Leases\",\n  scanningLeases = \"Scanning leases\",\n  checkingLeases = \"Checking Leases\",\n  checkingExpiredLeases = \"Checking Expired Leases\",\n  renewingLease = \"Renewing Lease\",\n  stealingLease = \"Stealing Lease\",\n  creatingLease = \"Creating Lease\",\n  creatingCheckpoint = \"Creating Checkpoint\",\n  updatingCheckpoint = \"Updating Checkpoint\",\n  creatingCheckpointStore = \"Creating Checkpoint Store\",\n  creatingEventProcessor = \"Creating Event Processor\",\n  creatingLeaseStore = \"Creating Lease Store\",\n  initializingStores = \"Initializing Stores\",\n  partitionManagerCleanup = \"Partition Manager Cleanup\",\n  partitionManagerMainLoop = \"Partition Manager Main Loop\",\n  partitionReceiverManagement = \"Partition Receiver Management\",\n  deletingLeaseStore = \"Deleting Lease Store\"\n}\n\n/**\n * @ignore\n */\nexport async function retry<T>(config: RetryConfig<T>): Promise<T> {\n  let createdOK: boolean = false;\n  let retryCount: number = 0;\n  let result: T = undefined as any;\n  let innerError: Error | undefined = undefined;\n  do {\n    try {\n      result = await config.operation();\n      createdOK = true;\n      if (config.partitionId) {\n        log.util(\n          \"[%s] Retry attempt: %d. Action '%s' for partitionId: '%s' suceeded.\",\n          config.hostName,\n          retryCount,\n          config.action,\n          config.partitionId\n        );\n      } else {\n        log.util(\n          \"[%s] Retry attempt: %d. Action '%s' suceeded.\",\n          config.hostName,\n          retryCount,\n          config.action\n        );\n      }\n    } catch (err) {\n      innerError = err;\n      if (config.partitionId) {\n        log.error(\n          \"[%s] An error occurred. Retry attempt: %d. PartitionId: '%s'. %s: %O\",\n          config.hostName,\n          config.partitionId,\n          retryCount,\n          config.retryMessage,\n          err\n        );\n      } else {\n        log.error(\n          \"[%s] An error occurred. Retry attempt: %d. %s: %O\",\n          config.hostName,\n          retryCount,\n          config.retryMessage,\n          err\n        );\n      }\n      retryCount++;\n    }\n  } while (!createdOK && retryCount < config.maxRetries);\n\n  if (!createdOK) {\n    let msg: string;\n    if (innerError) {\n      msg =\n        `${config.finalFailureMessage} while performing the action \"${config.action}\" ` +\n        `due to ${innerError.stack ? innerError.stack : JSON.stringify(innerError)}`;\n    } else {\n      msg = `${config.finalFailureMessage} while performing the action \"${config.action}\"`;\n    }\n\n    log.error(\"[%s] %s\", config.hostName, msg);\n    const info: EPHDiagnosticInfo = {\n      action: config.action,\n      hostName: config.hostName,\n      partitionId: config.partitionId || \"N/A\",\n      error: new Error(msg)\n    };\n    throw info;\n  }\n  return result;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { EventData } from \"@azure/event-hubs\";\nimport { LeaseInfo } from \"./azureBlobLease\";\nimport { validateType } from \"./util/utils\";\n\n/**\n * Describes the checkoint information.\n * @interface CheckpointInfo\n */\nexport interface CheckpointInfo {\n  /**\n   * @property {string} partitionId The EventHub partition id.\n   */\n  partitionId: string;\n  /**\n   * @property {string} offset The offset of the event to be checked in.\n   */\n  offset: string;\n  /**\n   * @property {string} sequenceNumber The sequence number of the event to be checked in.\n   */\n  sequenceNumber: number;\n}\n\n/**\n * Describes the checkoint information.\n * @namespace CheckpointInfo\n */\nexport namespace CheckpointInfo {\n  /**\n   * Creates the checkpoint info\n   * @param {string} partitionId The partition id for the checkpoint\n   * @param {string} [offset] The offset of the event to be checked in.\n   * @param {number} [sequenceNumber] The sequence number of the event to be checked in.\n   * @return {CheckpointInfo} CheckpointInfo\n   */\n  export function create(\n    partitionId: string,\n    offset?: string,\n    sequenceNumber?: number\n  ): CheckpointInfo {\n    validateType(\"partitionId\", partitionId, true, \"string\");\n    validateType(\"offset\", offset, false, \"string\");\n    validateType(\"sequenceNumber\", sequenceNumber, false, \"number\");\n    const checkpoint: CheckpointInfo = {\n      partitionId: partitionId,\n      offset: offset || \"-1\",\n      sequenceNumber: sequenceNumber != undefined ? sequenceNumber : 0\n    };\n    log.checkpoint(\"The created CheckpointInfo is: %o\", checkpoint);\n    return checkpoint;\n  }\n\n  /**\n   * Creates the checkpoint info\n   * @param {LeaseInfo} lease The lease info from which the checkpoint info needs to created.\n   * @return {CheckpointInfo} CheckpointInfo\n   */\n  export function createFromLease(lease: LeaseInfo): CheckpointInfo {\n    validateType(\"lease\", lease, true, \"object\");\n    const checkpoint: CheckpointInfo = {\n      offset: lease.offset || \"-1\",\n      partitionId: lease.partitionId,\n      sequenceNumber: lease.sequenceNumber\n    };\n    log.checkpoint(\"The created CheckpointInfo from lease %o is: %o\", lease, checkpoint);\n    return checkpoint;\n  }\n\n  /**\n   * Creates the checkpoint info.\n   * @param {string} partitionId The partition id for the checkpoint\n   * @param {EventData} eventData The event data from which the checkpoint info needs to created.\n   * @return {CheckpointInfo} CheckpointInfo\n   */\n  export function createFromEventData(partitionId: string, eventData: EventData): CheckpointInfo {\n    validateType(\"partitionId\", partitionId, true, \"string\");\n    validateType(\"eventData\", eventData, true, \"object\");\n    validateType(\"eventData.offset\", eventData.offset, true, \"string\");\n    validateType(\"eventData.sequenceNumber\", eventData.sequenceNumber, true, \"number\");\n\n    const checkpoint: CheckpointInfo = {\n      partitionId: partitionId,\n      offset: eventData.offset!,\n      sequenceNumber: eventData.sequenceNumber!\n    };\n    log.checkpoint(\"The created CheckpointInfo from EventData %o is: %o\", eventData, checkpoint);\n    return checkpoint;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { EventData, EventPosition } from \"@azure/event-hubs\";\nimport { CompleteLease } from \"./completeLease\";\nimport { CheckpointInfo } from \"./checkpointInfo\";\nimport * as log from \"./log\";\nimport { HostContextWithCheckpointLeaseManager } from \"./hostContext\";\nimport { validateType } from \"./util/utils\";\n\n/**\n * Describes the Partition Context.\n * @class PartitionContext\n */\nexport class PartitionContext {\n  /**\n   * @property {Lease} lease The most recdent checkpointed lease with the partitionId.\n   */\n  lease: CompleteLease;\n  /**\n   * @property {string} partitionId The eventhub partition id.\n   * @readonly\n   */\n  readonly partitionId: string;\n  /**\n   * @property {string} owner The host/owner of the partition.\n   * @readonly\n   */\n  get owner(): string {\n    return this.lease.owner;\n  }\n  /**\n   * @property {string} eventhubPath The path of the eventhub\n   * @readonly\n   */\n  get eventhubPath(): string {\n    return this._context.eventHubPath;\n  }\n  /**\n   * @property {string} consumerGroup The name of the consumer group.\n   * @readonly\n   */\n  get consumerGroup(): string {\n    return this._context.consumerGroup;\n  }\n\n  private _context: HostContextWithCheckpointLeaseManager;\n  private _offset: string = EventPosition.startOfStream;\n  private _sequenceNumber: number = 0;\n\n  /**\n   * Creates a new PartitionContext.\n   * @param {string} partitionId The eventhub partition id.\n   * @param {string} owner The name of the owner.\n   * @param {CompleteLease} lease The lease object.\n   */\n  constructor(\n    context: HostContextWithCheckpointLeaseManager,\n    partitionId: string,\n    lease: CompleteLease\n  ) {\n    this._context = context;\n    this.partitionId = partitionId;\n    this.lease = lease;\n  }\n\n  /**\n   * Sets the offset and sequence number of the partition context from the provided EventData.\n   * @param {EventData} eventData The event data `received` from the EventHubReceiver.\n   */\n  setOffsetAndSequenceNumber(eventData: EventData): void {\n    validateType(\"eventData\", eventData, true, \"object\");\n    validateType(\"eventData.offset\", eventData.offset, true, \"string\");\n    validateType(\"eventData.sequenceNumber\", eventData.sequenceNumber, true, \"number\");\n    this._offset = eventData.offset!;\n    this._sequenceNumber = eventData.sequenceNumber!;\n  }\n\n  /**\n   * Writes the current offset and sequenceNumber to the checkpoint store via the checkpoint manager.\n   *\n   * The checkpoint data is structured as a JSON payload (example):\n   * `{ \"partitionId\":\"0\",\"owner\":\"ephtest\",\"token\":\"48e209e3-55f0-41b8-a8dd-d9c09ff6c35a\",\n   * \"epoch\":1,\"offset\":\"\",\"SequenceNumber\":0 }`.\n   *\n   * @return {Promise<void>}\n   */\n  async checkpoint(): Promise<void> {\n    const capturedCheckpoint: CheckpointInfo = {\n      offset: this._offset,\n      partitionId: this.partitionId,\n      sequenceNumber: this._sequenceNumber\n    };\n    const withHostAndPartiton = this._context.withHostAndPartition;\n    log.partitionContext(withHostAndPartiton(this, \"Checkpointing: %O\"), capturedCheckpoint);\n    await this._context.checkpointLock.acquire(this._context.checkpointLockId, () => {\n      return this._persistCheckpoint(capturedCheckpoint);\n    });\n  }\n\n  /**\n   * Writes the current offset and sequenceNumber to the checkpoint store via the checkpoint manager.\n   *\n   * The checkpoint data is structured as a JSON payload (example):\n   * `{ \"partitionId\":\"0\",\"owner\":\"ephtest\",\"token\":\"48e209e3-55f0-41b8-a8dd-d9c09ff6c35a\",\n   * \"epoch\":1,\"offset\":\"\",\"SequenceNumber\":0 }`.\n   *\n   * @param {EventData} eventData The event data received from the EventHubReceiver.\n   * @return {Promise<void>}\n   */\n  async checkpointFromEventData(eventData: EventData): Promise<void> {\n    const data = CheckpointInfo.createFromEventData(this.partitionId, eventData);\n    const withHostAndPartiton = this._context.withHostAndPartition;\n    log.partitionContext(withHostAndPartiton(this, \"Checkpointing from ED: %O\"), data);\n    await this._context.checkpointLock.acquire(this._context.checkpointLockId, () => {\n      return this._persistCheckpoint(data);\n    });\n  }\n\n  /**\n   * @ignore\n   */\n  async getInitialOffset(): Promise<EventPosition> {\n    const startingCheckpoint = await this._context.checkpointManager.getCheckpoint(\n      this.partitionId\n    );\n    const withHostAndPartiton = this._context.withHostAndPartition;\n    let result: EventPosition;\n    if (!startingCheckpoint) {\n      if (this._context.initialOffset) {\n        log.partitionContext(\n          withHostAndPartiton(this, \"User provided initial offset: %s\"),\n          this._context.initialOffset.getExpression()\n        );\n      }\n      result = this._context.initialOffset || EventPosition.fromOffset(this._offset);\n    } else {\n      if (startingCheckpoint.offset != undefined) this._offset = startingCheckpoint.offset;\n      if (startingCheckpoint.sequenceNumber != undefined)\n        this._sequenceNumber = startingCheckpoint.sequenceNumber;\n      result = EventPosition.fromOffset(this._offset);\n      log.partitionContext(\n        withHostAndPartiton(this, \"Retrieved starting offset/sequence \" + \"number: %s/%d\"),\n        this._offset,\n        this._sequenceNumber\n      );\n    }\n    log.partitionContext(\n      withHostAndPartiton(\n        this,\n        \"Initial position provider offset: %s, \" + \"sequenceNumber: %d, enqueuedTime: %d\"\n      ),\n      result.offset,\n      result.sequenceNumber,\n      result.enqueuedTime\n    );\n    return result;\n  }\n\n  /**\n   * @ignore\n   */\n  private async _persistCheckpoint(checkpoint: CheckpointInfo): Promise<void> {\n    const withHostAndPartiton = this._context.withHostAndPartition;\n    try {\n      const inStoreCheckpoint = await this._context.checkpointManager.getCheckpoint(\n        checkpoint.partitionId\n      );\n      if (inStoreCheckpoint && inStoreCheckpoint.sequenceNumber >= checkpoint.sequenceNumber) {\n        const msg =\n          `Ignoring out of date checkpoint with offset: '${checkpoint.offset}', ` +\n          `sequenceNumber: ${checkpoint.sequenceNumber} because currently persisted checkpoint ` +\n          ` has higher offset '${inStoreCheckpoint.offset}', sequenceNumber ` +\n          `${inStoreCheckpoint.sequenceNumber}.`;\n        log.error(withHostAndPartiton(this, \"%s\"), msg);\n        throw new Error(msg);\n      }\n      log.partitionContext(withHostAndPartiton(this, \"Persisting the checkpoint: %O.\"), checkpoint);\n      await this._context.checkpointManager.updateCheckpoint(this.lease, checkpoint);\n      log.partitionContext(\n        withHostAndPartiton(this, \"Successfully persisted the checkpoint: %O.\"),\n        checkpoint\n      );\n    } catch (err) {\n      const msg =\n        `An error occurred while checkpointing info for partition ` +\n        `'${checkpoint.partitionId}': ${err ? err.stack : JSON.stringify(err)}.`;\n      log.error(withHostAndPartiton(this, \"%s\"), msg);\n      throw err;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { PartitionContext } from \"./partitionContext\";\nimport {\n  EventData,\n  MessagingError,\n  EventPosition,\n  TokenProvider,\n  ClientOptionsBase\n} from \"@azure/event-hubs\";\nimport { CheckpointManager } from \"./checkpointManager\";\nimport { LeaseManager } from \"./leaseManager\";\n\n/**\n * @ignore\n */\nexport enum CloseReason {\n  leaseLost = \"LeaseLost\",\n  shutdown = \"ShutDown\"\n}\n\n/**\n * Provides information about internal errors that occur while managing partitions or leases for\n * the partitions.\n * @interface EPHDiagnosticInfo\n */\nexport interface EPHDiagnosticInfo {\n  /**\n   * @property {string} hostName The name of the host that experienced the error. Allows\n   * distinguishing the error source if multiple hosts in a single process.\n   */\n  hostName: string;\n  /**\n   * @property {string} partitionId The partitionId that experienced the error. Allows\n   * distinguishing the error source if multiple hosts in a single process.\n   */\n  partitionId: string;\n  /**\n   * @property {string} action A short string that indicates what general activity threw the\n   * error.\n   */\n  action: string;\n  /**\n   * @property {any} error The error that was thrown.\n   */\n  error: any;\n}\n\n/**\n * Describes the error handler signature to receive notifcation for general errors.\n *\n * Errors which occur while processing events from a particular EventHub partition are delivered\n * to the `onError` handler provided in the `start()` method. This handler is called on\n * occasions when an error occurs while managing partitions or leases for the partitions.\n * @function\n */\nexport type OnEphError = (error: EPHDiagnosticInfo) => void;\n\n/**\n * Describes the message handler signature for messages received from an EventHub.\n * @function\n */\nexport type OnReceivedMessage = (context: PartitionContext, eventData: EventData) => void;\n\n/**\n * Describes the message handler signature for errors that occur while receiving messages from an\n * EventHub.\n * @function\n */\nexport type OnReceivedError = (error: MessagingError | Error) => void;\n\n/**\n * Describes the optional parameters that can be provided for creating an EventProcessorHost while\n * creating from an iothub connectionstring.\n * @interface FromIotHubConnectionStringOptions\n */\nexport type FromIotHubConnectionStringOptions = FromTokenProviderOptions;\n\n/**\n * Describes the optional parameters that can be provided for creating an EventProcessorHost while\n * creating from the given token provider\n * @interface FromTokenProviderOptions\n */\nexport interface FromTokenProviderOptions extends ClientOptionsBase {\n  /**\n   * @property {EventPosition} initialOffset This is only used when then receiver is being created\n   * for the very first time and there is no checkpoint data in the blob. For this option to be\n   * effective please make sure to provide a new hostName that was not used previously.\n   */\n  initialOffset?: EventPosition;\n  /**\n   * @property {string} [consumerGroup] The name of the consumer group within the Event Hub. Default\n   * value: **`\"$default\"`**.\n   */\n  consumerGroup?: string;\n  /**\n   * @property {string} [storageBlobPrefix] Prefix used when naming blobs within the storage\n   * container.\n   */\n  storageBlobPrefix?: string;\n  /**\n   * @property {OnEphError} [onEphError] Error handler that can be provided to receive notifcation\n   * for general errors.\n   *\n   * Errors which occur while processing events from a particular EventHub partition are delivered\n   * to the `onError` handler provided in the `start()` method. This handler is called on\n   * occasions when an error occurs while managing partitions or leases for the partitions.\n   */\n  onEphError?: OnEphError;\n  /**\n   * @property {number} [leaseRenewInterval] The sleep interval **`in seconds`** between scans.\n   * Default: **`10` seconds**.\n   *\n   * Allows a lease manager implementation to specify to PartitionManager how often it should\n   * scan leases and renew them. In order to redistribute leases in a timely fashion after a host\n   * ceases operating, we recommend a relatively short interval, such as ten seconds. Obviously it\n   * should be less than half of the lease length, to prevent accidental expiration.\n   *\n   * If `Leasemanager` is provided when creating the EventProcessorHost then this value will be ignored.\n   */\n  leaseRenewInterval?: number;\n  /**\n   * @property {number} [leaseDuration] Duration of a lease **`in seconds`** before it expires\n   * unless renewed. Default: **`30` seconds**, Min Value: **`15` seconds**,\n   * Max value: **`60` seconds**.\n   *\n   * If `Leasemanager` is provided when creating the EventProcessorHost then this value will be ignored.\n   */\n  leaseDuration?: number;\n  /**\n   * @property {number} [startupScanDelay] The delay time **`in seconds`** between the first scan\n   * for available partitions and the second. This is part of a startup optimization which allows\n   * individual hosts to become visible to other hosts, and thereby get a more accurate count\n   * of the number of hosts in the system, before they try to estimate how many partitions they\n   * should own. Default: **`30` seconds**.\n   */\n  startupScanDelay?: number;\n  /**\n   * @property {number} [fastScanInterval] There are two possible interval times between scans for\n   * available partitions, fast and slow. The fast (short) interval **`in seconds`** is used after\n   * a scan in which lease stealing has occurred, to promote quicker rebalancing.\n   * Default: **`3` seconds**.\n   */\n  fastScanInterval?: number;\n  /**\n   * @property {number} [slowScanInterval] The slow (long) interval **`in seconds`** is used\n   * after a scan in which lease stealing did not occur, to reduce unnecessary scanning when\n   * the system is in steady state. Default: **`5` seconds**.\n   */\n  slowScanInterval?: number;\n}\n\n/**\n * Describes the optional parameters that can be provided for creating an EventProcessorHost while\n * creating from the eventhub connection string.\n * @interface FromConnectionStringOptions\n */\nexport interface FromConnectionStringOptions extends FromTokenProviderOptions {\n  /**\n   * @property {string} [eventHubPath] The name of the EventHub. This is optional if the\n   * EventHub connection string contains EntityPath=hub-name else an Error will be thrown.\n   */\n  eventHubPath?: string;\n}\n\n/**\n * Describes the optional parameters that can be provided for creating an EventProcessorHost.\n * @interface EventProcessorHostOptions\n */\nexport interface EventProcessorHostOptions extends FromConnectionStringOptions {\n  /**\n   * @property {string} [eventHubConnectionString] Connection string for the Event Hub to receive\n   * from. Example: \"Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;\n   * SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key\".\n   */\n  eventHubConnectionString?: string;\n  /**\n   * @property {string} [storageConnectionString] Connection string to Azure Storage account used\n   * for leases and checkpointing. Example \"DefaultEndpointsProtocol=https;AccountName=<account-name>;\n   * AccountKey=<account-key>;EndpointSuffix=core.windows.net\"\n   */\n  storageConnectionString?: string;\n  /**\n   * @property {string} [storageContainerName] Azure Storage container name for use by built-in\n   * lease and checkpoint manager.\n   */\n  storageContainerName?: string;\n  /**\n   * @property {CheckpointManager} [checkpointManager] A manager to manage checkpoints.\n   * Default: **`AzureStorageCheckpointLeaseManager`**.\n   */\n  checkpointManager?: CheckpointManager;\n  /**\n   * @property {LeaseManager} [LeaseManager] A manager to manage leases. Default:\n   * **`AzureStorageCheckpointLeaseManager`**.\n   */\n  leaseManager?: LeaseManager;\n  /**\n   * @property {TokenProvider} [tokenProvider] An instance of the token provider interface that\n   * provides the token for authentication. Default value: **`SasTokenProvider`**.\n   */\n  tokenProvider?: TokenProvider;\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { HostContextWithCheckpointLeaseManager } from \"./hostContext\";\nimport { CompleteLease } from \"./completeLease\";\nimport {\n  ReceiveHandler,\n  EventHubClient,\n  EventPosition,\n  ReceiveOptions,\n  EventData,\n  MessagingError,\n  OnMessage,\n  OnError,\n  ErrorNameConditionMapper\n} from \"@azure/event-hubs\";\nimport { PartitionContext } from \"./partitionContext\";\nimport { CloseReason, OnReceivedMessage, OnReceivedError } from \"./modelTypes\";\nimport { AzureBlobLease } from \"./azureBlobLease\";\nimport { EPHActionStrings } from \"./util/utils\";\n\n/**\n * @ignore\n */\nexport class PartitionPump {\n  private _context: HostContextWithCheckpointLeaseManager;\n  private _lease: CompleteLease;\n  private _partitionContext: PartitionContext;\n  private _onMessage: OnReceivedMessage;\n  private _onError: OnReceivedError;\n  private _client?: EventHubClient;\n  private _receiveHandler?: ReceiveHandler;\n  private _leaseRenewalTimer?: NodeJS.Timer;\n\n  constructor(\n    context: HostContextWithCheckpointLeaseManager,\n    lease: CompleteLease,\n    onMessage: OnReceivedMessage,\n    onError: OnReceivedError\n  ) {\n    this._context = context;\n    this._lease = lease;\n    this._partitionContext = new PartitionContext(this._context, lease.partitionId, lease);\n    this._onMessage = onMessage;\n    this._onError = onError;\n  }\n\n  get lease(): CompleteLease {\n    return this._lease;\n  }\n  set lease(newLease: CompleteLease) {\n    this._lease = newLease;\n    if (this._partitionContext) {\n      this._partitionContext.lease = this._lease;\n    }\n  }\n\n  isOpen(): boolean {\n    if (this._receiveHandler && this._receiveHandler.isReceiverOpen) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  async start(): Promise<void> {\n    const withHostAndPartition = this._context.withHostAndPartition;\n    await this._createNewReceiver();\n    await this._scheduleLeaseRenewer();\n    log.partitionPump(\n      withHostAndPartition(\n        this._lease,\n        \"Successfully started the receiver and scheduled lease renewer.\"\n      )\n    );\n  }\n\n  async stop(reason: CloseReason): Promise<void> {\n    await this._removeReceiver(reason);\n  }\n\n  private async _createNewReceiver(): Promise<void> {\n    const partitionId = this._partitionContext.partitionId;\n    const withHostAndPartition = this._context.withHostAndPartition;\n    try {\n      this._client = this._context.getEventHubClient();\n    } catch (err) {\n      log.error(\n        withHostAndPartition(\n          partitionId,\n          \"An error occurred while creating \" + \"the eventhub client: %O.\"\n        ),\n        err\n      );\n      throw err;\n    }\n    log.partitionPump(withHostAndPartition(partitionId, \"Getting the initial offset.\"));\n    const eventPosition: EventPosition = await this._partitionContext.getInitialOffset();\n    this._context.pumps.set(partitionId, this);\n    log.partitionPump(withHostAndPartition(partitionId, \"Added the pump to the internal map.\"));\n    let receiveHandler: ReceiveHandler;\n    const rcvrOptions: ReceiveOptions = {\n      consumerGroup: this._context.consumerGroup,\n      eventPosition: eventPosition,\n      epoch: this._lease.epoch\n    };\n    const onMessage: OnMessage = (eventData: EventData) => {\n      this._partitionContext.setOffsetAndSequenceNumber(eventData);\n      this._onMessage(this._partitionContext, eventData);\n    };\n    const onError: OnError = async (error: MessagingError | Error) => {\n      log.error(\n        withHostAndPartition(partitionId, \"Receiver '%s' received an error: %O.\"),\n        receiveHandler.address,\n        error\n      );\n      // Let the user know about the error only if it is not ReceiverDisconnectedError.\n      // This error happens when another instance of EPH connects a receiver with a higher epoch\n      // value to a partition in the same consumer group that this receiver was connected to.\n      // This happens due to lease being stolen or current lease expiring, which is expected.\n      // Hence not reporting suxh errors to the user will try to make it less confusing for the user.\n      if (!this._isReceiverDisconnectedError(error)) {\n        this._onError!(error);\n      }\n      try {\n        await this._removeReceiver(CloseReason.shutdown);\n      } catch (err) {\n        log.error(\n          withHostAndPartition(\n            partitionId,\n            \"Since we received an error %O \" +\n              \"on the error handler for receiver with address '%s', we tried closing it. However, \" +\n              \"error occurred while closing it and it is: %O.\"\n          ),\n          error,\n          receiveHandler.address,\n          err\n        );\n      }\n    };\n    log.partitionPump(\n      withHostAndPartition(\n        partitionId,\n        \"Trying to create receiver in \" + \"consumergroup: '%s' with epoch %d from offset: %s.\"\n      ),\n      rcvrOptions.consumerGroup,\n      rcvrOptions.epoch,\n      eventPosition.getExpression()\n    );\n    receiveHandler = this._client.receive(partitionId, onMessage, onError, rcvrOptions);\n    this._receiveHandler = receiveHandler;\n    log.partitionPump(\n      withHostAndPartition(partitionId, \"Created receiver '%s' with eventPosition: %s\"),\n      receiveHandler.address,\n      eventPosition.getExpression()\n    );\n  }\n\n  private async _leaseRenewer(): Promise<void> {\n    const withHostAndPartition = this._context.withHostAndPartition;\n    let result: boolean = true;\n    let error: Error | undefined;\n    log.partitionPump(\n      withHostAndPartition(\n        this._lease,\n        \"Lease renewer is active after \" + \"%d seconds. Trying to renew the lease\"\n      ),\n      this._context.leaseRenewInterval\n    );\n    try {\n      result = await this._context.leaseManager.renewLease(this._lease);\n      if (result) {\n        log.partitionPump(withHostAndPartition(this._lease, \"Successfully renewed the lease.\"));\n      }\n    } catch (err) {\n      const msg =\n        `An error occurred while renewing the lease for partitionId ` +\n        `'${this._lease.partitionId}': ${err ? err.stack : JSON.stringify(err)}`;\n      error = new Error(msg);\n      this._context.onEphError({\n        hostName: this._context.hostName,\n        partitionId: this._lease.partitionId,\n        error: error,\n        action: EPHActionStrings.renewingLease\n      });\n      log.error(withHostAndPartition(this._lease, msg));\n    }\n    if (!result) {\n      log.error(\n        withHostAndPartition(\n          this._lease,\n          \"Failed to renew the lease, result: %s. \" + \"Shutting down the receiver.\"\n        ),\n        result\n      );\n      await this._removeReceiver(CloseReason.leaseLost);\n    } else {\n      this._scheduleLeaseRenewer();\n    }\n  }\n\n  private _scheduleLeaseRenewer(): void {\n    const withHostAndPartition = this._context.withHostAndPartition;\n    const renewalTime = this._context.leaseRenewInterval * 1000;\n    log.partitionPump(\n      withHostAndPartition(this._lease, \"Scheduling lease renewal in %d seconds.\"),\n      this._context.leaseRenewInterval\n    );\n    this._leaseRenewalTimer = setTimeout(async () => {\n      try {\n        await this._leaseRenewer();\n      } catch (err) {\n        log.error(\n          withHostAndPartition(this._lease, \"An error occurred in the _leaseRenewer(): %O\"),\n          err\n        );\n      }\n    }, renewalTime);\n  }\n\n  private async _removeReceiver(reason: CloseReason): Promise<void> {\n    const receiveHandler = this._receiveHandler;\n    const partitionContext = this._partitionContext;\n    const partitionId = partitionContext.partitionId;\n    const leaseId = (this._lease as AzureBlobLease).token;\n    const withHostAndPartition = this._context.withHostAndPartition;\n\n    if (receiveHandler && this._client) {\n      try {\n        this._context.pumps.delete(partitionId);\n        log.partitionPump(withHostAndPartition(partitionId, \"Deleted the pump from internal map.\"));\n        clearTimeout(this._leaseRenewalTimer as NodeJS.Timer);\n        log.partitionPump(\n          withHostAndPartition(partitionId, \"Removing receiver '%s', due to reason '%s'.\"),\n          receiveHandler.address,\n          partitionId,\n          reason\n        );\n        await this._client.close();\n        log.partitionPump(\n          withHostAndPartition(\n            partitionId,\n            \"Successfully stopped the receiver '%s' for partitionId '%s' due to reason '%s'.\"\n          ),\n          receiveHandler.address,\n          partitionId,\n          reason\n        );\n      } catch (err) {\n        const msg =\n          `An error occurred while closing the receiver '${receiveHandler.address}' : ` +\n          `${err ? err.stack : JSON.stringify(err)}`;\n        log.error(withHostAndPartition(partitionId, \"%s\"), msg);\n      }\n      this._receiveHandler = undefined;\n      this._client = undefined;\n      // Release the lease if it was not lost.\n      if (reason !== CloseReason.leaseLost) {\n        try {\n          log.partitionPump(\n            withHostAndPartition(\n              partitionContext,\n              \"Releasing lease %s after closing the receiver '%s' due to reason '%s'.\"\n            ),\n            leaseId,\n            receiveHandler.address,\n            reason\n          );\n          await this._context.leaseManager.releaseLease(partitionContext.lease);\n        } catch (err) {\n          const msg =\n            `An error occurred while releasing the lease ${leaseId} ` +\n            `the receiver '${receiveHandler.address}' : ${err ? err.stack : JSON.stringify(err)} `;\n          log.error(withHostAndPartition(partitionId, \"%s\"), msg);\n          throw err;\n        }\n      }\n    } else {\n      log.partitionPump(withHostAndPartition(partitionId, \"No receiver was found to remove.\"));\n    }\n  }\n\n  private _isReceiverDisconnectedError(error: MessagingError | Error): boolean {\n    const partitionId = this._partitionContext.partitionId;\n    const withHostAndPartition = this._context.withHostAndPartition;\n    let result = false;\n    if (error) {\n      // condition is \"amqp:link:stolen\"\n      if (\n        (error as MessagingError).condition === ErrorNameConditionMapper.ReceiverDisconnectedError\n      ) {\n        result = true;\n      } else if (error.message.match(/.*New receiver with higher epoch.*/i) !== null) {\n        result = true;\n        log.error(\n          withHostAndPartition(\n            partitionId,\n            \"It looks like the error should have \" +\n              \"been a 'ReceiverDisconnectedError', however it was not translated correctly: %O.\"\n          ),\n          error\n        );\n      }\n    }\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { HostContextWithCheckpointLeaseManager } from \"./hostContext\";\nimport { PartitionPump } from \"./partitionPump\";\nimport { CompleteLease } from \"./completeLease\";\nimport { CloseReason } from \"./modelTypes\";\nimport { EPHActionStrings } from \"./util/utils\";\n\n/**\n * @ignore\n */\nexport class PumpManager {\n  private _context: HostContextWithCheckpointLeaseManager;\n\n  constructor(context: HostContextWithCheckpointLeaseManager) {\n    this._context = context;\n  }\n\n  async addPump(lease: CompleteLease): Promise<void> {\n    const hostName = this._context.hostName;\n    const partitionId = lease.partitionId;\n    const withHostAndPartition = this._context.withHostAndPartition;\n    try {\n      const capturedPump = this._context.pumps.get(partitionId);\n      if (capturedPump) {\n        const isOpen = capturedPump.isOpen();\n        if (!isOpen) {\n          log.error(withHostAndPartition(partitionId, \"The existing pump is open -> %s.\"), isOpen);\n          await this.removePump(partitionId, CloseReason.shutdown);\n        } else {\n          log.pumpManager(\n            withHostAndPartition(\n              partitionId,\n              \"Updating lease for pump since it\" + \"is open -> %s.\"\n            ),\n            partitionId,\n            isOpen\n          );\n          capturedPump.lease = lease;\n        }\n      } else {\n        log.pumpManager(\n          withHostAndPartition(partitionId, \"Creating a new pump with lease %o.\"),\n          lease.getInfo()\n        );\n        const pump = new PartitionPump(\n          this._context,\n          lease,\n          this._context.onMessage!,\n          this._context.onError!\n        );\n        await pump.start();\n      }\n    } catch (err) {\n      const msg =\n        `An error occurred while adding/updating a pump for partitionId ` +\n        `'${partitionId}': ${err ? err.stack : JSON.stringify(err)}`;\n      log.error(withHostAndPartition(partitionId, \"%s.\"), msg);\n      this._context.onEphError({\n        hostName: hostName,\n        partitionId: partitionId,\n        error: new Error(msg),\n        action: EPHActionStrings.partitionReceiverManagement\n      });\n    }\n  }\n\n  async removePump(partitionId: string, reason: CloseReason): Promise<void> {\n    const withHostAndPartition = this._context.withHostAndPartition;\n    try {\n      const capturedPump = this._context.pumps.get(partitionId);\n      if (capturedPump) {\n        log.pumpManager(withHostAndPartition(partitionId, \"Stopping the pump.\"));\n        await capturedPump.stop(reason);\n      } else {\n        log.pumpManager(withHostAndPartition(partitionId, \"No pump was found, to remove.\"));\n      }\n    } catch (err) {\n      const msg =\n        `An error occurred while removing a pump for partitionId '${partitionId}': ` +\n        `${err ? err.stack : JSON.stringify(err)}`;\n      log.error(withHostAndPartition(partitionId, \"%s.\"), msg);\n      this._context.onEphError({\n        hostName: this._context.hostName,\n        partitionId: partitionId,\n        error: new Error(msg),\n        action: EPHActionStrings.partitionReceiverManagement\n      });\n    }\n  }\n\n  async removeAllPumps(reason: CloseReason): Promise<void> {\n    const withHost = this._context.withHost;\n    const tasks: Promise<void>[] = [];\n    for (const id of this._context.pumps.keys()) {\n      tasks.push(this.removePump(id, reason));\n    }\n    log.partitionManager(withHost(\"Removing all the pumps due to reason %s.\"), reason);\n    await Promise.all(tasks);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { randomNumberFromInterval } from \"./util/utils\";\nimport { HostContextWithPumpManager } from \"./hostContext\";\nimport { CompleteLease } from \"./completeLease\";\nimport { BaseLease } from \"./baseLease\";\nimport { EPHActionStrings } from \"./util/utils\";\nimport * as log from \"./log\";\nimport { EPHDiagnosticInfo } from \"./modelTypes\";\n\n/**\n * @ignore\n */\nexport class PartitionScanner {\n  private _context: HostContextWithPumpManager;\n  private _allLeaseStates: BaseLease[] = [];\n  private _desiredCount: number = 0;\n  private _unownedCount: number = 0;\n  private _leaseOwnedByOthers: Map<string, BaseLease> = new Map<string, BaseLease>();\n\n  constructor(context: HostContextWithPumpManager) {\n    this._context = context;\n  }\n\n  async scan(isFirst: boolean): Promise<boolean> {\n    const hostName = this._context.hostName;\n    const withHost = this._context.withHost;\n    let didSteal = false;\n    try {\n      this._reset();\n      log.partitionScanner(withHost(\"Starting a new iteration to scan partitions.\"));\n      log.partitionScanner(withHost(\"Getting lease states to find out who owns what.\"));\n      await this._getAllLeaseStates();\n      log.partitionScanner(withHost(\"Sorting leases to find out the desired partition count.\"));\n      const ourLeasesCount: number = await this._sortLeasesAndCalculateDesiredCount(isFirst);\n      log.partitionScanner(withHost(\"Our lease count: %d.\"), ourLeasesCount);\n      const attemptToAcquire: number = this._desiredCount - ourLeasesCount;\n      log.partitionScanner(\n        withHost(\"Attempting to acquire %d leases in parallel starting from \" + \"position 0.\"),\n        attemptToAcquire\n      );\n      const remainingNeeded = await this._acquireExpiredInParallel(0, attemptToAcquire);\n      log.partitionScanner(withHost(\"Looking to steal: %d.\"), remainingNeeded);\n      if (remainingNeeded > 0) {\n        const stealThese = await this._findLeasesToSteal(remainingNeeded);\n        log.partitionScanner(withHost(\"Number of lease found to steal: %d.\"), stealThese.length);\n        didSteal = await this._stealLeases(stealThese);\n        log.partitionScanner(\n          withHost(\"Have succesfully stolen: %d leases -> %s.\"),\n          stealThese.length,\n          didSteal\n        );\n      } else {\n        log.partitionScanner(\n          withHost(\"No need to scan further since remaining needed: %d.\"),\n          remainingNeeded\n        );\n      }\n    } catch (err) {\n      didSteal = false;\n      const msg =\n        `An error occurred while scanning leases: ` + `${err ? err.stack : JSON.stringify(err)}.`;\n      log.error(withHost(\"%s\"), hostName, msg);\n      const info: EPHDiagnosticInfo = {\n        action: EPHActionStrings.scanningLeases,\n        error: new Error(msg),\n        hostName: hostName,\n        partitionId: \"N/A\"\n      };\n      this._context.onEphError(info);\n    }\n    return didSteal;\n  }\n\n  private _reset(): void {\n    this._allLeaseStates = [];\n    this._desiredCount = 0;\n    this._unownedCount = 0;\n    this._leaseOwnedByOthers = new Map<string, BaseLease>();\n  }\n\n  private async _getAllLeaseStates(): Promise<void> {\n    const result = await this._context.leaseManager.getAllLeases();\n    this._allLeaseStates = result.sort();\n    log.partitionScanner(\n      this._context.withHost(\"State of all the leases that we know about:\\n%O\"),\n      this._allLeaseStates\n    );\n    return;\n  }\n\n  private _sortLeasesAndCalculateDesiredCount(isFirst: boolean): number {\n    const hostName: string = this._context.hostName;\n    const withHost = this._context.withHost;\n    log.partitionScanner(\n      withHost(\"Accounting input: allLeaseStates count is: %d\"),\n      this._allLeaseStates.length\n    );\n    const uniqueOwners: Set<string> = new Set<string>();\n    uniqueOwners.add(hostName);\n    let ourLeasesCount = 0;\n    this._unownedCount = 0;\n    for (const lease of this._allLeaseStates) {\n      const ownedByUs: boolean = lease.isOwned && lease.owner === hostName;\n      if (lease.isOwned && lease.owner) {\n        uniqueOwners.add(lease.owner);\n      } else {\n        this._unownedCount++;\n      }\n      if (ownedByUs) {\n        ourLeasesCount++;\n      } else if (lease.isOwned) {\n        this._leaseOwnedByOthers.set(lease.partitionId, lease);\n      }\n    }\n    const hostCount = uniqueOwners.size;\n    const countPerHost = Math.floor(this._allLeaseStates.length / hostCount);\n    this._desiredCount = isFirst ? 1 : countPerHost;\n    if (\n      !isFirst &&\n      this._unownedCount > 0 &&\n      this._unownedCount < hostCount &&\n      this._allLeaseStates.length % hostCount !== 0\n    ) {\n      // distribute leftovers\n      this._desiredCount++;\n    }\n\n    const sortedHosts: Array<string> = Array.from(uniqueOwners).sort();\n    let hostOrdinal: number = -1;\n    let startingPoint: number = 0;\n    if (isFirst) {\n      // If the entire system is starting up, the list of hosts is probably not complete and we\n      // can not really compute a meaningful hostOrdinal. But we only want hostOrdinal to\n      // calculate startingPoint. Instead, just randomly select a startingPoint.\n      startingPoint = randomNumberFromInterval(0, this._allLeaseStates.length - 1);\n    } else {\n      for (hostOrdinal = 0; hostOrdinal > sortedHosts.length; hostOrdinal++) {\n        if (sortedHosts[hostOrdinal] === hostName) {\n          break;\n        }\n      }\n      startingPoint = countPerHost * hostOrdinal;\n    }\n    // rotate this._allLeaseStates\n    log.partitionScanner(\n      withHost(\"Host ordinal: %d. Rotating leases to start at: %d.\"),\n      hostOrdinal,\n      startingPoint\n    );\n    if (startingPoint !== 0) {\n      const rotatedList: Array<BaseLease> = [];\n      for (let i = 0; i < this._allLeaseStates.length; i++) {\n        const index = (i + startingPoint) % this._allLeaseStates.length;\n        rotatedList.push(this._allLeaseStates[index]);\n      }\n      this._allLeaseStates = rotatedList;\n    }\n    log.partitionScanner(\n      withHost(\"Host count is %d. So Desired partition count is %d.\"),\n      hostCount,\n      this._desiredCount\n    );\n    log.partitionScanner(\n      withHost(\"our leases count: %d v/s leases owned by others: %d.\"),\n      ourLeasesCount,\n      this._leaseOwnedByOthers.size\n    );\n    log.partitionScanner(withHost(\"Total number of pumps: %d.\"), this._context.pumps.size);\n    return ourLeasesCount;\n  }\n\n  private _findExpiredLeases(startAt: number, endAt: number): BaseLease[] {\n    const withHost = this._context.withHost;\n    const expiredLeases: BaseLease[] = [];\n    log.partitionScanner(\n      withHost(\"Finding expired leases from '%s': [%d] upto '%s': [%d]\"),\n      this._allLeaseStates[startAt].partitionId,\n      startAt,\n      endAt < this._allLeaseStates.length ? this._allLeaseStates[endAt].partitionId : \"end\",\n      endAt\n    );\n    for (const lease of this._allLeaseStates.slice(startAt, endAt)) {\n      if (!lease.isOwned) {\n        expiredLeases.push(lease);\n      }\n    }\n    log.partitionScanner(withHost(\"Found in range: %d\"), expiredLeases.length);\n    return expiredLeases;\n  }\n\n  private _acquireExpiredInParallel(startAt: number, needed: number): Promise<number> {\n    const hostName = this._context.hostName;\n    const withHost = this._context.withHost;\n    const withHostAndPartition = this._context.withHostAndPartition;\n    const resultPromise = Promise.resolve(needed);\n    if (startAt < this._allLeaseStates.length) {\n      const lease = this._allLeaseStates[startAt];\n      const partitionId = lease ? lease.partitionId : \"undefined\";\n      log.partitionScanner(\n        withHost(\"Examining chunk at '%s': [%d], needed %d.\"),\n        partitionId,\n        startAt,\n        needed\n      );\n    } else {\n      log.partitionScanner(withHost(\"Examining chunk skipping, startAt is off end: %d\"), startAt);\n    }\n\n    if (needed > 0 && this._unownedCount > 0 && startAt < this._allLeaseStates.length) {\n      let runningNeeded = needed;\n      const endAt = Math.min(startAt + needed, this._allLeaseStates.length);\n      log.partitionScanner(\n        withHost(\"Finding expired leases from inclusive position range %d - %d\"),\n        startAt,\n        endAt\n      );\n      const getThese: BaseLease[] = this._findExpiredLeases(startAt, endAt);\n      const leaseManager = this._context.leaseManager;\n      const getTheseResult: Promise<void>[] = [];\n      for (const thisLease of getThese) {\n        let lease: CompleteLease | undefined = undefined;\n        const getThisPromise = leaseManager\n          .getLease(thisLease.partitionId)\n          .then((receivedLease) => {\n            lease = receivedLease;\n            if (lease) {\n              return leaseManager.acquireLease(lease);\n            } else {\n              return false;\n            }\n          })\n          .then((acquired) => {\n            if (acquired) {\n              runningNeeded--;\n              log.partitionScanner(\n                withHostAndPartition(thisLease, \"Acquired unowned/expired lease.\")\n              );\n              if (this._leaseOwnedByOthers.has(lease!.partitionId)) {\n                this._leaseOwnedByOthers.delete(lease!.partitionId);\n                this._unownedCount--;\n              }\n              return this._context.pumpManager.addPump(lease!);\n            } else if (lease) {\n              this._leaseOwnedByOthers.set(lease.partitionId, lease);\n            }\n            return Promise.resolve();\n          })\n          .catch((err) => {\n            const msg =\n              `An error occurred while getting/acquiring lease for partitionId ` +\n              `'${thisLease.partitionId}': ${err ? err.stack : JSON.stringify(err)}`;\n            log.error(withHostAndPartition(thisLease, \"%s\"), msg);\n            const info: EPHDiagnosticInfo = {\n              action: EPHActionStrings.checkingLeases,\n              error: new Error(msg),\n              hostName: hostName,\n              partitionId: thisLease.partitionId\n            };\n            this._context.onEphError(info);\n          });\n        getTheseResult.push(getThisPromise);\n      }\n\n      return resultPromise.then(() => {\n        return Promise.all(getTheseResult)\n          .catch((err) => {\n            const msg =\n              `An error occurred while getting/acquiring leases for some partitionId: ` +\n              `${err ? err.stack : JSON.stringify(err)}`;\n            log.error(withHost(\"%s\"), msg);\n          })\n          .then(() => {\n            log.partitionScanner(\n              withHost(\"Calling _acquireExpiredInParallel with startAt %d, \" + \"needed %d.\"),\n              endAt,\n              runningNeeded\n            );\n            return this._acquireExpiredInParallel(endAt, runningNeeded);\n          });\n      });\n    } else {\n      log.partitionScanner(\n        withHost(\"Short circuit: needed is %d, unowned is: %d, off end -> %s.\"),\n        needed,\n        this._unownedCount,\n        startAt < this._allLeaseStates.length\n      );\n    }\n\n    return resultPromise;\n  }\n\n  private _findLeasesToSteal(stealAsk: number): BaseLease[] {\n    // Generate a map of hostnames and owned counts.\n    const hostOwns: Map<string, number> = new Map<string, number>();\n    for (const lease of this._leaseOwnedByOthers.values()) {\n      if (hostOwns.has(lease.owner)) {\n        const newCount = hostOwns.get(lease.owner)! + 1;\n        hostOwns.set(lease.owner, newCount);\n      } else {\n        hostOwns.set(lease.owner, 1);\n      }\n    }\n\n    // Extract hosts which own more than the desired count\n    const bigOwners: Array<string> = [];\n    const withHost = this._context.withHost;\n    for (const entry of hostOwns.entries()) {\n      if (entry[1] > this._desiredCount) {\n        bigOwners.push(entry[0]);\n        log.partitionScanner(withHost(\"Big owner %s has %d\"), entry[0], entry[1]);\n      }\n    }\n    const stealLeases: BaseLease[] = [];\n    if (bigOwners.length > 0) {\n      // Randomly pick one of the big owners\n      const index: number = randomNumberFromInterval(0, bigOwners.length);\n      const bigVictim: string = bigOwners[index];\n      const victimExtra = hostOwns.get(bigVictim)! - this._desiredCount - 1;\n      const stealCount = Math.min(victimExtra, stealAsk);\n      log.partitionScanner(withHost(\"Stealing %d from %s.\"), stealCount, bigVictim);\n\n      // Grab stealCount partitions owned by bigVictim and return the leases.\n      for (const candidate of this._allLeaseStates) {\n        if (candidate.owner != undefined && candidate.owner === bigVictim) {\n          stealLeases.push(candidate);\n          if (stealLeases.length >= stealCount) {\n            break;\n          }\n        }\n      }\n    } else {\n      log.partitionScanner(withHost(\"No big owners found, skipping steal.\"));\n    }\n    return stealLeases;\n  }\n\n  private async _stealLeases(stealThese: BaseLease[]): Promise<boolean> {\n    const withHostAndPartition = this._context.withHostAndPartition;\n    if (stealThese.length > 0) {\n      const steals: Promise<boolean>[] = [];\n      for (const stealableLease of stealThese) {\n        let lease: CompleteLease | undefined = undefined;\n        const tryStealPromise: Promise<boolean> = this._context.leaseManager\n          .getLease(stealableLease.partitionId)\n          .then((receivedLease) => {\n            lease = receivedLease;\n            if (receivedLease) {\n              return this._context.leaseManager.acquireLease(receivedLease);\n            } else {\n              return false;\n            }\n          })\n          .then((acquired) => {\n            if (acquired) {\n              this._context.pumpManager.addPump(lease!).catch();\n              log.partitionScanner(\n                withHostAndPartition(stealableLease, \"Successfully stolen the lease.\")\n              );\n            }\n            return acquired;\n          })\n          .catch((err) => {\n            const msg =\n              `An error occurred while stealing the lease for partitionId ` +\n              `'${stealableLease.partitionId}': ${err ? err.stack : JSON.stringify(err)}`;\n            log.error(withHostAndPartition(stealableLease, \"%s\"), msg);\n            const info: EPHDiagnosticInfo = {\n              action: EPHActionStrings.stealingLease,\n              partitionId: stealableLease.partitionId,\n              hostName: this._context.hostName,\n              error: err\n            };\n            this._context.onEphError(info);\n            return false;\n          });\n        steals.push(tryStealPromise);\n      }\n\n      const stealResult = await Promise.all<boolean>(steals);\n      // If we found at least one case where the lease could not be stolen then `.some()`\n      // returns true. The final result will be true if `.some()` was not able to find a single\n      // lease that could not be stolen.\n      const result = !stealResult.some((x) => {\n        return !x;\n      });\n      return result;\n    } else {\n      return false;\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { HostContextWithPumpManager } from \"./hostContext\";\nimport { validateType, RetryConfig, retry, EPHActionStrings } from \"./util/utils\";\nimport { delay } from \"@azure/event-hubs\";\nimport * as log from \"./log\";\nimport { OnReceivedMessage, OnReceivedError, CloseReason } from \"./modelTypes\";\nimport { PartitionScanner } from \"./partitionScanner\";\n\n/**\n * @ignore\n */\nexport class PartitionManager {\n  private _context: HostContextWithPumpManager;\n  private _partitionScanner: PartitionScanner;\n  private _isCancelRequested: boolean = false;\n  private _isRunning: boolean = false;\n  private _runTask?: Promise<void>;\n\n  constructor(context: HostContextWithPumpManager) {\n    this._context = context;\n    this._partitionScanner = new PartitionScanner(this._context);\n  }\n\n  /**\n   * @ignore\n   */\n  async start(onMessage: OnReceivedMessage, onError: OnReceivedError): Promise<void> {\n    validateType(\"onMessage\", onMessage, true, \"function\");\n    validateType(\"onError\", onError, true, \"function\");\n    if (this._isRunning) {\n      throw new Error(\"A partition manager cannot be started multiple times.\");\n    }\n\n    try {\n      this._reset();\n      this._isRunning = true;\n      this._context.onMessage = onMessage;\n      this._context.onError = onError;\n      await this._cachePartitionIds();\n      await this._initializeStores();\n      this._runTask = this._run();\n    } catch (err) {\n      this._isRunning = false;\n      throw err;\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  async stop(): Promise<void> {\n    const withHost = this._context.withHost;\n    this._isCancelRequested = true;\n    const localRunTask = this._runTask;\n    if (localRunTask) {\n      try {\n        await localRunTask;\n      } catch (err) {\n        const msg =\n          `An error occurred while stopping the run task: ` +\n          `${err ? err.stack : JSON.stringify(err)}.`;\n        log.error(withHost(\"%s\"), msg);\n      } finally {\n        this._isRunning = false;\n      }\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  shouldStop(): boolean {\n    if (this._isCancelRequested) {\n      log.partitionManager(\n        this._context.withHost(\n          \"Cancellation was requested -> %s. \" + \"Hence stopping further execution.\"\n        ),\n        this._isCancelRequested\n      );\n    }\n    return this._isCancelRequested;\n  }\n\n  /**\n   * @ignore\n   */\n  private _reset(): void {\n    const withHost = this._context.withHost;\n    log.partitionManager(withHost(\"Resetting the partition manager.\"));\n    this._context.blobReferenceByPartition = {};\n    this._context.onMessage = undefined;\n    this._context.onError = undefined;\n    this._isRunning = false;\n    this._isCancelRequested = false;\n  }\n\n  /**\n   * @ignore\n   */\n  private async _run(): Promise<void> {\n    const withHost = this._context.withHost;\n    try {\n      await this._scan(true);\n    } catch (err) {\n      const msg =\n        `An error occurred in the main loop of the partition ` +\n        `manager: ${err ? err.stack : JSON.stringify(err)}. Hence shutting down.`;\n      log.error(withHost(\"%s\"), msg);\n      this._context.onEphError({\n        hostName: this._context.hostName,\n        partitionId: \"N/A\",\n        error: err,\n        action: EPHActionStrings.partitionManagerMainLoop\n      });\n    }\n    try {\n      // clean up\n      log.partitionManager(withHost(\"Shutting down all the receivers.\"));\n      await this._context.pumpManager.removeAllPumps(CloseReason.shutdown);\n    } catch (err) {\n      const msg =\n        `An error occurred while shutting down the partition ` +\n        `manager: ${err ? err.stack : JSON.stringify(err)}.`;\n      log.error(withHost(\"%s\"), msg);\n      this._context.onEphError({\n        hostName: this._context.hostName,\n        partitionId: \"N/A\",\n        error: err,\n        action: EPHActionStrings.partitionManagerCleanup\n      });\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private async _cachePartitionIds(): Promise<void> {\n    const hostName = this._context.hostName;\n    const withHost = this._context.withHost;\n    if (!this._context.partitionIds.length) {\n      log.partitionManager(withHost(\"Get the list of partition ids.\"));\n      const config: RetryConfig<string[]> = {\n        hostName: hostName,\n        operation: () => this._context.getPartitionIds(),\n        retryMessage: \"Failure getting partition ids for this Event Hub, retrying\",\n        finalFailureMessage: \"Out of retries for getting partition ids for this Event Hub\",\n        action: EPHActionStrings.gettingPartitionIds,\n        maxRetries: 5\n      };\n      await retry<string[]>(config);\n    }\n  }\n\n  /**\n   * @ignore\n   */\n  private async _initializeStores(): Promise<void> {\n    const hostName = this._context.hostName;\n    const withHost = this._context.withHost;\n    const leaseManager = this._context.leaseManager;\n    const checkpointManager = this._context.checkpointManager;\n\n    validateType(\"this._context.onMessage\", this._context.onMessage, true, \"function\");\n    validateType(\"this._context.onError\", this._context.onError, true, \"function\");\n\n    log.partitionManager(withHost(\"Ensuring that the lease store exists.\"));\n    if (!(await leaseManager.leaseStoreExists())) {\n      const config: RetryConfig<void> = {\n        hostName: hostName,\n        operation: () => leaseManager.createLeaseStoreIfNotExists(),\n        retryMessage: \"Failure creating lease store for this Event Hub, retrying\",\n        finalFailureMessage: \"Out of retries for creating lease store for this Event Hub\",\n        action: EPHActionStrings.creatingLeaseStore,\n        maxRetries: 5\n      };\n      await retry<void>(config);\n    }\n\n    if (this.shouldStop()) return;\n\n    log.partitionManager(withHost(\"Ensure the checkpointstore exists.\"));\n    if (!(await checkpointManager.checkpointStoreExists())) {\n      const config: RetryConfig<void> = {\n        hostName: hostName,\n        operation: () => checkpointManager.createCheckpointStoreIfNotExists(),\n        retryMessage: \"Failure creating checkpoint store for this Event Hub, retrying\",\n        finalFailureMessage: \"Out of retries for creating checkpoint store for this Event Hub\",\n        action: EPHActionStrings.creatingCheckpointStore,\n        maxRetries: 5\n      };\n      await retry<void>(config);\n    }\n\n    if (this.shouldStop()) return;\n\n    log.partitionManager(withHost(\"Ensure that the leases exist.\"));\n    const leaseConfig: RetryConfig<void> = {\n      hostName: hostName,\n      operation: () => leaseManager.createAllLeasesIfNotExists(this._context.partitionIds),\n      retryMessage: \"Failure creating lease for partition, retrying\",\n      finalFailureMessage: \"Out of retries for creating lease for partition\",\n      action: EPHActionStrings.creatingLease,\n      maxRetries: 5\n    };\n    await retry<void>(leaseConfig);\n\n    if (this.shouldStop()) return;\n\n    log.partitionManager(withHost(\"Ensure that the checkpoint exists.\"));\n    const checkpointConfig: RetryConfig<void> = {\n      hostName: hostName,\n      operation: () =>\n        checkpointManager.createAllCheckpointsIfNotExists(this._context.partitionIds),\n      retryMessage: \"Failure creating checkpoint for partition, retrying\",\n      finalFailureMessage: \"Out of retries for creating checkpoint for partition\",\n      action: EPHActionStrings.creatingCheckpoint,\n      maxRetries: 5\n    };\n    await retry<void>(checkpointConfig);\n\n    if (this.shouldStop()) return;\n  }\n\n  /**\n   * @ignore\n   */\n  private async _scan(isFirst: boolean): Promise<void> {\n    const withHost = this._context.withHost;\n    while (!this.shouldStop()) {\n      if (isFirst) {\n        log.partitionManager(withHost(\"Starting the first scan.\"));\n      }\n      const didSteal = await this._partitionScanner.scan(isFirst);\n      log.partitionManager(withHost(\"Did we steal any leases in this scan: %s.\"), didSteal);\n      let seconds: number = didSteal\n        ? this._context.fastScanInterval!\n        : this._context.slowScanInterval!;\n      if (isFirst) {\n        seconds = this._context.startupScanDelay!;\n        isFirst = false;\n      }\n      log.partitionManager(\n        withHost(\"Sleeping for %d seconds before starting the next scan.\"),\n        seconds\n      );\n      await delay(seconds * 1000);\n    }\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nexport const minLeaseDurationInSeconds = 15;\nexport const maxLeaseDurationInSeconds = 60;\nexport const defaultLeaseDurationInSeconds = 30;\nexport const defaultLeaseRenewIntervalInSeconds = 10;\nexport const defaultMaximumExecutionTimeInMs = 120000;\nexport const maximumExecutionTimeInMsForLeaseRenewal = 60000;\nexport const defaultCheckpointTimeoutInSeconds = 120;\nexport const defaultStartupScanDelayInSeconds = 30;\nexport const defaultFastScanIntervalInSeconds = 3;\nexport const defaultSlowScanIntervalInSeconds = 5;\nexport const metadataOwnerName = \"owninghost\";\nexport const leaseLost = \"leaselost\";\nexport const leaseIdMismatchWithLeaseOperation = \"leaseidmismatchwithleaseoperation\";\nexport const leaseIdMismatchWithBlobOperation = \"leaseidmismatchwithbloboperation\";\nexport const defaultConsumerGroup = \"$default\";\nexport const packageInfo = {\n  name: \"@azure/event-processor-host\",\n  version: \"2.1.1\"\n};\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { Dictionary } from \"@azure/event-hubs\";\nimport {\n  createBlobService,\n  BlobService as StorageBlobService,\n  ServiceResponse\n} from \"azure-storage\";\nimport * as log from \"./log\";\nimport { validateType, getStorageError } from \"./util/utils\";\nimport { defaultMaximumExecutionTimeInMs } from \"./util/constants\";\nimport path from \"path\";\n/**\n * @ignore\n */\nexport interface CreateContainerResult {\n  created: StorageBlobService.ContainerResult;\n  details: ServiceResponse;\n}\n\n/**\n * @ignore\n */\nexport enum LeaseState {\n  /**\n   * The lease state is not specified.\n   */\n  unspecified = \"unspecified\",\n\n  /**\n   * The lease is in the \"available\" state.\n   */\n  available = \"available\",\n\n  /**\n   * The lease is in the \"leased\" state.\n   */\n  leased = \"leased\",\n\n  /**\n   * The lease is in the \"expired\" state.\n   */\n  expired = \"expired\",\n\n  /**\n   * The lease is in the \"breaking\" state.\n   */\n  breaking = \"breaking\",\n\n  /**\n   * The lease is in the \"broken\" state.\n   */\n  broken = \"broken\"\n}\n\n/**\n * @ignore\n */\nexport class BlobService {\n  private _hostName: string;\n  private _connectionString: string;\n  private _storageBlobService: StorageBlobService;\n  private _beginningOfTime: string = new Date(1990, 0, 1).toUTCString();\n\n  constructor(hostName: string, connectionString: string) {\n    this._hostName = hostName;\n    this._connectionString = connectionString;\n    this._storageBlobService = createBlobService(this._connectionString);\n    this._storageBlobService.defaultMaximumExecutionTimeInMs = defaultMaximumExecutionTimeInMs;\n  }\n\n  /**\n   * Ensures that the container and blob exist.\n   */\n  async ensureContainerAndBlobExist(containerName: string, blobPath: string): Promise<void> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    const partitionId = path.basename(blobPath);\n    try {\n      await this.ensureContainerExists(containerName);\n      await this.ensureBlobExists(containerName, blobPath, \"{}\");\n    } catch (err) {\n      const msg =\n        `An error occurred while ensuring that the container and blob exists. ` +\n        `It is: \\n${err ? err.stack : JSON.stringify(err)}`;\n      log.error(\"[%s] [%s] %s\", this._hostName, partitionId, msg);\n      throw new Error(msg);\n    }\n  }\n\n  ensureContainerExists(containerName: string): Promise<CreateContainerResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n\n    return new Promise<CreateContainerResult>((resolve, reject) => {\n      log.blobService(\n        \"[%s] Ensuring that the container '%s' exists.\",\n        this._hostName,\n        containerName\n      );\n      this._storageBlobService.createContainerIfNotExists(\n        containerName,\n        (error, result, response) => {\n          if (error) {\n            log.error(\n              \"[%s] An error occurred while ensuring that the container '%s' exists: %O\",\n              this._hostName,\n              containerName,\n              getStorageError(error)\n            );\n            reject(error);\n          } else {\n            const containerInfo = { created: result, details: response };\n            log.blobService(\n              \"[%s] Result for Container '%s': %O\",\n              this._hostName,\n              containerName,\n              containerInfo\n            );\n            resolve(containerInfo);\n          }\n        }\n      );\n    });\n  }\n\n  doesContainerExist(containerName: string): Promise<boolean> {\n    validateType(\"containerName\", containerName, true, \"string\");\n\n    return new Promise<boolean>((resolve, reject) => {\n      this._storageBlobService.doesContainerExist(containerName, (error, result) => {\n        if (error) {\n          log.error(\n            \"[%s] An error occurred while determining whether the container \" + \"'%s' exists: % O.\",\n            this._hostName,\n            containerName,\n            getStorageError(error)\n          );\n          reject(error);\n        } else {\n          log.blobService(\n            \"[%s] Does container '%s' exist -> %s.\",\n            this._hostName,\n            containerName,\n            result.exists\n          );\n          resolve(result.exists);\n        }\n      });\n    });\n  }\n\n  doesBlobExist(containerName: string, blobPath: string): Promise<boolean> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<boolean>((resolve, reject) => {\n      this._storageBlobService.doesBlobExist(containerName, blobPath, (error, result) => {\n        if (error) {\n          log.error(\n            \"[%s] [%s] An error occurred while determining whether the blob '%s' exists in \" +\n              \"container '%s': %O\",\n            this._hostName,\n            partitionId,\n            blobPath,\n            containerName,\n            getStorageError(error)\n          );\n          reject(error);\n        } else {\n          log.blobService(\n            \"[%s] [%s] Does blob '%s' exist in container '%s' -> %s.\",\n            this._hostName,\n            partitionId,\n            blobPath,\n            containerName,\n            result.exists\n          );\n          resolve(result.exists);\n        }\n      });\n    });\n  }\n\n  ensureBlobExists(containerName: string, blobPath: string, text: string): Promise<void> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    validateType(\"text\", text, true, \"string\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<void>((resolve, reject) => {\n      const options: StorageBlobService.CreateBlobRequestOptions = {\n        accessConditions: {\n          DateUnModifiedSince: this._beginningOfTime\n        }\n      };\n      log.blobService(\n        \"[%s] [%s] Ensuring that blob '%s' exists in container '%s'.\",\n        this._hostName,\n        partitionId,\n        blobPath,\n        containerName\n      );\n      this._storageBlobService.createBlockBlobFromText(\n        containerName,\n        blobPath,\n        text,\n        options,\n        (error) => {\n          if (error) {\n            if ((error as any).statusCode === 412) {\n              // Blob already exists.\n              resolve();\n            } else {\n              log.error(\n                \"[%s] [%s] An error occurred while ensuring that blob '%s' exists in \" +\n                  \"container '%s': %O\",\n                this._hostName,\n                partitionId,\n                blobPath,\n                containerName,\n                getStorageError(error)\n              );\n              reject(error);\n            }\n          } else {\n            resolve();\n          }\n        }\n      );\n    });\n  }\n\n  renewLease(\n    containerName: string,\n    blobPath: string,\n    leaseId: string,\n    options: StorageBlobService.LeaseRequestOptions\n  ): Promise<StorageBlobService.LeaseResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    validateType(\"leaseId\", leaseId, true, \"string\");\n    validateType(\"options\", options, false, \"object\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<StorageBlobService.LeaseResult>((resolve, reject) => {\n      if (!options) options = {};\n      log.blobService(\n        \"[%s] [%s] Attempting to renew lease '%s' for blobPath '%s'.\",\n        this._hostName,\n        partitionId,\n        leaseId,\n        blobPath\n      );\n      this._storageBlobService.renewLease(\n        containerName,\n        blobPath,\n        leaseId,\n        options,\n        (error, result) => {\n          if (error) {\n            log.error(\n              \"[%s] [%s] An error occurred while renewing lease '%s' for blobPath '%s': %O.\",\n              this._hostName,\n              partitionId,\n              leaseId,\n              blobPath,\n              getStorageError(error)\n            );\n            reject(error);\n          } else {\n            log.blobService(\n              \"[%s] [%s] Successfully, renewed lease with leaseId: '%s' for blobPath '%s'.\",\n              this._hostName,\n              partitionId,\n              leaseId,\n              blobPath\n            );\n            resolve(result);\n          }\n        }\n      );\n    });\n  }\n\n  releaseLease(\n    containerName: string,\n    blobPath: string,\n    leaseId: string,\n    options?: StorageBlobService.LeaseRequestOptions\n  ): Promise<StorageBlobService.LeaseResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    validateType(\"leaseId\", leaseId, true, \"string\");\n    validateType(\"options\", options, false, \"object\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<StorageBlobService.LeaseResult>((resolve, reject) => {\n      if (!options) options = {};\n      log.blobService(\n        \"[%s] [%s] Attempting to release lease '%s' for blobPath '%s'.\",\n        this._hostName,\n        partitionId,\n        leaseId,\n        blobPath\n      );\n      this._storageBlobService.releaseLease(\n        containerName,\n        blobPath,\n        leaseId,\n        options,\n        (error, result) => {\n          if (error) {\n            log.error(\n              \"[%s] [%s] An error occurred while releasing lease '%s' for blobPath '%s': %O.\",\n              this._hostName,\n              partitionId,\n              leaseId,\n              blobPath,\n              getStorageError(error)\n            );\n            reject(error);\n          } else {\n            log.blobService(\n              \"[%s] [%s] Successfully, released lease with leaseId: '%s' for blobPath '%s'.\",\n              this._hostName,\n              partitionId,\n              leaseId,\n              blobPath\n            );\n            resolve(result);\n          }\n        }\n      );\n    });\n  }\n\n  updateContent(\n    containerName: string,\n    blobPath: string,\n    text: string,\n    options?: StorageBlobService.CreateBlobRequestOptions\n  ): Promise<StorageBlobService.BlobResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    validateType(\"text\", text, true, \"string\");\n    validateType(\"options\", options, false, \"object\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<StorageBlobService.BlobResult>((resolve, reject) => {\n      if (!options) options = {};\n      log.blobService(\n        \"[%s] [%s] Updating content '%s' in the container '%s' of the blob '%s' .\",\n        this._hostName,\n        partitionId,\n        text,\n        containerName,\n        blobPath\n      );\n      this._storageBlobService.createBlockBlobFromText(\n        containerName,\n        blobPath,\n        text,\n        options,\n        (error, result) => {\n          if (error) {\n            log.error(\n              \"[%s] [%s] An error occurred while updating content '%s' to blobPath '%s': %O.\",\n              this._hostName,\n              partitionId,\n              text,\n              blobPath,\n              getStorageError(error)\n            );\n            reject(error);\n          } else {\n            log.blobService(\n              \"[%s] [%s] Successfully, updated blob content '%s' for blobPath '%s'.\",\n              this._hostName,\n              partitionId,\n              text,\n              blobPath\n            );\n            resolve(result);\n          }\n        }\n      );\n    });\n  }\n\n  getContent(\n    containerName: string,\n    blobPath: string,\n    options?: StorageBlobService.GetBlobRequestOptions\n  ): Promise<string> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    validateType(\"options\", options, false, \"object\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise((resolve, reject) => {\n      if (!options) options = {};\n      log.blobService(\n        \"[%s] [%s] Attempting to getcontent from blobPath '%s'.\",\n        this._hostName,\n        partitionId,\n        blobPath\n      );\n      this._storageBlobService.getBlobToText(\n        containerName,\n        blobPath,\n        options,\n        (error, text, result) => {\n          if (error) {\n            log.error(\n              \"[%s] [%s] An error occurred while getting content from blobPath '%s': %O.\",\n              this._hostName,\n              partitionId,\n              blobPath,\n              getStorageError(error)\n            );\n            reject(error);\n          } else {\n            log.blobService(\n              \"[%s] [%s] Successfully, fetched blob content '%s' for blobPath '%s'.\",\n              this._hostName,\n              partitionId,\n              text,\n              blobPath\n            );\n            resolve(text);\n          }\n        }\n      );\n    });\n  }\n\n  changeLease(\n    containerName: string,\n    blobPath: string,\n    currentLeaseId: string,\n    proposedLeaseId: string\n  ): Promise<StorageBlobService.LeaseResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    validateType(\"currentLeaseId\", currentLeaseId, true, \"string\");\n    validateType(\"proposedLeaseId\", proposedLeaseId, true, \"string\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<StorageBlobService.LeaseResult>((resolve, reject) => {\n      log.blobService(\n        \"[%s] [%s] Attempting to change lease '%s' for blobPath '%s' with new lease '%s'.\",\n        this._hostName,\n        partitionId,\n        currentLeaseId,\n        blobPath,\n        proposedLeaseId\n      );\n      this._storageBlobService.changeLease(\n        containerName,\n        blobPath,\n        currentLeaseId,\n        proposedLeaseId,\n        (error, result) => {\n          if (error) {\n            log.error(\n              \"[%s] [%s] An error occurred while changing lease '%s' to '%s' for blobPath \" +\n                \"'%s': %O.\",\n              this._hostName,\n              partitionId,\n              currentLeaseId,\n              proposedLeaseId,\n              blobPath,\n              error\n            );\n            reject(error);\n          } else {\n            log.blobService(\n              \"[%s] [%s] Successfully, changed current lease '%s' with proposed lease \" +\n                \"'%s' for blobPath '%s'.\",\n              this._hostName,\n              partitionId,\n              currentLeaseId,\n              proposedLeaseId,\n              blobPath\n            );\n            resolve(result);\n          }\n        }\n      );\n    });\n  }\n\n  getBlobProperties(\n    containerName: string,\n    blobPath: string\n  ): Promise<StorageBlobService.BlobResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<StorageBlobService.BlobResult>((resolve, reject) => {\n      log.blobService(\n        \"[%s] [%s] Attempting to get blob props for blobPath '%s'.\",\n        this._hostName,\n        partitionId,\n        blobPath\n      );\n      this._storageBlobService.getBlobProperties(containerName, blobPath, (error, result) => {\n        if (error) {\n          log.error(\n            \"[%s] [%s] An error occurred while getting blob props for blobPath '%s': %O.\",\n            this._hostName,\n            partitionId,\n            blobPath,\n            getStorageError(error)\n          );\n          reject(error);\n        } else {\n          log.blobService(\n            \"[%s] [%s] Successfully, got blob props for blobPath '%s'.\",\n            this._hostName,\n            partitionId,\n            blobPath\n          );\n          resolve(result);\n        }\n      });\n    });\n  }\n\n  listBlobsSegmented(\n    containerName: string,\n    options?: StorageBlobService.ListBlobsSegmentedRequestOptions\n  ): Promise<StorageBlobService.ListBlobsResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    if (!options) {\n      options = {\n        maxResults: 5000,\n        include: \"metadata\"\n      };\n    }\n    return new Promise<StorageBlobService.ListBlobsResult>((resolve, reject) => {\n      log.blobService(\n        \"[%s] Attempting to list blobs for container '%s'.\",\n        this._hostName,\n        containerName\n      );\n      this._storageBlobService.listBlobsSegmented(\n        containerName,\n        undefined as any,\n        options!,\n        (error, result) => {\n          if (error) {\n            log.error(\n              \"[%s] An error occurred while listing blobs for container '%s': %O.\",\n              this._hostName,\n              containerName,\n              getStorageError(error)\n            );\n            reject(error);\n          } else {\n            log.blobService(\n              \"[%s] Successfully, received the list of blobs for container '%s'.\",\n              this._hostName,\n              containerName\n            );\n            resolve(result);\n          }\n        }\n      );\n    });\n  }\n\n  getBlobMetadata(containerName: string, blobPath: string): Promise<StorageBlobService.BlobResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<StorageBlobService.BlobResult>((resolve, reject) => {\n      log.blobService(\n        \"[%s] [%s] Attempting to get blob metadata for blobPath '%s'.\",\n        this._hostName,\n        partitionId,\n        blobPath\n      );\n      this._storageBlobService.getBlobMetadata(containerName, blobPath, (error, result) => {\n        if (error) {\n          log.error(\n            \"[%s] [%s] An error occurred while getting blob metadata for blobPath '%s': %O.\",\n            this._hostName,\n            partitionId,\n            blobPath,\n            getStorageError(error)\n          );\n          reject(error);\n        } else {\n          log.blobService(\n            \"[%s] [%s] Successfully, got the blob metadata %o for blobPath '%s'.\",\n            this._hostName,\n            partitionId,\n            result,\n            blobPath\n          );\n          resolve(result);\n        }\n      });\n    });\n  }\n\n  setBlobMetadata(\n    containerName: string,\n    blobPath: string,\n    metadata: Dictionary<string>,\n    options?: StorageBlobService.BlobRequestOptions\n  ): Promise<StorageBlobService.BlobResult> {\n    if (!options) options = {};\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    validateType(\"metadata\", metadata, true, \"object\");\n    validateType(\"options\", options, true, \"object\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<StorageBlobService.BlobResult>((resolve, reject) => {\n      log.blobService(\n        \"[%s] [%s] Attempting to set blob metadata %o for blobPath '%s'.\",\n        this._hostName,\n        partitionId,\n        metadata,\n        blobPath\n      );\n      this._storageBlobService.setBlobMetadata(\n        containerName,\n        blobPath,\n        metadata,\n        options!,\n        (error, result) => {\n          if (error) {\n            log.error(\n              \"[%s] [%s] An error occurred while setting blob metadata for blobPath '%s': %O.\",\n              this._hostName,\n              partitionId,\n              blobPath,\n              getStorageError(error)\n            );\n            reject(error);\n          } else {\n            log.blobService(\n              \"[%s] [%s] Successfully, set the blob metadata for blobPath '%s'. \" +\n                \"The result is: name: %s, metadata: %o, lease: %o\",\n              this._hostName,\n              partitionId,\n              blobPath,\n              result.name,\n              result.metadata,\n              result.lease\n            );\n            resolve(result);\n          }\n        }\n      );\n    });\n  }\n\n  acquireLease(\n    containerName: string,\n    blobPath: string,\n    options: StorageBlobService.AcquireLeaseRequestOptions\n  ): Promise<StorageBlobService.LeaseResult> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    validateType(\"options\", options, false, \"object\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<StorageBlobService.LeaseResult>((resolve, reject) => {\n      if (!options) options = {};\n      log.blobService(\n        \"[%s] [%s] Attempting to acquire lease for blobPath '%s'.\",\n        this._hostName,\n        partitionId,\n        blobPath\n      );\n      this._storageBlobService.acquireLease(containerName, blobPath, options, (error, result) => {\n        if (error) {\n          log.error(\n            \"[%s] [%s] An error occurred while acquiring lease for blobPath '%s': %O.\",\n            this._hostName,\n            partitionId,\n            blobPath,\n            getStorageError(error)\n          );\n          reject(error);\n        } else {\n          log.blobService(\n            \"[%s] [%s] Acquired lease '%s' for blobPath '%s.\",\n            this._hostName,\n            partitionId,\n            result.id,\n            blobPath\n          );\n          resolve(result);\n        }\n      });\n    });\n  }\n\n  async deleteBlobIfExists(containerName: string, blobPath: string): Promise<void> {\n    validateType(\"containerName\", containerName, true, \"string\");\n    validateType(\"blobPath\", blobPath, true, \"string\");\n    const partitionId = path.basename(blobPath);\n\n    return new Promise<void>((resolve, reject) => {\n      log.blobService(\n        \"[%s] Attempting to delete blob for blobPath '%s'.\",\n        this._hostName,\n        partitionId,\n        blobPath\n      );\n      this._storageBlobService.deleteBlobIfExists(containerName, blobPath, (error, result) => {\n        if (error) {\n          log.error(\n            \"[%s] An error occurred while deleting blob for blobPath '%s': %O.\",\n            this._hostName,\n            partitionId,\n            blobPath,\n            getStorageError(error)\n          );\n          reject(error);\n        } else {\n          log.blobService(\n            \"[%s] [%s] Deleted blob '%s' ->  %s.\",\n            this._hostName,\n            partitionId,\n            partitionId,\n            blobPath,\n            result\n          );\n          resolve();\n        }\n      });\n    });\n  }\n\n  async deleteContainerIfExists(containerName: string): Promise<void> {\n    validateType(\"containerName\", containerName, true, \"string\");\n\n    return new Promise<void>((resolve, reject) => {\n      log.blobService(\"[%s] Attempting to delete container '%s'.\", this._hostName, containerName);\n      this._storageBlobService.deleteContainerIfExists(containerName, (error, result) => {\n        if (error) {\n          log.error(\n            \"[%s] An error occurred while deleting container '%s': %O.\",\n            this._hostName,\n            containerName,\n            getStorageError(error)\n          );\n          reject(error);\n        } else {\n          log.blobService(\n            \"[%s] Deleted container '%s' ->  %s.\",\n            this._hostName,\n            containerName,\n            result\n          );\n          resolve();\n        }\n      });\n    });\n  }\n\n  static create(hostName: string, connectionString: string): BlobService {\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"connectionString\", connectionString, true, \"string\");\n\n    return new BlobService(hostName, connectionString);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { BlobService, CreateContainerResult } from \"./blobService\";\nimport { BlobService as StorageBlobService } from \"azure-storage\";\nimport { Dictionary } from \"@azure/event-hubs\";\n\n/**\n * @ignore\n */\nexport class AzureBlob {\n  private _blobService: BlobService;\n  private _containerName: string;\n  private _blobPath: string;\n  private _containerAndBlobExist: boolean = false;\n\n  constructor(\n    hostName: string,\n    connectionString: string,\n    containerName: string,\n    blob: string,\n    blobService?: BlobService\n  ) {\n    this._blobPath = blob;\n    this._containerName = containerName;\n    this._blobService = blobService || BlobService.create(hostName, connectionString);\n  }\n\n  async ensureContainerAndBlobExist(): Promise<void> {\n    try {\n      if (!this._containerAndBlobExist) {\n        await this._blobService.ensureContainerAndBlobExist(this._containerName, this._blobPath);\n        this._containerAndBlobExist = true;\n      }\n    } catch (err) {\n      const msg =\n        `An error occurred while ensuring that the container and blob exists. ` +\n        `It is: \\n${err ? err.stack : JSON.stringify(err)}`;\n      throw new Error(msg);\n    }\n  }\n\n  ensureContainerExists(): Promise<CreateContainerResult> {\n    return this._blobService.ensureContainerExists(this._containerName);\n  }\n\n  doesContainerExist(): Promise<boolean> {\n    return this._blobService.doesContainerExist(this._containerName);\n  }\n\n  doesBlobExist(): Promise<boolean> {\n    return this._blobService.doesBlobExist(this._containerName, this._blobPath);\n  }\n\n  ensureBlobExists(text: string): Promise<void> {\n    return this._blobService.ensureBlobExists(this._containerName, this._blobPath, text);\n  }\n\n  renewLease(\n    leaseId: string,\n    options: StorageBlobService.LeaseRequestOptions\n  ): Promise<StorageBlobService.LeaseResult> {\n    return this._blobService.renewLease(this._containerName, this._blobPath, leaseId, options);\n  }\n\n  releaseLease(\n    leaseId: string,\n    options?: StorageBlobService.LeaseRequestOptions\n  ): Promise<StorageBlobService.LeaseResult> {\n    return this._blobService.releaseLease(this._containerName, this._blobPath, leaseId, options);\n  }\n\n  updateContent(\n    text: string,\n    options?: StorageBlobService.CreateBlobRequestOptions\n  ): Promise<StorageBlobService.BlobResult> {\n    return this._blobService.updateContent(this._containerName, this._blobPath, text, options);\n  }\n\n  getContent(options?: StorageBlobService.GetBlobRequestOptions): Promise<string> {\n    return this._blobService.getContent(this._containerName, this._blobPath, options);\n  }\n\n  changeLease(\n    currentLeaseId: string,\n    proposedLeaseId: string\n  ): Promise<StorageBlobService.LeaseResult> {\n    return this._blobService.changeLease(\n      this._containerName,\n      this._blobPath,\n      currentLeaseId,\n      proposedLeaseId\n    );\n  }\n\n  getBlobProperties(): Promise<StorageBlobService.BlobResult> {\n    return this._blobService.getBlobProperties(this._containerName, this._blobPath);\n  }\n\n  getBlobMetadata(): Promise<StorageBlobService.BlobResult> {\n    return this._blobService.getBlobMetadata(this._containerName, this._blobPath);\n  }\n\n  setBlobMetadata(\n    metadata: Dictionary<string>,\n    options?: StorageBlobService.BlobRequestOptions\n  ): Promise<StorageBlobService.BlobResult> {\n    return this._blobService.setBlobMetadata(\n      this._containerName,\n      this._blobPath,\n      metadata,\n      options\n    );\n  }\n\n  listBlobsSegmented(\n    options?: StorageBlobService.ListBlobsSegmentedRequestOptions\n  ): Promise<StorageBlobService.ListBlobsResult> {\n    return this._blobService.listBlobsSegmented(this._containerName, options);\n  }\n\n  acquireLease(\n    options: StorageBlobService.AcquireLeaseRequestOptions\n  ): Promise<StorageBlobService.LeaseResult> {\n    return this._blobService.acquireLease(this._containerName, this._blobPath, options);\n  }\n\n  deleteBlobIfExists(): Promise<void> {\n    return this._blobService.deleteBlobIfExists(this._containerName, this._blobPath);\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\n/**\n * Describes the basic information required in a lease.\n */\nexport interface BaseLeaseInfo {\n  /**\n   * @property {string} partitionId The associated partitionId for which the lease is held.\n   */\n  partitionId: string;\n  /**\n   * @property {string} owner The host owner for the partition.\n   */\n  owner: string;\n}\n\n/**\n * Describes the base lease.\n */\nexport class BaseLease implements BaseLeaseInfo {\n  /**\n   * @property {string} partitionId The associated partitionId for which the lease is held.\n   * @readonly\n   */\n  readonly partitionId: string;\n  /**\n   * @property {string} owner The host owner for the partition.\n   */\n  owner: string;\n  /**\n   * @property {boolean} isOwned Indicates wether the lease is owned. `true` if it is owned by\n   * someone; `false` otherwise.\n   */\n  isOwned: boolean = false;\n\n  /**\n   * @constructor\n   * @param info The information required to create a base lease.\n   */\n  constructor(info: BaseLeaseInfo) {\n    this.partitionId = info.partitionId;\n    this.owner = info.owner;\n  }\n\n  /**\n   * Compares possibleOwner against this.owner\n   * @param {string} possibleOwner The owner name to check.\n   * @returns {boolean} boolean - true if possibleOwner is the same as this.owner, false otherwise.\n   */\n  isOwnedBy(possibleOwner: string): boolean {\n    return this.owner === possibleOwner;\n  }\n\n  /**\n   * Gets the lease information.\n   * @returns {CompleteLeaseInfo} CompleteLeaseInfo.\n   */\n  getInfo(): BaseLeaseInfo {\n    const info: BaseLeaseInfo = {\n      partitionId: this.partitionId,\n      owner: this.owner\n    };\n    return info;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport * as log from \"./log\";\nimport { BaseLease, BaseLeaseInfo } from \"./baseLease\";\n\n/**\n * Describes the properties of a Complete Lease.\n * @interface CompleteLeaseInfo\n */\nexport interface CompleteLeaseInfo extends BaseLeaseInfo {\n  /**\n   * @property {number} epoch The epoch(time) of the lease, which is a value you can use to\n   * determine the most recent owner of a partition between competing nodes.\n   */\n  epoch: number;\n}\n\n/**\n * Describes a Complete Lease.\n * @class CompleteLease.\n */\nexport class CompleteLease extends BaseLease {\n  /**\n   * @property {number} epoch The epoch(time) of the lease, which is a value you can use to\n   * determine the most recent owner of a partition between competing nodes.\n   */\n  epoch: number;\n\n  /**\n   * Creates an instance of the Lease.\n   * @constructor\n   * @param {CompleteLeaseInfo} info The Lease info.\n   */\n  constructor(info: CompleteLeaseInfo) {\n    super(info);\n    this.epoch = info.epoch != undefined ? info.epoch : -1;\n  }\n\n  /**\n   * Increments the value of epoch by 1.\n   * @returns {number} The incremented value of the epoch.\n   */\n  incrementEpoch(): number {\n    const result = ++this.epoch;\n    log.completeLease(\"[%s] [%s] New epoch for lease is %s.\", this.owner, this.partitionId, result);\n    return result;\n  }\n\n  /**\n   * Gets the lease information.\n   * @returns {CompleteLeaseInfo} CompleteLeaseInfo.\n   */\n  getInfo(): CompleteLeaseInfo {\n    const info = super.getInfo() as CompleteLeaseInfo;\n    info.epoch = this.epoch;\n    log.completeLease(\"[%s] [%s] Lease info is: %o\", this.owner, this.partitionId, info);\n    return info;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport { CompleteLeaseInfo, CompleteLease } from \"./completeLease\";\nimport { AzureBlob } from \"./azureBlob\";\nimport * as log from \"./log\";\n\n/**\n * Describes the properties of a lease.\n * @interface LeaseInfo\n */\nexport interface LeaseInfo extends CompleteLeaseInfo {\n  /**\n   * @property {string} token The lease token that manages concurrency between hosts. You can use\n   * this token to guarantee single access to any resource needed by the EPH.\n   */\n  token: string;\n  /**\n   * @property {string} sequenceNumber The sequence number of the event to be checked in.\n   */\n  sequenceNumber: number;\n  /**\n   * @property {string} offset The offset of the event to be checked in.\n   */\n  offset?: string;\n}\n\n/**\n * Describes the properties of a lease representing an Azure Blob.\n * @interface AzureBlobLeaseInfo\n */\nexport interface AzureBlobLeaseInfo extends LeaseInfo {\n  /**\n   * @property {AzureBlob} blob Reference to the azure blob.\n   */\n  blob: AzureBlob;\n}\n\n/**\n * Describes the lease used with an Azure Blob for storing the checkpoint information.\n */\nexport class AzureBlobLease extends CompleteLease implements AzureBlobLeaseInfo {\n  // It is important to keep the offset optional. While getting the startingCheckpoint in\n  // PartitionContext.getInitialOffset(), we internally call leaseManager.getCheckpoint() which will\n  // return undefined, if the offset is undefined. At that time, if the user had provided\n  // initialOffset using the EPHOptions then that will be used. Thus not initializing the offset\n  // with default value of \"-1\" is crucial to ensure that user provided initial offset is honored\n  // when a new lease container is used.\n  /**\n   * @property {string} offset The offset of the event to be checked in.\n   */\n  offset?: string;\n  /**\n   * @property {string} sequenceNumber The sequence number of the event to be checked in.\n   */\n  sequenceNumber: number;\n  /**\n   * @property {string} token The lease token that manages concurrency between hosts. You can use\n   * this token to guarantee single access to any resource needed by the EPH.\n   */\n  token: string;\n  /**\n   * @property {AzureBlob} blob Reference to the azure blob.\n   */\n  blob: AzureBlob;\n\n  constructor(info: AzureBlobLeaseInfo) {\n    super(info);\n    this.offset = info.offset;\n    this.sequenceNumber = info.sequenceNumber != undefined ? info.sequenceNumber : 0;\n    this.token = info.token || \"\";\n    this.blob = info.blob;\n  }\n\n  /**\n   * Gets the lease information.\n   * @returns {LeaseInfo} LeaseInfo.\n   */\n  getInfo(): LeaseInfo {\n    const info = super.getInfo() as LeaseInfo;\n    info.sequenceNumber = this.sequenceNumber;\n    info.token = this.token;\n    info.offset = this.offset;\n    log.azurebloblease(\"[%s] [%s] Lease info is: %o\", this.owner, this.partitionId, info);\n    return info as LeaseInfo;\n  }\n\n  /**\n   * Serializes the lease information.\n   * @returns {string} string The serialized lease info.\n   */\n  serialize(): string {\n    return JSON.stringify(this.getInfo());\n  }\n\n  /**\n   * Creates a Lease for the given partitionId.\n   * @param {string} id The partitionId for which the lease needs to be created.\n   * @param {AzureBlob} blob The azure blob reference\n   * @returns {CompleteLease} Lease.\n   */\n  static createFromPartitionId(id: string, blob: AzureBlob): AzureBlobLease {\n    return new AzureBlobLease({\n      partitionId: id,\n      epoch: -1,\n      sequenceNumber: 0,\n      owner: \"\",\n      token: \"\",\n      blob: blob\n    });\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport { CheckpointInfo } from \"./checkpointInfo\";\nimport { CheckpointManager } from \"./checkpointManager\";\nimport { LeaseManager } from \"./leaseManager\";\nimport { BaseHostContext } from \"./hostContext\";\nimport { AzureBlob } from \"./azureBlob\";\nimport { validateType, getStorageError, EPHActionStrings } from \"./util/utils\";\nimport { CompleteLease } from \"./completeLease\";\nimport { AzureBlobLease, AzureBlobLeaseInfo, LeaseInfo } from \"./azureBlobLease\";\nimport { BlobService as StorageBlobService, StorageError } from \"azure-storage\";\nimport { LeaseState } from \"./blobService\";\nimport { BaseLease, BaseLeaseInfo } from \"./baseLease\";\nimport { EPHDiagnosticInfo } from \"./modelTypes\";\nimport {\n  maximumExecutionTimeInMsForLeaseRenewal,\n  metadataOwnerName,\n  leaseLost,\n  leaseIdMismatchWithLeaseOperation,\n  leaseIdMismatchWithBlobOperation\n} from \"./util/constants\";\nimport * as log from \"./log\";\nimport path from \"path\";\n\n/**\n * @ignore\n */\nenum UploadActivity {\n  create = \"create\",\n  acquire = \"acquire\",\n  release = \"release\",\n  update = \"update\"\n}\n\n/**\n * @ignore\n */\nexport class AzureStorageCheckpointLeaseManager implements CheckpointManager, LeaseManager {\n  leaseRenewInterval: number;\n  leaseDuration: number;\n  private _context: BaseHostContext;\n  private _latestCheckpoint: Map<string, CheckpointInfo> = new Map<string, CheckpointInfo>();\n\n  constructor(context: BaseHostContext) {\n    this._context = context;\n    this.leaseDuration = this._context.leaseDuration;\n    this.leaseRenewInterval = this._context.leaseRenewInterval;\n  }\n\n  getAzureBlob(partitionId: string): AzureBlob {\n    validateType(\"partitionId\", partitionId, true, \"string\");\n    let result = this._context.blobReferenceByPartition[partitionId];\n    if (!result) {\n      const blobPath = `${this._context.composedBlobPrefix}${partitionId}`;\n      result = new AzureBlob(\n        this._context.hostName,\n        this._context.storageConnectionString!,\n        this._context.storageContainerName!,\n        blobPath,\n        this._context.blobService\n      );\n      this._context.blobReferenceByPartition[partitionId] = result;\n    }\n    return result;\n  }\n\n  async downloadLease(partitionId: string, blob: AzureBlob): Promise<AzureBlobLease> {\n    try {\n      const text: string = await blob.getContent();\n      const jsonLease: LeaseInfo = JSON.parse(text);\n      const blobLeaseInfo: AzureBlobLeaseInfo = {\n        ...jsonLease,\n        blob: blob\n      };\n      return new AzureBlobLease(blobLeaseInfo);\n    } catch (err) {\n      const msg =\n        `An error occurred while downloading the lease for blobPath ` +\n        `\"${this._context.composedBlobPrefix}${partitionId}\". It is: \\n` +\n        `${err ? err.stack : JSON.stringify(err)}`;\n      log.error(this._context.withHost(msg));\n      throw new Error(msg);\n    }\n  }\n\n  leaseStoreExists(): Promise<boolean> {\n    return this._context.blobService!.doesContainerExist(this._context.storageContainerName!);\n  }\n\n  async createLeaseStoreIfNotExists(): Promise<void> {\n    await this._context.blobService!.ensureContainerExists(this._context.storageContainerName!);\n    return;\n  }\n\n  async deleteLeaseStore(): Promise<void> {\n    const blobService = this._context.blobService;\n    const storageContainerName = this._context.storageContainerName!;\n    try {\n      if (blobService) {\n        const listResult = await blobService.listBlobsSegmented(storageContainerName);\n        const deleteBlobs: Promise<void>[] = [];\n        for (const blob of listResult.entries) {\n          deleteBlobs.push(blobService.deleteBlobIfExists(storageContainerName, blob.name));\n        }\n        await Promise.all(deleteBlobs);\n        await blobService.deleteContainerIfExists(storageContainerName);\n      } else {\n        throw new Error(\n          \"'blobService' is not defined in the 'hostContext', hence cannot \" + \"list all the blobs.\"\n        );\n      }\n    } catch (err) {\n      const msg =\n        `An error occurred while deleting the lease store '${storageContainerName}': %O` +\n        `${err ? err.stack : JSON.stringify(err)}`;\n      log.error(this._context.withHost(msg));\n      const info: EPHDiagnosticInfo = {\n        error: new Error(msg),\n        hostName: this._context.hostName,\n        partitionId: \"N/A\",\n        action: EPHActionStrings.deletingLeaseStore\n      };\n      this._context.onEphError(info);\n    }\n  }\n\n  async getLease(partitionId: string): Promise<AzureBlobLease | undefined> {\n    validateType(\"partitionId\", partitionId, true, \"string\");\n    let result: AzureBlobLease | undefined;\n    const blob = this.getAzureBlob(partitionId);\n    const withHostAndPartition = this._context.withHostAndPartition;\n    log.checkpointLeaseMgr(withHostAndPartition(partitionId, \"Getting lease.\"));\n    try {\n      if (await blob.doesBlobExist()) {\n        result = await this.downloadLease(partitionId, blob);\n      }\n    } catch (err) {\n      const msg =\n        `An error occurred while getting lease for partitionId '${partitionId}': \\n` +\n        `${err ? err.stack : JSON.stringify(err)}`;\n      log.error(withHostAndPartition(partitionId, msg));\n      throw new Error(msg);\n    }\n    return result;\n  }\n\n  async getAllLeases(): Promise<BaseLease[]> {\n    const result: BaseLease[] = [];\n    const withHost = this._context.withHost;\n    const withHostAndPartition = this._context.withHostAndPartition;\n    try {\n      const leaseBlobs: StorageBlobService.BlobResult[] = await this._listBlobs();\n      for (const lbi of leaseBlobs) {\n        const name = lbi.name;\n        const partitionId = path.basename(name);\n        const leaseInfo: BaseLeaseInfo = {\n          partitionId: partitionId,\n          owner: lbi.metadata![metadataOwnerName]\n        };\n        const lease = new BaseLease(leaseInfo);\n        lease.isOwned = (lbi.lease && lbi.lease.state === LeaseState.leased) || false;\n        result.push(lease);\n        log.checkpointLeaseMgr(\n          withHostAndPartition(\n            partitionId,\n            \"BlobResult item from the list \" + \"of blobs is: name: %s, lease: %o, metadata: %o.\"\n          ),\n          lbi.name,\n          lbi.lease,\n          lbi.metadata\n        );\n      }\n    } catch (err) {\n      const info: EPHDiagnosticInfo = {\n        error: err,\n        action: EPHActionStrings.gettingAllLeases,\n        hostName: this._context.hostName,\n        partitionId: \"N/A\"\n      };\n      this._context.onEphError(info);\n    }\n    log.checkpointLeaseMgr(withHost(\"Number of leases: %d\"), result.length);\n    return result;\n  }\n\n  async createAllLeasesIfNotExists(partitionIds: string[]): Promise<void> {\n    try {\n      const withHost = this._context.withHost;\n      const leaseBlobs = await this._listBlobs();\n      if (leaseBlobs.length === partitionIds.length) {\n        log.checkpointLeaseMgr(\n          withHost(\n            \"Number of blobs %d === Number of partitionIds %d. \" + \"Hence no need to create leases.\"\n          ),\n          leaseBlobs.length,\n          partitionIds.length\n        );\n        return;\n      } else {\n        const createPromises: Promise<CompleteLease>[] = [];\n        for (const id of partitionIds) {\n          const createPromise: Promise<CompleteLease> = this.createLeaseIfNotExists(id);\n          createPromises.push(createPromise);\n        }\n        await Promise.all(createPromises);\n      }\n    } catch (err) {\n      const info: EPHDiagnosticInfo = {\n        error: err,\n        action: EPHActionStrings.creatingAllLeases,\n        hostName: this._context.hostName,\n        partitionId: \"N/A\"\n      };\n      this._context.onEphError(info);\n      throw err;\n    }\n  }\n\n  async createLeaseIfNotExists(partitionId: string): Promise<CompleteLease> {\n    validateType(\"partitionId\", partitionId, true, \"string\");\n    const withHostAndPartition = this._context.withHostAndPartition;\n    log.checkpointLeaseMgr(withHostAndPartition(partitionId, \"createLeaseIfNotExists.\"));\n    let returnLease: AzureBlobLease;\n    try {\n      const blob = this.getAzureBlob(partitionId);\n      returnLease = AzureBlobLease.createFromPartitionId(partitionId, blob);\n      await this._uploadLease(returnLease, UploadActivity.create);\n    } catch (error) {\n      const statusCode = (error as StorageError).statusCode;\n      const code = (error as StorageError).code;\n      // https://docs.microsoft.com/en-us/rest/api/storageservices/blob-service-error-codes\n      // LeaseIdMissing || BlobAlreadyExists\n      if (\n        (statusCode === 412 && code && code.toLowerCase() === \"leaseidmissing\") ||\n        (statusCode === 409 && code && code.toLowerCase() === \"blobalreadyexists\")\n      ) {\n        returnLease = <AzureBlobLease>await this.getLease(partitionId);\n      } else {\n        log.error(\n          withHostAndPartition(\n            partitionId,\n            \"An error occurred while creating lease if \" + \"it does not exist: %O.\"\n          ),\n          error\n        );\n        throw error;\n      }\n    }\n    return returnLease;\n  }\n\n  async deleteLease(lease: AzureBlobLease): Promise<void> {\n    try {\n      return await lease.blob.deleteBlobIfExists();\n    } catch (err) {\n      const msg =\n        `An error occurred while deleting the lease for blobPath ` +\n        `\"${this._context.composedBlobPrefix}${lease.partitionId}\". It is: \\n` +\n        `${err ? err.stack : JSON.stringify(err)}`;\n      log.error(this._context.withHostAndPartition(lease, msg));\n      throw new Error(msg);\n    }\n  }\n\n  async acquireLease(lease: AzureBlobLease): Promise<boolean> {\n    let result: boolean = true;\n    const newLeaseId: string = uuid();\n    const withHostAndPartition = this._context.withHostAndPartition;\n    try {\n      // TODO: We are initializing newToken to empty string.\n      let newToken: string = \"\";\n      const blobResult = await lease.blob.getBlobProperties();\n      if (blobResult.lease && blobResult.lease.state && blobResult.lease.state === \"leased\") {\n        if (!lease.token) {\n          // We reach here in a race condition: when this instance of EventProcessorHost scanned the\n          // lease blobs, this partition was unowned (token is empty) but between then and now, another\n          // instance of EPH has established a lease (getLeaseState() is LEASED). We normally enforce\n          // that we only steal the lease if it is still owned by the instance which owned it when we\n          // scanned, but we can't do that when we don't know who owns it. The safest thing to do is just\n          // fail the acquisition. If that means that one EPH instance gets more partitions than it should,\n          // rebalancing will take care of that quickly enough.\n          return false;\n        }\n        log.checkpointLeaseMgr(\n          withHostAndPartition(\n            lease,\n            \"Need to change lease '%s' -> '%s' \" + \"for partitionId '%s'.\"\n          ),\n          lease.token,\n          newLeaseId,\n          lease.partitionId\n        );\n        const changeLeaseResult = await lease.blob.changeLease(lease.token, newLeaseId);\n        newToken = changeLeaseResult.id;\n      } else {\n        try {\n          const options: StorageBlobService.AcquireLeaseRequestOptions = {\n            leaseDuration: this.leaseDuration,\n            proposedLeaseId: newLeaseId\n          };\n          const acquireResult = await lease.blob.acquireLease(options);\n          newToken = acquireResult.id;\n        } catch (err) {\n          const statusCode = err && (err as StorageError).statusCode;\n          const code = err && (err as StorageError).code;\n          if (statusCode === 409 && code && code.toLowerCase() === \"leasealreadypresent\") {\n            // Either some other host grabbed the lease or checkpoint call renewed it.\n            return false;\n          }\n        }\n      }\n      lease.token = newToken;\n      lease.owner = this._context.hostName;\n      // Increment epoch each time lease is acquired or stolen by a new host\n      lease.incrementEpoch();\n      await this._uploadLease(lease, UploadActivity.acquire);\n    } catch (err) {\n      if (this._wasLeaseLost(lease.partitionId, err)) {\n        result = false;\n      } else {\n        throw err;\n      }\n    }\n    return result;\n  }\n\n  async renewLease(lease: AzureBlobLease): Promise<boolean> {\n    let result: boolean = false;\n    try {\n      const options: StorageBlobService.LeaseRequestOptions = {\n        timeoutIntervalInMs: this.leaseRenewInterval * 1000,\n        maximumExecutionTimeInMs: maximumExecutionTimeInMsForLeaseRenewal\n      };\n      await lease.blob.renewLease(lease.token, options);\n      result = true;\n    } catch (err) {\n      if (!this._wasLeaseLost(lease.partitionId, err)) {\n        throw err;\n      }\n    }\n    return result;\n  }\n\n  async releaseLease(lease: AzureBlobLease): Promise<void> {\n    const withHostAndPartition = this._context.withHostAndPartition;\n    try {\n      const leaseId: string = lease.token;\n      log.checkpointLeaseMgr(withHostAndPartition(lease, \"Trying to release the lease.\"));\n      const releasedCopy = new AzureBlobLease({ ...lease.getInfo(), blob: lease.blob });\n      releasedCopy.owner = \"\";\n      releasedCopy.token = \"\";\n      await this._uploadLease(lease, UploadActivity.release);\n      await lease.blob.releaseLease(leaseId);\n    } catch (err) {\n      if (!this._wasLeaseLost(lease.partitionId, err)) {\n        throw err;\n      }\n    }\n    return;\n  }\n\n  async updateLease(lease: AzureBlobLease): Promise<boolean> {\n    const withHostAndPartition = this._context.withHostAndPartition;\n    if (lease == undefined) {\n      return false;\n    }\n\n    if (!lease.token) {\n      return false;\n    }\n\n    log.checkpointLeaseMgr(\n      withHostAndPartition(\n        lease,\n        \"Let us renew the lease to make sure the \" +\n          \"update with offset '%s' and sequence number %d will go through.\"\n      ),\n      lease.offset,\n      lease.sequenceNumber\n    );\n    let result = await this.renewLease(lease);\n    if (result) {\n      try {\n        await this._uploadLease(lease, UploadActivity.update);\n      } catch (err) {\n        if (this._wasLeaseLost(lease.partitionId, err)) {\n          result = false;\n        } else {\n          throw err;\n        }\n      }\n    }\n    // else could not renew lease due to lease loss. Result is already false, so pass it unchanged\n    return result;\n  }\n\n  checkpointStoreExists(): Promise<boolean> {\n    log.checkpointLeaseMgr(this._context.withHost(\"Checking whether the checkpoint store exists.\"));\n    return this.leaseStoreExists();\n  }\n\n  async deleteCheckpointStore(): Promise<void> {\n    return this.deleteLeaseStore();\n  }\n\n  async createCheckpointStoreIfNotExists(): Promise<void> {\n    // This is a no-op since this method will be called only creating the lease store.\n    // The lease store and the checkpoint store are the same thing.\n    return;\n  }\n\n  async createAllCheckpointsIfNotExists(partitionIds: string[]): Promise<void> {\n    validateType(\"partitionIds\", partitionIds, true, \"Array\");\n    // Because we control the caller, we know that this method will only be called after\n    // createAllLeasesIfNotExists. In this implementation checkpoints are in the same\n    // blobs as leases, so the blobs will already exist if execution reaches here.\n    return;\n  }\n\n  async getCheckpoint(partitionId: string): Promise<CheckpointInfo | undefined> {\n    validateType(\"partitionId\", partitionId, true, \"string\");\n    const withHostAndPartition = this._context.withHostAndPartition;\n    let result: CheckpointInfo | undefined;\n    log.checkpointLeaseMgr(withHostAndPartition(partitionId, \"Getting checkpoint.\"));\n    const lease: AzureBlobLease | undefined = await this.getLease(partitionId);\n    if (lease != undefined && lease.offset) {\n      result = CheckpointInfo.createFromLease(lease.getInfo());\n    }\n    return result;\n  }\n\n  async updateCheckpoint(lease: AzureBlobLease, checkpoint: CheckpointInfo): Promise<void> {\n    const withHostAndPartition = this._context.withHostAndPartition;\n    log.checkpointLeaseMgr(\n      withHostAndPartition(checkpoint, \"Checkpoint at offset '%s' and seqno %d.\"),\n      checkpoint.offset,\n      checkpoint.sequenceNumber\n    );\n    lease.offset = checkpoint.offset;\n    lease.sequenceNumber = checkpoint.sequenceNumber;\n    try {\n      if (await this.updateLease(lease)) {\n        return;\n      } else {\n        const msg =\n          `Lease lost while updating the checkpoint for partitionId ` +\n          `'${checkpoint.partitionId}'.Hence could not update it.`;\n        log.error(withHostAndPartition(lease, msg));\n        throw new Error(msg);\n      }\n    } catch (err) {\n      const info: EPHDiagnosticInfo = {\n        action: EPHActionStrings.updatingCheckpoint,\n        error: err,\n        hostName: this._context.hostName,\n        partitionId: checkpoint.partitionId\n      };\n      this._context.onEphError(info);\n    }\n  }\n\n  async deleteCheckpoint(partitionId: string): Promise<void> {\n    validateType(\"partitionId\", partitionId, true, \"string\");\n    // This is a no-op to avoid deleting leases accidentally.\n  }\n\n  private async _listBlobs(): Promise<StorageBlobService.BlobResult[]> {\n    const blobService = this._context.blobService;\n    const withHost = this._context.withHost;\n    if (blobService) {\n      const listResult = await blobService.listBlobsSegmented(this._context.storageContainerName!);\n      log.checkpointLeaseMgr(withHost(\"Number of blobs: %d\"), listResult.entries.length);\n      return listResult.entries;\n    } else {\n      throw new Error(\n        \"'blobService' is not defined in the 'hostContext', hence cannot \" + \"list all the blobs.\"\n      );\n    }\n  }\n\n  private async _uploadLease(\n    lease: AzureBlobLease,\n    activity: UploadActivity,\n    options?: StorageBlobService.CreateBlobRequestOptions\n  ): Promise<void> {\n    const partitionId = lease.partitionId;\n    const blob = lease.blob;\n    const withHostAndPartition = this._context.withHostAndPartition;\n    if (activity !== UploadActivity.create) {\n      // It is possible for AzureBlobLease objects in memory to have stale offset/sequence number\n      // fields if a checkpoint was written but PartitionManager hasn't done its ten-second sweep\n      // which downloads new copies of all the leases. This can happen because we're trying to\n      // maintain the fiction that checkpoints and leases are separate -- which they can be in\n      // other implementations -- even though they are completely intertwined in this\n      // implementation. To prevent writing stale checkpoint data to the store, merge the\n      // checkpoint data from the most recently written checkpoint into this write, if needed.\n      if (this._latestCheckpoint.has(partitionId)) {\n        const cached: CheckpointInfo = this._latestCheckpoint.get(partitionId)!;\n        if (cached.sequenceNumber > lease.sequenceNumber || lease.offset == undefined) {\n          (lease.offset = cached.offset), (lease.sequenceNumber = cached.sequenceNumber);\n          log.checkpointLeaseMgr(\n            withHostAndPartition(\n              lease,\n              \"Updating stale offset/seqno with \" + \"new values %s/%d while uploading lease.\"\n            ),\n            lease.offset,\n            lease.sequenceNumber\n          );\n        } else if (lease.offset != undefined) {\n          this._latestCheckpoint.set(partitionId, CheckpointInfo.createFromLease(lease.getInfo()));\n        }\n      }\n    }\n    const jsonToUpload = lease.serialize();\n    if (!options) {\n      options = {\n        leaseId: lease.token\n      };\n    }\n    if (!options.metadata) options.metadata = {};\n    // - For \"acquire\" and \"update\" activities, the metadata must be set, since that is the time\n    // when the host actually owns the lease. If metadata is not set for update activity\n    // (i.e. while checkpointing), then the metadata is wiped off (over-written).\n    // This causes problems for the partition scanner while trying to determine the lease owner.\n    // - For \"release\" activity the metadata needs to be deleted/unset, since the intention is to\n    // not own the lease anymore (due to lease being lost or the receiver shutting down). Hence,\n    // setting the metadata as an empty object.\n    // - For \"create\" activity, the intention is to create a lease if it does not exist, but not own\n    // it. The lease state will be available and the status will be unlocked. Hence setting the\n    // metadata as an empty object.\n    if (activity === UploadActivity.acquire || activity === UploadActivity.update) {\n      options.metadata[metadataOwnerName] = lease.owner || this._context.hostName;\n    }\n    log.checkpointLeaseMgr(\n      withHostAndPartition(\n        lease,\n        \"Trying to upload raw JSON for activity \" + \"'%s': %s, with options: %o\"\n      ),\n      activity,\n      jsonToUpload,\n      options\n    );\n    await blob.updateContent(jsonToUpload, options);\n  }\n\n  private _wasLeaseLost(partitionId: string, err: StorageError): boolean {\n    let result: boolean = false;\n    const statusCode = err.statusCode;\n    const code = err.code;\n    const withHostAndPartition = this._context.withHostAndPartition;\n    // conflict OR precondition failed.\n    if ((statusCode && statusCode === 409) || statusCode === 412) {\n      if (\n        !code ||\n        (code &&\n          (code.toLowerCase() === leaseLost ||\n            code.toLowerCase() === leaseIdMismatchWithLeaseOperation ||\n            code.toLowerCase() === leaseIdMismatchWithBlobOperation))\n      ) {\n        result = true;\n      }\n    }\n    log.error(\n      withHostAndPartition(partitionId, \"Was lease lost -> %s, err: %O.\"),\n      result,\n      getStorageError(err)\n    );\n    return result;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport os from \"os\";\nimport uuid from \"uuid/v4\";\nimport {\n  EventHubClient,\n  EventPosition,\n  TokenProvider,\n  DefaultDataTransformer,\n  Dictionary,\n  EventHubRuntimeInformation,\n  EventHubPartitionRuntimeInformation,\n  EventHubConnectionConfig\n} from \"@azure/event-hubs\";\nimport AsyncLock from \"async-lock\";\nimport { LeaseManager } from \"./leaseManager\";\nimport { PumpManager } from \"./pumpManager\";\nimport { PartitionManager } from \"./partitionManager\";\nimport { PartitionScanner } from \"./partitionScanner\";\nimport { BlobService } from \"./blobService\";\nimport { AzureBlob } from \"./azureBlob\";\nimport { AzureStorageCheckpointLeaseManager } from \"./azureStorageCheckpointLeaseManager\";\nimport { CheckpointManager } from \"./checkpointManager\";\nimport { validateType } from \"./util/utils\";\nimport { PartitionContext } from \"./partitionContext\";\nimport { BaseLease } from \"./baseLease\";\nimport { PartitionPump } from \"./partitionPump\";\nimport {\n  EventProcessorHostOptions,\n  OnEphError,\n  OnReceivedMessage,\n  OnReceivedError\n} from \"./modelTypes\";\nimport {\n  maxLeaseDurationInSeconds,\n  minLeaseDurationInSeconds,\n  defaultLeaseRenewIntervalInSeconds,\n  defaultLeaseDurationInSeconds,\n  defaultStartupScanDelayInSeconds,\n  packageInfo,\n  defaultFastScanIntervalInSeconds,\n  defaultSlowScanIntervalInSeconds,\n  defaultConsumerGroup\n} from \"./util/constants\";\n\n/**\n * @ignore\n */\nexport interface BaseHostContext {\n  hostName: string;\n  checkpointLock: AsyncLock;\n  checkpointLockId: string;\n  consumerGroup: string;\n  eventHubPath: string;\n  storageContainerName?: string;\n  eventHubConnectionString: string;\n  connectionConfig: EventHubConnectionConfig;\n  onEphError: OnEphError;\n  leaseRenewInterval: number;\n  leaseDuration: number;\n  partitionIds: string[];\n  blobReferenceByPartition: Dictionary<AzureBlob>;\n  storageConnectionString?: string;\n  tokenProvider?: TokenProvider;\n  initialOffset?: EventPosition;\n  storageBlobPrefix?: string;\n  blobService?: BlobService;\n  composedBlobPrefix: string;\n  onMessage?: OnReceivedMessage;\n  onError?: OnReceivedError;\n  startupScanDelay?: number;\n  fastScanInterval?: number;\n  slowScanInterval?: number;\n  pumps: Map<string, PartitionPump>;\n  userAgent: string;\n  withHost(msg: string): string;\n  withHostAndPartition(partition: string | { partitionId: string }, msg: string): string;\n}\n\n/**\n * @ignore\n */\nexport interface HostContextWithCheckpointLeaseManager extends BaseHostContext {\n  leaseManager: LeaseManager;\n  checkpointManager: CheckpointManager;\n  getEventHubClient(): EventHubClient;\n  getHubRuntimeInformation(): Promise<EventHubRuntimeInformation>;\n  getPartitionInformation(\n    partitionId: string | number\n  ): Promise<EventHubPartitionRuntimeInformation>;\n  getPartitionIds(): Promise<string[]>;\n}\n\nexport interface HostContextWithPumpManager extends HostContextWithCheckpointLeaseManager {\n  pumpManager: PumpManager;\n}\n\nexport interface HostContext extends HostContextWithPumpManager {\n  partitionManager: PartitionManager;\n  partitionScanner: PartitionScanner;\n}\n\n/**\n * @ignore\n */\nexport namespace HostContext {\n  function _validateLeaseDurationAndRenewInterval(duration: number, interval: number): void {\n    validateType(\"leaseDuration\", duration, true, \"number\");\n    validateType(\"leaseRenewInterval\", interval, true, \"number\");\n\n    if (duration <= interval) {\n      throw new Error(\n        `Lease duration ${duration} needs to be greater than lease ` + `renew interval ${interval}.`\n      );\n    }\n\n    if (duration > maxLeaseDurationInSeconds || duration < minLeaseDurationInSeconds) {\n      throw new Error(\n        `Lease duration needs to be between ${minLeaseDurationInSeconds} ` +\n          `seconds and ${maxLeaseDurationInSeconds} seconds. The given value is: ${duration} seconds.`\n      );\n    }\n  }\n\n  function _validatestorageContainerName(name: string): void {\n    if (!name || name.match(/^[a-z0-9](([a-z0-9\\-[^\\-])){1,61}[a-z0-9]$/gi) === null) {\n      throw new Error(\n        `Azure Storage lease container name \"${name}\" is invalid. Please check ` +\n          `naming conventions at https://msdn.microsoft.com/en-us/library/azure/dd135715.aspx`\n      );\n    }\n  }\n\n  function _eitherStorageConnectionStringOrCheckpointLeaseManager(\n    options: EventProcessorHostOptions\n  ): void {\n    validateType(\"options\", options, true, \"object\");\n    const checkpointManager = options.checkpointManager;\n    const leaseManager = options.leaseManager;\n    const storageConnectionString = options.storageConnectionString;\n    if (storageConnectionString) {\n      if (checkpointManager || leaseManager) {\n        throw new Error(\n          \"Either provide ('checkpointManager' and 'leaseManager') or \" +\n            \"provide 'storageConnectionString'.\"\n        );\n      }\n    } else if (!(checkpointManager && leaseManager)) {\n      throw new Error(\n        \"Either provide ('checkpointManager' and 'leaseManager') or \" +\n          \"provide 'storageConnectionString'.\"\n      );\n    }\n  }\n\n  function _createBase(hostName: string, options: EventProcessorHostOptions): BaseHostContext {\n    validateType(\"hostName\", hostName, true, \"string\");\n\n    const onEphErrorFunc: OnEphError = () => {\n      // do nothing\n    };\n    const config = EventHubConnectionConfig.create(\n      options.eventHubConnectionString!,\n      options.eventHubPath\n    );\n\n    // set defaults\n    if (!options.consumerGroup) options.consumerGroup = defaultConsumerGroup;\n    if (!options.eventHubPath) options.eventHubPath = config.entityPath;\n    if (!options.onEphError) options.onEphError = onEphErrorFunc;\n    if (!options.dataTransformer) options.dataTransformer = new DefaultDataTransformer();\n    if (!options.startupScanDelay) options.startupScanDelay = defaultStartupScanDelayInSeconds;\n    if (!options.fastScanInterval) options.fastScanInterval = defaultFastScanIntervalInSeconds;\n    if (!options.slowScanInterval) options.slowScanInterval = defaultSlowScanIntervalInSeconds;\n\n    validateType(\"options\", options, true, \"object\");\n    validateType(\"options.eventHubPath\", options.eventHubPath, true, \"string\");\n    validateType(\n      \"options.eventHubConnectionString\",\n      options.eventHubConnectionString,\n      true,\n      \"string\"\n    );\n    validateType(\n      \"options.storageConnectionString\",\n      options.storageConnectionString,\n      false,\n      \"string\"\n    );\n    validateType(\"options.initialOffset\", options.initialOffset, false, \"object\");\n    validateType(\"options.consumerGroup\", options.consumerGroup, false, \"string\");\n    validateType(\"options.storageContainerName\", options.storageContainerName, false, \"string\");\n    validateType(\"options.storageBlobPrefix\", options.storageBlobPrefix, false, \"string\");\n    validateType(\"options.onEphError\", options.onEphError, false, \"function\");\n    _eitherStorageConnectionStringOrCheckpointLeaseManager(options);\n\n    if (options.leaseManager) {\n      options.leaseDuration = options.leaseManager.leaseDuration;\n      options.leaseRenewInterval = options.leaseManager.leaseRenewInterval;\n    }\n    if (!options.leaseRenewInterval)\n      options.leaseRenewInterval = defaultLeaseRenewIntervalInSeconds;\n    if (!options.leaseDuration) options.leaseDuration = defaultLeaseDurationInSeconds;\n\n    validateType(\"options.leaseRenewInterval\", options.leaseRenewInterval, false, \"number\");\n    validateType(\"options.leaseDuration\", options.leaseDuration, false, \"number\");\n\n    const context: BaseHostContext = {\n      hostName: hostName,\n      checkpointLock: new AsyncLock({ maxPending: 100000 }),\n      checkpointLockId: `checkpoint-${uuid()}`,\n      eventHubConnectionString: options.eventHubConnectionString!,\n      connectionConfig: config,\n      eventHubPath: options.eventHubPath!,\n      tokenProvider: options.tokenProvider,\n      blobReferenceByPartition: {},\n      partitionIds: [],\n      pumps: new Map<string, PartitionPump>(),\n      consumerGroup: options.consumerGroup,\n      storageContainerName: options.storageContainerName,\n      leaseRenewInterval: options.leaseRenewInterval,\n      leaseDuration: options.leaseDuration,\n      initialOffset: options.initialOffset,\n      storageBlobPrefix: options.storageBlobPrefix,\n      composedBlobPrefix: options.storageBlobPrefix\n        ? `${options.storageBlobPrefix.trim()}${options.consumerGroup}/`\n        : `${options.consumerGroup}/`,\n      onEphError: options.onEphError,\n      startupScanDelay: options.startupScanDelay,\n      fastScanInterval: options.fastScanInterval,\n      slowScanInterval: options.slowScanInterval,\n      userAgent: getUserAgent(options),\n      withHost: (msg: string) => {\n        return `[${hostName}] ${msg}`;\n      },\n      withHostAndPartition: (partition: string | PartitionContext | BaseLease, msg: string) => {\n        let id: string = \"N/A\";\n        if (typeof partition === \"string\") {\n          id = partition;\n        } else if (typeof partition === \"object\") {\n          id = partition.partitionId;\n        }\n        return `[${hostName}] [${id}] ${msg}`;\n      }\n    };\n\n    if (options.storageConnectionString) {\n      context.storageConnectionString = options.storageConnectionString;\n      context.blobService = BlobService.create(hostName, options.storageConnectionString);\n    }\n\n    _validateLeaseDurationAndRenewInterval(context.leaseDuration, context.leaseRenewInterval);\n    if (context.storageContainerName) _validatestorageContainerName(context.storageContainerName);\n    return context;\n  }\n\n  function _createWithCheckpointLeaseManager(\n    hostName: string,\n    options: EventProcessorHostOptions\n  ): HostContextWithCheckpointLeaseManager {\n    const ctxt = _createBase(hostName, options) as HostContextWithCheckpointLeaseManager;\n    const checkpointLeaseManager = new AzureStorageCheckpointLeaseManager(ctxt);\n    ctxt.leaseManager = options.leaseManager || checkpointLeaseManager;\n    ctxt.checkpointManager = options.checkpointManager || checkpointLeaseManager;\n    ctxt.getEventHubClient = () => {\n      if (ctxt.tokenProvider) {\n        return EventHubClient.createFromTokenProvider(\n          ctxt.connectionConfig.host,\n          ctxt.eventHubPath,\n          ctxt.tokenProvider,\n          {\n            userAgent: ctxt.userAgent,\n            webSocket: options && options.webSocket,\n            webSocketConstructorOptions: options && options.webSocketConstructorOptions\n          }\n        );\n      } else {\n        return EventHubClient.createFromConnectionString(\n          ctxt.eventHubConnectionString,\n          ctxt.eventHubPath,\n          {\n            userAgent: ctxt.userAgent,\n            webSocket: options && options.webSocket,\n            webSocketConstructorOptions: options && options.webSocketConstructorOptions\n          }\n        );\n      }\n    };\n    ctxt.getHubRuntimeInformation = async () => {\n      const client = ctxt.getEventHubClient();\n      try {\n        return await client.getHubRuntimeInformation();\n      } finally {\n        client.close().catch(/* do nothing */);\n      }\n    };\n    ctxt.getPartitionInformation = async (id: string | number) => {\n      const client = ctxt.getEventHubClient();\n      try {\n        return await client.getPartitionInformation(id);\n      } finally {\n        client.close().catch(/* do nothing */);\n      }\n    };\n    ctxt.getPartitionIds = async () => {\n      if (!ctxt.partitionIds.length) {\n        const client = ctxt.getEventHubClient();\n        try {\n          ctxt.partitionIds = await client.getPartitionIds();\n        } finally {\n          client.close().catch(/* do nothing */);\n        }\n      }\n      return ctxt.partitionIds;\n    };\n    return ctxt;\n  }\n\n  function _createWithPumpManager(\n    hostName: string,\n    options: EventProcessorHostOptions\n  ): HostContextWithPumpManager {\n    const context = _createWithCheckpointLeaseManager(\n      hostName,\n      options\n    ) as HostContextWithPumpManager;\n    context.pumpManager = new PumpManager(context);\n    return context;\n  }\n\n  /**\n   * @property {string} userAgent The user agent string for the EventHubs client.\n   * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk\n   */\n  const userAgent: string = `azsdk-js-azureeventprocessorhost/${\n    packageInfo.version\n  } (NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;\n\n  /**\n   * @ignore\n   */\n  export function getUserAgent(options: EventProcessorHostOptions): string {\n    const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;\n    return finalUserAgent;\n  }\n\n  /**\n   * @ignore\n   */\n  export function create(hostName: string, options: EventProcessorHostOptions): HostContext {\n    const context = _createWithPumpManager(hostName, options);\n    const hostContext = context as HostContext;\n    hostContext.partitionManager = new PartitionManager(context);\n    hostContext.partitionScanner = new PartitionScanner(context);\n    return hostContext;\n  }\n}\n","// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.\n\nimport uuid from \"uuid/v4\";\nimport {\n  TokenProvider,\n  EventHubRuntimeInformation,\n  EventHubPartitionRuntimeInformation,\n  AadTokenProvider,\n  EventHubClient\n} from \"@azure/event-hubs\";\nimport {\n  ApplicationTokenCredentials,\n  UserTokenCredentials,\n  DeviceTokenCredentials,\n  MSITokenCredentials\n} from \"@azure/ms-rest-nodeauth\";\nimport * as log from \"./log\";\nimport { LeaseManager } from \"./leaseManager\";\nimport { HostContext } from \"./hostContext\";\nimport { CheckpointManager } from \"./checkpointManager\";\nimport { validateType } from \"./util/utils\";\nimport {\n  FromConnectionStringOptions,\n  EventProcessorHostOptions,\n  FromTokenProviderOptions,\n  OnReceivedMessage,\n  OnReceivedError,\n  FromIotHubConnectionStringOptions\n} from \"./modelTypes\";\n\n/**\n * Describes the Event Processor Host to process events from an EventHub.\n * @class EventProcessorHost\n */\nexport class EventProcessorHost {\n  /**\n   * @property {ProcessorContextWithLeaseManager} _context The processor context.\n   * @private\n   */\n  private _context: HostContext;\n  /**\n   * Creates a new host to process events from an Event Hub.\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} storageConnectionString Connection string to Azure Storage account used for\n   * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;\n   * AccountKey=<account-key>;EndpointSuffix=core.windows.net\n   * @param {EventHubClient} eventHubClient The EventHub client\n   * @param {EventProcessorOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   */\n  constructor(hostName: string, options?: EventProcessorHostOptions) {\n    if (!options) options = {};\n    this._context = HostContext.create(hostName, options);\n  }\n\n  /**\n   * Provides the host name for the Event processor host.\n   */\n  get hostName(): string {\n    return this._context.hostName;\n  }\n\n  /**\n   * Provides the consumer group name for the Event processor host.\n   */\n  get consumerGroup(): string {\n    return this._context.consumerGroup;\n  }\n\n  /**\n   * Provides the eventhub runtime information.\n   * @returns {Promise<EventHubRuntimeInformation>}\n   */\n  getHubRuntimeInformation(): Promise<EventHubRuntimeInformation> {\n    return this._context.getHubRuntimeInformation();\n  }\n\n  /**\n   * Provides information about the specified partition.\n   * @param {(string|number)} partitionId Partition ID for which partition information is required.\n   *\n   * @returns {EventHubPartitionRuntimeInformation} EventHubPartitionRuntimeInformation\n   */\n  getPartitionInformation(\n    partitionId: string | number\n  ): Promise<EventHubPartitionRuntimeInformation> {\n    return this._context.getPartitionInformation(partitionId);\n  }\n\n  /**\n   * Provides an array of partitionIds.\n   * @returns {Promise<string[]>}\n   */\n  getPartitionIds(): Promise<string[]> {\n    return this._context.getPartitionIds();\n  }\n\n  /**\n   * Provides a list of partitions the EPH is currently receiving messages from.\n   *\n   * The EPH will try to grab leases for more partitions during each scan that happens once every\n   * (configured) lease renew seconds. The number of EPH instances that are being run\n   * simultaneously to receive messages from the same consumer group within an event hub also\n   * influences the number of partitions that this instance of EPH is actively receiving messages\n   * from.\n   *\n   * @returns {Array<string>} Array<string> List of partitions that this EPH instance is currently\n   * receiving messages from.\n   */\n  get receivingFromPartitions(): string[] {\n    return Array.from(this._context.pumps.keys());\n  }\n\n  /**\n   * Starts the event processor host, fetching the list of partitions, and attempting to grab leases\n   * For each successful lease, it will get the details from the blob and start a receiver at the\n   * point where it left off previously.\n   *\n   * @return {Promise<void>}\n   */\n  async start(onMessage: OnReceivedMessage, onError: OnReceivedError): Promise<void> {\n    try {\n      await this._context.partitionManager.start(onMessage, onError);\n    } catch (err) {\n      log.error(this._context.withHost(\"An error occurred while starting the EPH: %O\"), err);\n      this._context.onEphError(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Stops the EventProcessorHost from processing messages.\n   * @return {Promise<void>}\n   */\n  async stop(): Promise<void> {\n    try {\n      await this._context.partitionManager.stop();\n    } catch (err) {\n      log.error(this._context.withHost(\"An error occurred while stopping the EPH: %O\"), err);\n      this._context.onEphError(err);\n      throw err;\n    }\n  }\n\n  /**\n   * Convenience method for generating unique host name.\n   *\n   * @param {string} [prefix] String to use as the beginning of the name. Default value: \"js-host\".\n   * @return {string} A unique host name\n   */\n  static createHostName(prefix?: string): string {\n    if (!prefix) prefix = \"js-host\";\n    return `${prefix}-${uuid()}`;\n  }\n\n  /**\n   * Creates an EventProcessorHost instance from the EventHub connection string.\n   *\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} storageConnectionString Connection string to Azure Storage account used for\n   * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;\n   * AccountKey=<account-key>;EndpointSuffix=core.windows.net\n   * @param {string} storageContainerName Azure Storage container name for use by built-in lease\n   * and checkpoint manager.\n   * @param {string} eventHubConnectionString Connection string for the Event Hub to receive from.\n   * Example: 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;\n   * SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'\n   * @param {FromConnectionStringOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   *\n   * @returns {EventProcessorHost} EventProcessorHost\n   */\n  static createFromConnectionString(\n    hostName: string,\n    storageConnectionString: string,\n    storageContainerName: string,\n    eventHubConnectionString: string,\n    options?: FromConnectionStringOptions\n  ): EventProcessorHost {\n    if (!options) options = {};\n\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"storageConnectionString\", storageConnectionString, true, \"string\");\n    validateType(\"storageContainerName\", storageContainerName, true, \"string\");\n    validateType(\"eventHubConnectionString\", eventHubConnectionString, true, \"string\");\n    validateType(\"options\", options, false, \"object\");\n\n    const ephOptions: EventProcessorHostOptions = {\n      ...options,\n      storageConnectionString: storageConnectionString,\n      storageContainerName: storageContainerName,\n      eventHubConnectionString: eventHubConnectionString\n    };\n    return new EventProcessorHost(hostName, ephOptions);\n  }\n\n  /**\n   * Creates an EventProcessorHost instance from the EventHub connection string with the provided\n   * checkpoint manager and lease manager.\n   *\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} eventHubConnectionString Connection string for the Event Hub to receive from.\n   * Example: 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;\n   * SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'\n   * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.\n   * @param {LeaseManager} leaseManager A manager to manage leases.\n   * @param {FromConnectionStringOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   *\n   * @returns {EventProcessorHost} EventProcessorHost\n   */\n  static createFromConnectionStringWithCustomCheckpointAndLeaseManager(\n    hostName: string,\n    eventHubConnectionString: string,\n    checkpointManager: CheckpointManager,\n    leaseManager: LeaseManager,\n    options?: FromConnectionStringOptions\n  ): EventProcessorHost {\n    if (!options) options = {};\n\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"eventHubConnectionString\", eventHubConnectionString, true, \"string\");\n    validateType(\"checkpointManager\", checkpointManager, true, \"object\");\n    validateType(\"leaseManager\", leaseManager, true, \"object\");\n    validateType(\"options\", options, false, \"object\");\n\n    const ephOptions: EventProcessorHostOptions = {\n      ...options,\n      eventHubConnectionString: eventHubConnectionString,\n      checkpointManager: checkpointManager,\n      leaseManager: leaseManager\n    };\n    return new EventProcessorHost(hostName, ephOptions);\n  }\n\n  /**\n   * Creates an EventProcessorHost instance from a TokenProvider.\n   *\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} storageConnectionString Connection string to Azure Storage account used for\n   * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;\n   * AccountKey=<account-key>;EndpointSuffix=core.windows.net\n   * @param {string} storageContainerName Azure Storage container name for use by built-in lease\n   * and checkpoint manager.\n   * @param {string} namespace Fully qualified domain name for Event Hubs.\n   * Example: \"{your-sb-namespace}.servicebus.windows.net\"\n   * @param {string} eventHubPath The name of the EventHub.\n   * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.\n   * @param {FromTokenProviderOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   *\n   * @returns {EventProcessorHost} EventProcessorHost\n   */\n  static createFromTokenProvider(\n    hostName: string,\n    storageConnectionString: string,\n    storageContainerName: string,\n    namespace: string,\n    eventHubPath: string,\n    tokenProvider: TokenProvider,\n    options?: FromTokenProviderOptions\n  ): EventProcessorHost {\n    if (!options) options = {};\n\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"storageConnectionString\", storageConnectionString, true, \"string\");\n    validateType(\"storageContainerName\", storageContainerName, true, \"string\");\n    validateType(\"namespace\", namespace, true, \"string\");\n    validateType(\"eventHubPath\", eventHubPath, true, \"string\");\n    validateType(\"tokenProvider\", tokenProvider, true, \"object\");\n    validateType(\"options\", options, false, \"object\");\n\n    if (!namespace.endsWith(\"/\")) namespace += \"/\";\n    const connectionString =\n      `Endpoint=sb://${namespace};SharedAccessKeyName=defaultKeyName;` +\n      `SharedAccessKey=defaultKeyValue;EntityPath=${eventHubPath}`;\n    const ephOptions: EventProcessorHostOptions = {\n      ...options,\n      tokenProvider: tokenProvider,\n      storageConnectionString: storageConnectionString,\n      storageContainerName: storageContainerName,\n      eventHubPath: eventHubPath,\n      eventHubConnectionString: connectionString\n    };\n    return new EventProcessorHost(hostName, ephOptions);\n  }\n\n  /**\n   * Creates an EventProcessorHost instance from a TokenProvider with the provided checkpoint manager\n   * and lease manager.\n   *\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} namespace Fully qualified domain name for Event Hubs.\n   * Example: \"{your-sb-namespace}.servicebus.windows.net\"\n   * @param {string} eventHubPath The name of the EventHub.\n   * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.\n   * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.\n   * @param {LeaseManager} leaseManager A manager to manage leases.\n   * @param {FromTokenProviderOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   *\n   * @returns {EventProcessorHost} EventProcessorHost\n   */\n  static createFromTokenProviderWithCustomCheckpointAndLeaseManager(\n    hostName: string,\n    namespace: string,\n    eventHubPath: string,\n    tokenProvider: TokenProvider,\n    checkpointManager: CheckpointManager,\n    leaseManager: LeaseManager,\n    options?: FromTokenProviderOptions\n  ): EventProcessorHost {\n    if (!options) options = {};\n\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"namespace\", namespace, true, \"string\");\n    validateType(\"eventHubPath\", eventHubPath, true, \"string\");\n    validateType(\"tokenProvider\", tokenProvider, true, \"object\");\n    validateType(\"checkpointManager\", checkpointManager, true, \"object\");\n    validateType(\"leaseManager\", leaseManager, true, \"object\");\n    validateType(\"options\", options, false, \"object\");\n\n    if (!namespace.endsWith(\"/\")) namespace += \"/\";\n    const connectionString =\n      `Endpoint=sb://${namespace};SharedAccessKeyName=defaultKeyName;` +\n      `SharedAccessKey=defaultKeyValue;EntityPath=${eventHubPath}`;\n    const ephOptions: EventProcessorHostOptions = {\n      ...options,\n      tokenProvider: tokenProvider,\n      eventHubPath: eventHubPath,\n      eventHubConnectionString: connectionString,\n      checkpointManager: checkpointManager,\n      leaseManager: leaseManager\n    };\n    return new EventProcessorHost(hostName, ephOptions);\n  }\n\n  /**\n   * Creates an EventProcessorHost instance from AAD token credentials.\n   *\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} storageConnectionString Connection string to Azure Storage account used for\n   * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;\n   * AccountKey=<account-key>;EndpointSuffix=core.windows.net\n   * @param {string} storageContainerName Azure Storage container name for use by built-in lease\n   * and checkpoint manager.\n   * @param {string} namespace Fully qualified domain name for Event Hubs.\n   * Example: \"{your-sb-namespace}.servicebus.windows.net\"\n   * @param {string} eventHubPath The name of the EventHub.\n   * @param {TokenCredentials} credentials - The AAD Token credentials. It can be one of the\n   * following: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials\n   * | MSITokenCredentials.\n   * @param {FromTokenProviderOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   *\n   * @returns {EventProcessorHost} EventProcessorHost\n   */\n  static createFromAadTokenCredentials(\n    hostName: string,\n    storageConnectionString: string,\n    storageContainerName: string,\n    namespace: string,\n    eventHubPath: string,\n    credentials:\n      | ApplicationTokenCredentials\n      | UserTokenCredentials\n      | DeviceTokenCredentials\n      | MSITokenCredentials,\n    options?: FromTokenProviderOptions\n  ): EventProcessorHost {\n    if (!options) options = {};\n\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"storageConnectionString\", storageConnectionString, true, \"string\");\n    validateType(\"storageContainerName\", storageContainerName, true, \"string\");\n    validateType(\"namespace\", namespace, true, \"string\");\n    validateType(\"eventHubPath\", eventHubPath, true, \"string\");\n    validateType(\"credentials\", credentials, true, \"object\");\n    validateType(\"options\", options, false, \"object\");\n\n    if (!namespace.endsWith(\"/\")) namespace += \"/\";\n    const connectionString =\n      `Endpoint=sb://${namespace};SharedAccessKeyName=defaultKeyName;` +\n      `SharedAccessKey=defaultKeyValue;EntityPath=${eventHubPath}`;\n\n    const ephOptions: EventProcessorHostOptions = {\n      ...options,\n      tokenProvider: new AadTokenProvider(credentials),\n      storageConnectionString: storageConnectionString,\n      storageContainerName: storageContainerName,\n      eventHubPath: eventHubPath,\n      eventHubConnectionString: connectionString\n    };\n    return new EventProcessorHost(hostName, ephOptions);\n  }\n\n  /**\n   * Creates an EventProcessorHost instance from AAD token credentials with the given checkpoint manager\n   * and lease manager.\n   *\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} namespace Fully qualified domain name for Event Hubs.\n   * Example: \"{your-sb-namespace}.servicebus.windows.net\"\n   * @param {string} eventHubPath The name of the EventHub.\n   * @param {TokenCredentials} credentials - The AAD Token credentials. It can be one of the\n   * following: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials\n   * | MSITokenCredentials.\n   * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.\n   * @param {LeaseManager} leaseManager A manager to manage leases.\n   * @param {FromTokenProviderOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   *\n   * @returns {EventProcessorHost} EventProcessorHost\n   */\n  static createFromAadTokenCredentialsWithCustomCheckpointAndLeaseManager(\n    hostName: string,\n    namespace: string,\n    eventHubPath: string,\n    credentials:\n      | ApplicationTokenCredentials\n      | UserTokenCredentials\n      | DeviceTokenCredentials\n      | MSITokenCredentials,\n    checkpointManager: CheckpointManager,\n    leaseManager: LeaseManager,\n    options?: FromTokenProviderOptions\n  ): EventProcessorHost {\n    if (!options) options = {};\n\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"namespace\", namespace, true, \"string\");\n    validateType(\"eventHubPath\", eventHubPath, true, \"string\");\n    validateType(\"credentials\", credentials, true, \"object\");\n    validateType(\"checkpointManager\", checkpointManager, true, \"object\");\n    validateType(\"leaseManager\", leaseManager, true, \"object\");\n    validateType(\"options\", options, false, \"object\");\n\n    if (!namespace.endsWith(\"/\")) namespace += \"/\";\n    const connectionString =\n      `Endpoint=sb://${namespace};SharedAccessKeyName=defaultKeyName;` +\n      `SharedAccessKey=defaultKeyValue;EntityPath=${eventHubPath}`;\n    const ephOptions: EventProcessorHostOptions = {\n      ...options,\n      tokenProvider: new AadTokenProvider(credentials),\n      eventHubPath: eventHubPath,\n      eventHubConnectionString: connectionString,\n      checkpointManager: checkpointManager,\n      leaseManager: leaseManager\n    };\n    return new EventProcessorHost(hostName, ephOptions);\n  }\n\n  /**\n   * Creates an EventProcessorHost instance from the IotHub connection string.\n   *\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} storageConnectionString Connection string to Azure Storage account used for\n   * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;\n   * AccountKey=<account-key>;EndpointSuffix=core.windows.net\n   * @param {string} storageContainerName Azure Storage container name for use by built-in lease\n   * and checkpoint manager.\n   * @param {string} iotHubConnectionString Connection string for the IotHub.\n   * Example: 'Endpoint=iot-host-name;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'\n   * @param {FromIotHubConnectionStringOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   *\n   * @returns {EventProcessorHost} EventProcessorHost\n   */\n  static async createFromIotHubConnectionString(\n    hostName: string,\n    storageConnectionString: string,\n    storageContainerName: string,\n    iotHubConnectionString: string,\n    options?: FromIotHubConnectionStringOptions\n  ): Promise<EventProcessorHost> {\n    if (!options) options = {};\n\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"storageConnectionString\", storageConnectionString, true, \"string\");\n    validateType(\"storageContainerName\", storageContainerName, true, \"string\");\n    validateType(\"iotHubConnectionString\", iotHubConnectionString, true, \"string\");\n    validateType(\"options\", options, false, \"object\");\n\n    const client = await EventHubClient.createFromIotHubConnectionString(iotHubConnectionString);\n    /* tslint:disable:no-string-literal */\n    const eventHubConnectionString = client[\"_context\"].config.connectionString;\n    const ephOptions: EventProcessorHostOptions = {\n      ...options,\n      storageConnectionString: storageConnectionString,\n      storageContainerName: storageContainerName,\n      eventHubConnectionString: eventHubConnectionString,\n      eventHubPath: client.eventhubName\n    };\n    return new EventProcessorHost(hostName, ephOptions);\n  }\n\n  /**\n   * Creates an EventProcessorHost instance from the IotHub connection string with the given\n   * checkpoint manager and lease manager.\n   *\n   * @param {string} hostName Name of the processor host. MUST BE UNIQUE.\n   * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use\n   * `EventProcessorHost.createHostName(\"your-prefix\")`; Default: `js-host-${uuid()}`.\n   * @param {string} iotHubConnectionString Connection string for the IotHub.\n   * Example: 'Endpoint=iot-host-name;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'\n   * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.\n   * @param {LeaseManager} leaseManager A manager to manage leases.\n   * @param {FromIotHubConnectionStringOptions} [options] Optional parameters for creating an\n   * EventProcessorHost.\n   *\n   * @returns {EventProcessorHost} EventProcessorHost\n   */\n  static async createFromIotHubConnectionStringWithCustomCheckpointAndLeaseManager(\n    hostName: string,\n    iotHubConnectionString: string,\n    checkpointManager: CheckpointManager,\n    leaseManager: LeaseManager,\n    options?: FromIotHubConnectionStringOptions\n  ): Promise<EventProcessorHost> {\n    if (!options) options = {};\n\n    validateType(\"hostName\", hostName, true, \"string\");\n    validateType(\"iotHubConnectionString\", iotHubConnectionString, true, \"string\");\n    validateType(\"checkpointManager\", checkpointManager, true, \"object\");\n    validateType(\"leaseManager\", leaseManager, true, \"object\");\n    validateType(\"options\", options, false, \"object\");\n\n    const client = await EventHubClient.createFromIotHubConnectionString(iotHubConnectionString);\n    /* tslint:disable:no-string-literal */\n    const eventHubConnectionString = client[\"_context\"].config.connectionString;\n\n    const ephOptions: EventProcessorHostOptions = {\n      ...options,\n      eventHubConnectionString: eventHubConnectionString,\n      checkpointManager: checkpointManager,\n      leaseManager: leaseManager,\n      eventHubPath: client.eventhubName\n    };\n    return new EventProcessorHost(hostName, ephOptions);\n  }\n}\n"],"names":["bytesToUuid","log.util","log.error","checkpoint","log.checkpoint","CheckpointInfo","EventPosition","log.partitionContext","log.partitionPump","error","ErrorNameConditionMapper","log.pumpManager","log.partitionManager","log.partitionScanner","delay","createBlobService","log.blobService","log.completeLease","log.azurebloblease","log.checkpointLeaseMgr","uuid","EventHubConnectionConfig","DefaultDataTransformer","EventHubClient","AadTokenProvider"],"mappings":"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"}