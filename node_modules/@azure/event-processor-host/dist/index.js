'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var crypto = _interopDefault(require('crypto'));
var eventHubs = require('@azure/event-hubs');
var debugModule = _interopDefault(require('debug'));
var os = _interopDefault(require('os'));
var AsyncLock = _interopDefault(require('async-lock'));
var azureStorage = require('azure-storage');
var path = _interopDefault(require('path'));

// Unique ID creation requires a high quality random # generator.  In node.js
// this is pretty straight-forward - we use the crypto API.



var rng = function nodeRNG() {
  return crypto.randomBytes(16);
};

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

var bytesToUuid_1 = bytesToUuid;

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid_1(rnds);
}

var v4_1 = v4;

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 * log statements for error
 */
const error = debugModule("azure:eph:error");
/**
 * @ignore
 * log statements for lease
 */
const baseLease = debugModule("azure:eph:baseLease");
/**
 * @ignore
 * log statements for lease
 */
const completeLease = debugModule("azure:eph:completeLease");
/**
 * @ignore
 * log statements for azurebloblease
 */
const azurebloblease = debugModule("azure:eph:azurebloblease");
/**
 * @ignore
 * log statements for leaseManager
 */
const leaseManager = debugModule("azure:eph:leaseManager");
/**
 * @ignore
 * log statements for partitionManager
 */
const partitionManager = debugModule("azure:eph:partitionManager");
/**
 * @ignore
 * log statements for partitionManager
 */
const partitionPump = debugModule("azure:eph:partitionPump");
/**
 * @ignore
 * log statements for pumpManager
 */
const pumpManager = debugModule("azure:eph:pumpManager");
/**
 * @ignore
 * log statements for partitionScanner
 */
const partitionScanner = debugModule("azure:eph:partitionScanner");
/**
 * @ignore
 * log statements for host
 */
const host = debugModule("azure:eph:host");
/**
 * @ignore
 * log statements for blobService
 */
const blobService = debugModule("azure:eph:blobService");
/**
 * @ignore
 * log statements for partitionContext
 */
const partitionContext = debugModule("azure:eph:partitionContext");
/**
 * @ignore
 * log statements for checkpointLeaseMgr
 */
const checkpointLeaseMgr = debugModule("azure:eph:checkpointLeaseMgr");
/**
 * @ignore
 * log statements for checkpointLeaseMgr
 */
const checkpoint = debugModule("azure:eph:checkpointInfo");
/**
 * @ignore
 * log statements for checkpointLeaseMgr
 */
const util = debugModule("azure:eph:util");

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Generates a random number between the given interval
 * @param {number} min Min number of the range (inclusive).
 * @param {number} max Max number of the range (inclusive).
 */
function randomNumberFromInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Validates the type and requiredness of a given parameter.
 * @param paramName The name of the parameter.
 * @param paramValue The parameter value
 * @param type The type of the parameter
 */
function validateType(paramName, paramValue, required, type) {
    if (required && paramValue == undefined) {
        throw new TypeError(`${paramName} is required. Given value: ${paramValue}. Hence it cannot be null or undefined.`);
    }
    if (paramValue != undefined) {
        if (type === "Array") {
            if (!Array.isArray(paramValue)) {
                throw new TypeError(`${paramName} must be of type "${type}".`);
            }
        }
        else if (type === "Date") {
            if (!(paramValue instanceof Date)) {
                throw new TypeError(`${paramName} must be of type "${type}".`);
            }
        }
        else if (type === "string" ||
            type === "number" ||
            type === "boolean" ||
            type === "object" ||
            type === "function") {
            if (typeof paramValue !== type) {
                throw new TypeError(`${paramName} must be of type "${type}".`);
            }
        }
        else {
            throw new Error(`Invalid argument. type "${type}" is not a valid type. Valid values are: ` +
                `"string", "number", "boolean", "Array", "object", "Date", "function"`);
        }
    }
}
/**
 * @ignore
 */
function getStorageError(err) {
    return {
        name: err.name,
        message: err.message,
        statusCode: err.statusCode,
        code: err.code,
        requestId: err.requestId
    };
}
/**
 * @ignore
 */
var EPHActionStrings;
(function (EPHActionStrings) {
    EPHActionStrings["acquireLease"] = "Acquire Lease";
    EPHActionStrings["gettingPartitionIds"] = "Getting PartitionIds";
    EPHActionStrings["gettingAllLeases"] = "Getting All Leases";
    EPHActionStrings["creatingAllLeases"] = "Creating All Leases";
    EPHActionStrings["scanningLeases"] = "Scanning leases";
    EPHActionStrings["checkingLeases"] = "Checking Leases";
    EPHActionStrings["checkingExpiredLeases"] = "Checking Expired Leases";
    EPHActionStrings["renewingLease"] = "Renewing Lease";
    EPHActionStrings["stealingLease"] = "Stealing Lease";
    EPHActionStrings["creatingLease"] = "Creating Lease";
    EPHActionStrings["creatingCheckpoint"] = "Creating Checkpoint";
    EPHActionStrings["updatingCheckpoint"] = "Updating Checkpoint";
    EPHActionStrings["creatingCheckpointStore"] = "Creating Checkpoint Store";
    EPHActionStrings["creatingEventProcessor"] = "Creating Event Processor";
    EPHActionStrings["creatingLeaseStore"] = "Creating Lease Store";
    EPHActionStrings["initializingStores"] = "Initializing Stores";
    EPHActionStrings["partitionManagerCleanup"] = "Partition Manager Cleanup";
    EPHActionStrings["partitionManagerMainLoop"] = "Partition Manager Main Loop";
    EPHActionStrings["partitionReceiverManagement"] = "Partition Receiver Management";
    EPHActionStrings["deletingLeaseStore"] = "Deleting Lease Store";
})(EPHActionStrings || (EPHActionStrings = {}));
/**
 * @ignore
 */
function retry(config) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        let createdOK = false;
        let retryCount = 0;
        let result = undefined;
        let innerError = undefined;
        do {
            try {
                result = yield config.operation();
                createdOK = true;
                if (config.partitionId) {
                    util("[%s] Retry attempt: %d. Action '%s' for partitionId: '%s' suceeded.", config.hostName, retryCount, config.action, config.partitionId);
                }
                else {
                    util("[%s] Retry attempt: %d. Action '%s' suceeded.", config.hostName, retryCount, config.action);
                }
            }
            catch (err) {
                innerError = err;
                if (config.partitionId) {
                    error("[%s] An error occurred. Retry attempt: %d. PartitionId: '%s'. %s: %O", config.hostName, config.partitionId, retryCount, config.retryMessage, err);
                }
                else {
                    error("[%s] An error occurred. Retry attempt: %d. %s: %O", config.hostName, retryCount, config.retryMessage, err);
                }
                retryCount++;
            }
        } while (!createdOK && retryCount < config.maxRetries);
        if (!createdOK) {
            let msg;
            if (innerError) {
                msg =
                    `${config.finalFailureMessage} while performing the action "${config.action}" ` +
                        `due to ${innerError.stack ? innerError.stack : JSON.stringify(innerError)}`;
            }
            else {
                msg = `${config.finalFailureMessage} while performing the action "${config.action}"`;
            }
            error("[%s] %s", config.hostName, msg);
            const info = {
                action: config.action,
                hostName: config.hostName,
                partitionId: config.partitionId || "N/A",
                error: new Error(msg)
            };
            throw info;
        }
        return result;
    });
}

// Copyright (c) Microsoft Corporation. All rights reserved.
(function (CheckpointInfo) {
    /**
     * Creates the checkpoint info
     * @param {string} partitionId The partition id for the checkpoint
     * @param {string} [offset] The offset of the event to be checked in.
     * @param {number} [sequenceNumber] The sequence number of the event to be checked in.
     * @return {CheckpointInfo} CheckpointInfo
     */
    function create(partitionId, offset, sequenceNumber) {
        validateType("partitionId", partitionId, true, "string");
        validateType("offset", offset, false, "string");
        validateType("sequenceNumber", sequenceNumber, false, "number");
        const checkpoint$1 = {
            partitionId: partitionId,
            offset: offset || "-1",
            sequenceNumber: sequenceNumber != undefined ? sequenceNumber : 0
        };
        checkpoint("The created CheckpointInfo is: %o", checkpoint$1);
        return checkpoint$1;
    }
    CheckpointInfo.create = create;
    /**
     * Creates the checkpoint info
     * @param {LeaseInfo} lease The lease info from which the checkpoint info needs to created.
     * @return {CheckpointInfo} CheckpointInfo
     */
    function createFromLease(lease) {
        validateType("lease", lease, true, "object");
        const checkpoint$1 = {
            offset: lease.offset || "-1",
            partitionId: lease.partitionId,
            sequenceNumber: lease.sequenceNumber
        };
        checkpoint("The created CheckpointInfo from lease %o is: %o", lease, checkpoint$1);
        return checkpoint$1;
    }
    CheckpointInfo.createFromLease = createFromLease;
    /**
     * Creates the checkpoint info.
     * @param {string} partitionId The partition id for the checkpoint
     * @param {EventData} eventData The event data from which the checkpoint info needs to created.
     * @return {CheckpointInfo} CheckpointInfo
     */
    function createFromEventData(partitionId, eventData) {
        validateType("partitionId", partitionId, true, "string");
        validateType("eventData", eventData, true, "object");
        validateType("eventData.offset", eventData.offset, true, "string");
        validateType("eventData.sequenceNumber", eventData.sequenceNumber, true, "number");
        const checkpoint$1 = {
            partitionId: partitionId,
            offset: eventData.offset,
            sequenceNumber: eventData.sequenceNumber
        };
        checkpoint("The created CheckpointInfo from EventData %o is: %o", eventData, checkpoint$1);
        return checkpoint$1;
    }
    CheckpointInfo.createFromEventData = createFromEventData;
})(exports.CheckpointInfo || (exports.CheckpointInfo = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the Partition Context.
 * @class PartitionContext
 */
class PartitionContext {
    /**
     * Creates a new PartitionContext.
     * @param {string} partitionId The eventhub partition id.
     * @param {string} owner The name of the owner.
     * @param {CompleteLease} lease The lease object.
     */
    constructor(context, partitionId, lease) {
        this._offset = eventHubs.EventPosition.startOfStream;
        this._sequenceNumber = 0;
        this._context = context;
        this.partitionId = partitionId;
        this.lease = lease;
    }
    /**
     * @property {string} owner The host/owner of the partition.
     * @readonly
     */
    get owner() {
        return this.lease.owner;
    }
    /**
     * @property {string} eventhubPath The path of the eventhub
     * @readonly
     */
    get eventhubPath() {
        return this._context.eventHubPath;
    }
    /**
     * @property {string} consumerGroup The name of the consumer group.
     * @readonly
     */
    get consumerGroup() {
        return this._context.consumerGroup;
    }
    /**
     * Sets the offset and sequence number of the partition context from the provided EventData.
     * @param {EventData} eventData The event data `received` from the EventHubReceiver.
     */
    setOffsetAndSequenceNumber(eventData) {
        validateType("eventData", eventData, true, "object");
        validateType("eventData.offset", eventData.offset, true, "string");
        validateType("eventData.sequenceNumber", eventData.sequenceNumber, true, "number");
        this._offset = eventData.offset;
        this._sequenceNumber = eventData.sequenceNumber;
    }
    /**
     * Writes the current offset and sequenceNumber to the checkpoint store via the checkpoint manager.
     *
     * The checkpoint data is structured as a JSON payload (example):
     * `{ "partitionId":"0","owner":"ephtest","token":"48e209e3-55f0-41b8-a8dd-d9c09ff6c35a",
     * "epoch":1,"offset":"","SequenceNumber":0 }`.
     *
     * @return {Promise<void>}
     */
    checkpoint() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const capturedCheckpoint = {
                offset: this._offset,
                partitionId: this.partitionId,
                sequenceNumber: this._sequenceNumber
            };
            const withHostAndPartiton = this._context.withHostAndPartition;
            partitionContext(withHostAndPartiton(this, "Checkpointing: %O"), capturedCheckpoint);
            yield this._context.checkpointLock.acquire(this._context.checkpointLockId, () => {
                return this._persistCheckpoint(capturedCheckpoint);
            });
        });
    }
    /**
     * Writes the current offset and sequenceNumber to the checkpoint store via the checkpoint manager.
     *
     * The checkpoint data is structured as a JSON payload (example):
     * `{ "partitionId":"0","owner":"ephtest","token":"48e209e3-55f0-41b8-a8dd-d9c09ff6c35a",
     * "epoch":1,"offset":"","SequenceNumber":0 }`.
     *
     * @param {EventData} eventData The event data received from the EventHubReceiver.
     * @return {Promise<void>}
     */
    checkpointFromEventData(eventData) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const data = exports.CheckpointInfo.createFromEventData(this.partitionId, eventData);
            const withHostAndPartiton = this._context.withHostAndPartition;
            partitionContext(withHostAndPartiton(this, "Checkpointing from ED: %O"), data);
            yield this._context.checkpointLock.acquire(this._context.checkpointLockId, () => {
                return this._persistCheckpoint(data);
            });
        });
    }
    /**
     * @ignore
     */
    getInitialOffset() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const startingCheckpoint = yield this._context.checkpointManager.getCheckpoint(this.partitionId);
            const withHostAndPartiton = this._context.withHostAndPartition;
            let result;
            if (!startingCheckpoint) {
                if (this._context.initialOffset) {
                    partitionContext(withHostAndPartiton(this, "User provided initial offset: %s"), this._context.initialOffset.getExpression());
                }
                result = this._context.initialOffset || eventHubs.EventPosition.fromOffset(this._offset);
            }
            else {
                if (startingCheckpoint.offset != undefined)
                    this._offset = startingCheckpoint.offset;
                if (startingCheckpoint.sequenceNumber != undefined)
                    this._sequenceNumber = startingCheckpoint.sequenceNumber;
                result = eventHubs.EventPosition.fromOffset(this._offset);
                partitionContext(withHostAndPartiton(this, "Retrieved starting offset/sequence " + "number: %s/%d"), this._offset, this._sequenceNumber);
            }
            partitionContext(withHostAndPartiton(this, "Initial position provider offset: %s, " + "sequenceNumber: %d, enqueuedTime: %d"), result.offset, result.sequenceNumber, result.enqueuedTime);
            return result;
        });
    }
    /**
     * @ignore
     */
    _persistCheckpoint(checkpoint) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHostAndPartiton = this._context.withHostAndPartition;
            try {
                const inStoreCheckpoint = yield this._context.checkpointManager.getCheckpoint(checkpoint.partitionId);
                if (inStoreCheckpoint && inStoreCheckpoint.sequenceNumber >= checkpoint.sequenceNumber) {
                    const msg = `Ignoring out of date checkpoint with offset: '${checkpoint.offset}', ` +
                        `sequenceNumber: ${checkpoint.sequenceNumber} because currently persisted checkpoint ` +
                        ` has higher offset '${inStoreCheckpoint.offset}', sequenceNumber ` +
                        `${inStoreCheckpoint.sequenceNumber}.`;
                    error(withHostAndPartiton(this, "%s"), msg);
                    throw new Error(msg);
                }
                partitionContext(withHostAndPartiton(this, "Persisting the checkpoint: %O."), checkpoint);
                yield this._context.checkpointManager.updateCheckpoint(this.lease, checkpoint);
                partitionContext(withHostAndPartiton(this, "Successfully persisted the checkpoint: %O."), checkpoint);
            }
            catch (err) {
                const msg = `An error occurred while checkpointing info for partition ` +
                    `'${checkpoint.partitionId}': ${err ? err.stack : JSON.stringify(err)}.`;
                error(withHostAndPartiton(this, "%s"), msg);
                throw err;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * @ignore
 */
var CloseReason;
(function (CloseReason) {
    CloseReason["leaseLost"] = "LeaseLost";
    CloseReason["shutdown"] = "ShutDown";
})(CloseReason || (CloseReason = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
class PartitionPump {
    constructor(context, lease, onMessage, onError) {
        this._context = context;
        this._lease = lease;
        this._partitionContext = new PartitionContext(this._context, lease.partitionId, lease);
        this._onMessage = onMessage;
        this._onError = onError;
    }
    get lease() {
        return this._lease;
    }
    set lease(newLease) {
        this._lease = newLease;
        if (this._partitionContext) {
            this._partitionContext.lease = this._lease;
        }
    }
    isOpen() {
        if (this._receiveHandler && this._receiveHandler.isReceiverOpen) {
            return true;
        }
        else {
            return false;
        }
    }
    start() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            yield this._createNewReceiver();
            yield this._scheduleLeaseRenewer();
            partitionPump(withHostAndPartition(this._lease, "Successfully started the receiver and scheduled lease renewer."));
        });
    }
    stop(reason) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this._removeReceiver(reason);
        });
    }
    _createNewReceiver() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const partitionId = this._partitionContext.partitionId;
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                this._client = this._context.getEventHubClient();
            }
            catch (err) {
                error(withHostAndPartition(partitionId, "An error occurred while creating " + "the eventhub client: %O."), err);
                throw err;
            }
            partitionPump(withHostAndPartition(partitionId, "Getting the initial offset."));
            const eventPosition = yield this._partitionContext.getInitialOffset();
            this._context.pumps.set(partitionId, this);
            partitionPump(withHostAndPartition(partitionId, "Added the pump to the internal map."));
            let receiveHandler;
            const rcvrOptions = {
                consumerGroup: this._context.consumerGroup,
                eventPosition: eventPosition,
                epoch: this._lease.epoch
            };
            const onMessage = (eventData) => {
                this._partitionContext.setOffsetAndSequenceNumber(eventData);
                this._onMessage(this._partitionContext, eventData);
            };
            const onError = (error$1) => tslib.__awaiter(this, void 0, void 0, function* () {
                error(withHostAndPartition(partitionId, "Receiver '%s' received an error: %O."), receiveHandler.address, error$1);
                // Let the user know about the error only if it is not ReceiverDisconnectedError.
                // This error happens when another instance of EPH connects a receiver with a higher epoch
                // value to a partition in the same consumer group that this receiver was connected to.
                // This happens due to lease being stolen or current lease expiring, which is expected.
                // Hence not reporting suxh errors to the user will try to make it less confusing for the user.
                if (!this._isReceiverDisconnectedError(error$1)) {
                    this._onError(error$1);
                }
                try {
                    yield this._removeReceiver(CloseReason.shutdown);
                }
                catch (err) {
                    error(withHostAndPartition(partitionId, "Since we received an error %O " +
                        "on the error handler for receiver with address '%s', we tried closing it. However, " +
                        "error occurred while closing it and it is: %O."), error$1, receiveHandler.address, err);
                }
            });
            partitionPump(withHostAndPartition(partitionId, "Trying to create receiver in " + "consumergroup: '%s' with epoch %d from offset: %s."), rcvrOptions.consumerGroup, rcvrOptions.epoch, eventPosition.getExpression());
            receiveHandler = this._client.receive(partitionId, onMessage, onError, rcvrOptions);
            this._receiveHandler = receiveHandler;
            partitionPump(withHostAndPartition(partitionId, "Created receiver '%s' with eventPosition: %s"), receiveHandler.address, eventPosition.getExpression());
        });
    }
    _leaseRenewer() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            let result = true;
            let error$1;
            partitionPump(withHostAndPartition(this._lease, "Lease renewer is active after " + "%d seconds. Trying to renew the lease"), this._context.leaseRenewInterval);
            try {
                result = yield this._context.leaseManager.renewLease(this._lease);
                if (result) {
                    partitionPump(withHostAndPartition(this._lease, "Successfully renewed the lease."));
                }
            }
            catch (err) {
                const msg = `An error occurred while renewing the lease for partitionId ` +
                    `'${this._lease.partitionId}': ${err ? err.stack : JSON.stringify(err)}`;
                error$1 = new Error(msg);
                this._context.onEphError({
                    hostName: this._context.hostName,
                    partitionId: this._lease.partitionId,
                    error: error$1,
                    action: EPHActionStrings.renewingLease
                });
                error(withHostAndPartition(this._lease, msg));
            }
            if (!result) {
                error(withHostAndPartition(this._lease, "Failed to renew the lease, result: %s. " + "Shutting down the receiver."), result);
                yield this._removeReceiver(CloseReason.leaseLost);
            }
            else {
                this._scheduleLeaseRenewer();
            }
        });
    }
    _scheduleLeaseRenewer() {
        const withHostAndPartition = this._context.withHostAndPartition;
        const renewalTime = this._context.leaseRenewInterval * 1000;
        partitionPump(withHostAndPartition(this._lease, "Scheduling lease renewal in %d seconds."), this._context.leaseRenewInterval);
        this._leaseRenewalTimer = setTimeout(() => tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._leaseRenewer();
            }
            catch (err) {
                error(withHostAndPartition(this._lease, "An error occurred in the _leaseRenewer(): %O"), err);
            }
        }), renewalTime);
    }
    _removeReceiver(reason) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const receiveHandler = this._receiveHandler;
            const partitionContext = this._partitionContext;
            const partitionId = partitionContext.partitionId;
            const leaseId = this._lease.token;
            const withHostAndPartition = this._context.withHostAndPartition;
            if (receiveHandler && this._client) {
                try {
                    this._context.pumps.delete(partitionId);
                    partitionPump(withHostAndPartition(partitionId, "Deleted the pump from internal map."));
                    clearTimeout(this._leaseRenewalTimer);
                    partitionPump(withHostAndPartition(partitionId, "Removing receiver '%s', due to reason '%s'."), receiveHandler.address, partitionId, reason);
                    yield this._client.close();
                    partitionPump(withHostAndPartition(partitionId, "Successfully stopped the receiver '%s' for partitionId '%s' due to reason '%s'."), receiveHandler.address, partitionId, reason);
                }
                catch (err) {
                    const msg = `An error occurred while closing the receiver '${receiveHandler.address}' : ` +
                        `${err ? err.stack : JSON.stringify(err)}`;
                    error(withHostAndPartition(partitionId, "%s"), msg);
                }
                this._receiveHandler = undefined;
                this._client = undefined;
                // Release the lease if it was not lost.
                if (reason !== CloseReason.leaseLost) {
                    try {
                        partitionPump(withHostAndPartition(partitionContext, "Releasing lease %s after closing the receiver '%s' due to reason '%s'."), leaseId, receiveHandler.address, reason);
                        yield this._context.leaseManager.releaseLease(partitionContext.lease);
                    }
                    catch (err) {
                        const msg = `An error occurred while releasing the lease ${leaseId} ` +
                            `the receiver '${receiveHandler.address}' : ${err ? err.stack : JSON.stringify(err)} `;
                        error(withHostAndPartition(partitionId, "%s"), msg);
                        throw err;
                    }
                }
            }
            else {
                partitionPump(withHostAndPartition(partitionId, "No receiver was found to remove."));
            }
        });
    }
    _isReceiverDisconnectedError(error$1) {
        const partitionId = this._partitionContext.partitionId;
        const withHostAndPartition = this._context.withHostAndPartition;
        let result = false;
        if (error$1) {
            // condition is "amqp:link:stolen"
            if (error$1.condition === eventHubs.ErrorNameConditionMapper.ReceiverDisconnectedError) {
                result = true;
            }
            else if (error$1.message.match(/.*New receiver with higher epoch.*/i) !== null) {
                result = true;
                error(withHostAndPartition(partitionId, "It looks like the error should have " +
                    "been a 'ReceiverDisconnectedError', however it was not translated correctly: %O."), error$1);
            }
        }
        return result;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
class PumpManager {
    constructor(context) {
        this._context = context;
    }
    addPump(lease) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const hostName = this._context.hostName;
            const partitionId = lease.partitionId;
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                const capturedPump = this._context.pumps.get(partitionId);
                if (capturedPump) {
                    const isOpen = capturedPump.isOpen();
                    if (!isOpen) {
                        error(withHostAndPartition(partitionId, "The existing pump is open -> %s."), isOpen);
                        yield this.removePump(partitionId, CloseReason.shutdown);
                    }
                    else {
                        pumpManager(withHostAndPartition(partitionId, "Updating lease for pump since it" + "is open -> %s."), partitionId, isOpen);
                        capturedPump.lease = lease;
                    }
                }
                else {
                    pumpManager(withHostAndPartition(partitionId, "Creating a new pump with lease %o."), lease.getInfo());
                    const pump = new PartitionPump(this._context, lease, this._context.onMessage, this._context.onError);
                    yield pump.start();
                }
            }
            catch (err) {
                const msg = `An error occurred while adding/updating a pump for partitionId ` +
                    `'${partitionId}': ${err ? err.stack : JSON.stringify(err)}`;
                error(withHostAndPartition(partitionId, "%s."), msg);
                this._context.onEphError({
                    hostName: hostName,
                    partitionId: partitionId,
                    error: new Error(msg),
                    action: EPHActionStrings.partitionReceiverManagement
                });
            }
        });
    }
    removePump(partitionId, reason) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                const capturedPump = this._context.pumps.get(partitionId);
                if (capturedPump) {
                    pumpManager(withHostAndPartition(partitionId, "Stopping the pump."));
                    yield capturedPump.stop(reason);
                }
                else {
                    pumpManager(withHostAndPartition(partitionId, "No pump was found, to remove."));
                }
            }
            catch (err) {
                const msg = `An error occurred while removing a pump for partitionId '${partitionId}': ` +
                    `${err ? err.stack : JSON.stringify(err)}`;
                error(withHostAndPartition(partitionId, "%s."), msg);
                this._context.onEphError({
                    hostName: this._context.hostName,
                    partitionId: partitionId,
                    error: new Error(msg),
                    action: EPHActionStrings.partitionReceiverManagement
                });
            }
        });
    }
    removeAllPumps(reason) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHost = this._context.withHost;
            const tasks = [];
            for (const id of this._context.pumps.keys()) {
                tasks.push(this.removePump(id, reason));
            }
            partitionManager(withHost("Removing all the pumps due to reason %s."), reason);
            yield Promise.all(tasks);
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
class PartitionScanner {
    constructor(context) {
        this._allLeaseStates = [];
        this._desiredCount = 0;
        this._unownedCount = 0;
        this._leaseOwnedByOthers = new Map();
        this._context = context;
    }
    scan(isFirst) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const hostName = this._context.hostName;
            const withHost = this._context.withHost;
            let didSteal = false;
            try {
                this._reset();
                partitionScanner(withHost("Starting a new iteration to scan partitions."));
                partitionScanner(withHost("Getting lease states to find out who owns what."));
                yield this._getAllLeaseStates();
                partitionScanner(withHost("Sorting leases to find out the desired partition count."));
                const ourLeasesCount = yield this._sortLeasesAndCalculateDesiredCount(isFirst);
                partitionScanner(withHost("Our lease count: %d."), ourLeasesCount);
                const attemptToAcquire = this._desiredCount - ourLeasesCount;
                partitionScanner(withHost("Attempting to acquire %d leases in parallel starting from " + "position 0."), attemptToAcquire);
                const remainingNeeded = yield this._acquireExpiredInParallel(0, attemptToAcquire);
                partitionScanner(withHost("Looking to steal: %d."), remainingNeeded);
                if (remainingNeeded > 0) {
                    const stealThese = yield this._findLeasesToSteal(remainingNeeded);
                    partitionScanner(withHost("Number of lease found to steal: %d."), stealThese.length);
                    didSteal = yield this._stealLeases(stealThese);
                    partitionScanner(withHost("Have succesfully stolen: %d leases -> %s."), stealThese.length, didSteal);
                }
                else {
                    partitionScanner(withHost("No need to scan further since remaining needed: %d."), remainingNeeded);
                }
            }
            catch (err) {
                didSteal = false;
                const msg = `An error occurred while scanning leases: ` + `${err ? err.stack : JSON.stringify(err)}.`;
                error(withHost("%s"), hostName, msg);
                const info = {
                    action: EPHActionStrings.scanningLeases,
                    error: new Error(msg),
                    hostName: hostName,
                    partitionId: "N/A"
                };
                this._context.onEphError(info);
            }
            return didSteal;
        });
    }
    _reset() {
        this._allLeaseStates = [];
        this._desiredCount = 0;
        this._unownedCount = 0;
        this._leaseOwnedByOthers = new Map();
    }
    _getAllLeaseStates() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const result = yield this._context.leaseManager.getAllLeases();
            this._allLeaseStates = result.sort();
            partitionScanner(this._context.withHost("State of all the leases that we know about:\n%O"), this._allLeaseStates);
            return;
        });
    }
    _sortLeasesAndCalculateDesiredCount(isFirst) {
        const hostName = this._context.hostName;
        const withHost = this._context.withHost;
        partitionScanner(withHost("Accounting input: allLeaseStates count is: %d"), this._allLeaseStates.length);
        const uniqueOwners = new Set();
        uniqueOwners.add(hostName);
        let ourLeasesCount = 0;
        this._unownedCount = 0;
        for (const lease of this._allLeaseStates) {
            const ownedByUs = lease.isOwned && lease.owner === hostName;
            if (lease.isOwned && lease.owner) {
                uniqueOwners.add(lease.owner);
            }
            else {
                this._unownedCount++;
            }
            if (ownedByUs) {
                ourLeasesCount++;
            }
            else if (lease.isOwned) {
                this._leaseOwnedByOthers.set(lease.partitionId, lease);
            }
        }
        const hostCount = uniqueOwners.size;
        const countPerHost = Math.floor(this._allLeaseStates.length / hostCount);
        this._desiredCount = isFirst ? 1 : countPerHost;
        if (!isFirst &&
            this._unownedCount > 0 &&
            this._unownedCount < hostCount &&
            this._allLeaseStates.length % hostCount !== 0) {
            // distribute leftovers
            this._desiredCount++;
        }
        const sortedHosts = Array.from(uniqueOwners).sort();
        let hostOrdinal = -1;
        let startingPoint = 0;
        if (isFirst) {
            // If the entire system is starting up, the list of hosts is probably not complete and we
            // can not really compute a meaningful hostOrdinal. But we only want hostOrdinal to
            // calculate startingPoint. Instead, just randomly select a startingPoint.
            startingPoint = randomNumberFromInterval(0, this._allLeaseStates.length - 1);
        }
        else {
            for (hostOrdinal = 0; hostOrdinal > sortedHosts.length; hostOrdinal++) {
                if (sortedHosts[hostOrdinal] === hostName) {
                    break;
                }
            }
            startingPoint = countPerHost * hostOrdinal;
        }
        // rotate this._allLeaseStates
        partitionScanner(withHost("Host ordinal: %d. Rotating leases to start at: %d."), hostOrdinal, startingPoint);
        if (startingPoint !== 0) {
            const rotatedList = [];
            for (let i = 0; i < this._allLeaseStates.length; i++) {
                const index = (i + startingPoint) % this._allLeaseStates.length;
                rotatedList.push(this._allLeaseStates[index]);
            }
            this._allLeaseStates = rotatedList;
        }
        partitionScanner(withHost("Host count is %d. So Desired partition count is %d."), hostCount, this._desiredCount);
        partitionScanner(withHost("our leases count: %d v/s leases owned by others: %d."), ourLeasesCount, this._leaseOwnedByOthers.size);
        partitionScanner(withHost("Total number of pumps: %d."), this._context.pumps.size);
        return ourLeasesCount;
    }
    _findExpiredLeases(startAt, endAt) {
        const withHost = this._context.withHost;
        const expiredLeases = [];
        partitionScanner(withHost("Finding expired leases from '%s': [%d] upto '%s': [%d]"), this._allLeaseStates[startAt].partitionId, startAt, endAt < this._allLeaseStates.length ? this._allLeaseStates[endAt].partitionId : "end", endAt);
        for (const lease of this._allLeaseStates.slice(startAt, endAt)) {
            if (!lease.isOwned) {
                expiredLeases.push(lease);
            }
        }
        partitionScanner(withHost("Found in range: %d"), expiredLeases.length);
        return expiredLeases;
    }
    _acquireExpiredInParallel(startAt, needed) {
        const hostName = this._context.hostName;
        const withHost = this._context.withHost;
        const withHostAndPartition = this._context.withHostAndPartition;
        const resultPromise = Promise.resolve(needed);
        if (startAt < this._allLeaseStates.length) {
            const lease = this._allLeaseStates[startAt];
            const partitionId = lease ? lease.partitionId : "undefined";
            partitionScanner(withHost("Examining chunk at '%s': [%d], needed %d."), partitionId, startAt, needed);
        }
        else {
            partitionScanner(withHost("Examining chunk skipping, startAt is off end: %d"), startAt);
        }
        if (needed > 0 && this._unownedCount > 0 && startAt < this._allLeaseStates.length) {
            let runningNeeded = needed;
            const endAt = Math.min(startAt + needed, this._allLeaseStates.length);
            partitionScanner(withHost("Finding expired leases from inclusive position range %d - %d"), startAt, endAt);
            const getThese = this._findExpiredLeases(startAt, endAt);
            const leaseManager = this._context.leaseManager;
            const getTheseResult = [];
            for (const thisLease of getThese) {
                let lease = undefined;
                const getThisPromise = leaseManager
                    .getLease(thisLease.partitionId)
                    .then((receivedLease) => {
                    lease = receivedLease;
                    if (lease) {
                        return leaseManager.acquireLease(lease);
                    }
                    else {
                        return false;
                    }
                })
                    .then((acquired) => {
                    if (acquired) {
                        runningNeeded--;
                        partitionScanner(withHostAndPartition(thisLease, "Acquired unowned/expired lease."));
                        if (this._leaseOwnedByOthers.has(lease.partitionId)) {
                            this._leaseOwnedByOthers.delete(lease.partitionId);
                            this._unownedCount--;
                        }
                        return this._context.pumpManager.addPump(lease);
                    }
                    else if (lease) {
                        this._leaseOwnedByOthers.set(lease.partitionId, lease);
                    }
                    return Promise.resolve();
                })
                    .catch((err) => {
                    const msg = `An error occurred while getting/acquiring lease for partitionId ` +
                        `'${thisLease.partitionId}': ${err ? err.stack : JSON.stringify(err)}`;
                    error(withHostAndPartition(thisLease, "%s"), msg);
                    const info = {
                        action: EPHActionStrings.checkingLeases,
                        error: new Error(msg),
                        hostName: hostName,
                        partitionId: thisLease.partitionId
                    };
                    this._context.onEphError(info);
                });
                getTheseResult.push(getThisPromise);
            }
            return resultPromise.then(() => {
                return Promise.all(getTheseResult)
                    .catch((err) => {
                    const msg = `An error occurred while getting/acquiring leases for some partitionId: ` +
                        `${err ? err.stack : JSON.stringify(err)}`;
                    error(withHost("%s"), msg);
                })
                    .then(() => {
                    partitionScanner(withHost("Calling _acquireExpiredInParallel with startAt %d, " + "needed %d."), endAt, runningNeeded);
                    return this._acquireExpiredInParallel(endAt, runningNeeded);
                });
            });
        }
        else {
            partitionScanner(withHost("Short circuit: needed is %d, unowned is: %d, off end -> %s."), needed, this._unownedCount, startAt < this._allLeaseStates.length);
        }
        return resultPromise;
    }
    _findLeasesToSteal(stealAsk) {
        // Generate a map of hostnames and owned counts.
        const hostOwns = new Map();
        for (const lease of this._leaseOwnedByOthers.values()) {
            if (hostOwns.has(lease.owner)) {
                const newCount = hostOwns.get(lease.owner) + 1;
                hostOwns.set(lease.owner, newCount);
            }
            else {
                hostOwns.set(lease.owner, 1);
            }
        }
        // Extract hosts which own more than the desired count
        const bigOwners = [];
        const withHost = this._context.withHost;
        for (const entry of hostOwns.entries()) {
            if (entry[1] > this._desiredCount) {
                bigOwners.push(entry[0]);
                partitionScanner(withHost("Big owner %s has %d"), entry[0], entry[1]);
            }
        }
        const stealLeases = [];
        if (bigOwners.length > 0) {
            // Randomly pick one of the big owners
            const index = randomNumberFromInterval(0, bigOwners.length);
            const bigVictim = bigOwners[index];
            const victimExtra = hostOwns.get(bigVictim) - this._desiredCount - 1;
            const stealCount = Math.min(victimExtra, stealAsk);
            partitionScanner(withHost("Stealing %d from %s."), stealCount, bigVictim);
            // Grab stealCount partitions owned by bigVictim and return the leases.
            for (const candidate of this._allLeaseStates) {
                if (candidate.owner != undefined && candidate.owner === bigVictim) {
                    stealLeases.push(candidate);
                    if (stealLeases.length >= stealCount) {
                        break;
                    }
                }
            }
        }
        else {
            partitionScanner(withHost("No big owners found, skipping steal."));
        }
        return stealLeases;
    }
    _stealLeases(stealThese) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            if (stealThese.length > 0) {
                const steals = [];
                for (const stealableLease of stealThese) {
                    let lease = undefined;
                    const tryStealPromise = this._context.leaseManager
                        .getLease(stealableLease.partitionId)
                        .then((receivedLease) => {
                        lease = receivedLease;
                        if (receivedLease) {
                            return this._context.leaseManager.acquireLease(receivedLease);
                        }
                        else {
                            return false;
                        }
                    })
                        .then((acquired) => {
                        if (acquired) {
                            this._context.pumpManager.addPump(lease).catch();
                            partitionScanner(withHostAndPartition(stealableLease, "Successfully stolen the lease."));
                        }
                        return acquired;
                    })
                        .catch((err) => {
                        const msg = `An error occurred while stealing the lease for partitionId ` +
                            `'${stealableLease.partitionId}': ${err ? err.stack : JSON.stringify(err)}`;
                        error(withHostAndPartition(stealableLease, "%s"), msg);
                        const info = {
                            action: EPHActionStrings.stealingLease,
                            partitionId: stealableLease.partitionId,
                            hostName: this._context.hostName,
                            error: err
                        };
                        this._context.onEphError(info);
                        return false;
                    });
                    steals.push(tryStealPromise);
                }
                const stealResult = yield Promise.all(steals);
                // If we found at least one case where the lease could not be stolen then `.some()`
                // returns true. The final result will be true if `.some()` was not able to find a single
                // lease that could not be stolen.
                const result = !stealResult.some((x) => {
                    return !x;
                });
                return result;
            }
            else {
                return false;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
class PartitionManager {
    constructor(context) {
        this._isCancelRequested = false;
        this._isRunning = false;
        this._context = context;
        this._partitionScanner = new PartitionScanner(this._context);
    }
    /**
     * @ignore
     */
    start(onMessage, onError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("onMessage", onMessage, true, "function");
            validateType("onError", onError, true, "function");
            if (this._isRunning) {
                throw new Error("A partition manager cannot be started multiple times.");
            }
            try {
                this._reset();
                this._isRunning = true;
                this._context.onMessage = onMessage;
                this._context.onError = onError;
                yield this._cachePartitionIds();
                yield this._initializeStores();
                this._runTask = this._run();
            }
            catch (err) {
                this._isRunning = false;
                throw err;
            }
        });
    }
    /**
     * @ignore
     */
    stop() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHost = this._context.withHost;
            this._isCancelRequested = true;
            const localRunTask = this._runTask;
            if (localRunTask) {
                try {
                    yield localRunTask;
                }
                catch (err) {
                    const msg = `An error occurred while stopping the run task: ` +
                        `${err ? err.stack : JSON.stringify(err)}.`;
                    error(withHost("%s"), msg);
                }
                finally {
                    this._isRunning = false;
                }
            }
        });
    }
    /**
     * @ignore
     */
    shouldStop() {
        if (this._isCancelRequested) {
            partitionManager(this._context.withHost("Cancellation was requested -> %s. " + "Hence stopping further execution."), this._isCancelRequested);
        }
        return this._isCancelRequested;
    }
    /**
     * @ignore
     */
    _reset() {
        const withHost = this._context.withHost;
        partitionManager(withHost("Resetting the partition manager."));
        this._context.blobReferenceByPartition = {};
        this._context.onMessage = undefined;
        this._context.onError = undefined;
        this._isRunning = false;
        this._isCancelRequested = false;
    }
    /**
     * @ignore
     */
    _run() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHost = this._context.withHost;
            try {
                yield this._scan(true);
            }
            catch (err) {
                const msg = `An error occurred in the main loop of the partition ` +
                    `manager: ${err ? err.stack : JSON.stringify(err)}. Hence shutting down.`;
                error(withHost("%s"), msg);
                this._context.onEphError({
                    hostName: this._context.hostName,
                    partitionId: "N/A",
                    error: err,
                    action: EPHActionStrings.partitionManagerMainLoop
                });
            }
            try {
                // clean up
                partitionManager(withHost("Shutting down all the receivers."));
                yield this._context.pumpManager.removeAllPumps(CloseReason.shutdown);
            }
            catch (err) {
                const msg = `An error occurred while shutting down the partition ` +
                    `manager: ${err ? err.stack : JSON.stringify(err)}.`;
                error(withHost("%s"), msg);
                this._context.onEphError({
                    hostName: this._context.hostName,
                    partitionId: "N/A",
                    error: err,
                    action: EPHActionStrings.partitionManagerCleanup
                });
            }
        });
    }
    /**
     * @ignore
     */
    _cachePartitionIds() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const hostName = this._context.hostName;
            const withHost = this._context.withHost;
            if (!this._context.partitionIds.length) {
                partitionManager(withHost("Get the list of partition ids."));
                const config = {
                    hostName: hostName,
                    operation: () => this._context.getPartitionIds(),
                    retryMessage: "Failure getting partition ids for this Event Hub, retrying",
                    finalFailureMessage: "Out of retries for getting partition ids for this Event Hub",
                    action: EPHActionStrings.gettingPartitionIds,
                    maxRetries: 5
                };
                yield retry(config);
            }
        });
    }
    /**
     * @ignore
     */
    _initializeStores() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const hostName = this._context.hostName;
            const withHost = this._context.withHost;
            const leaseManager = this._context.leaseManager;
            const checkpointManager = this._context.checkpointManager;
            validateType("this._context.onMessage", this._context.onMessage, true, "function");
            validateType("this._context.onError", this._context.onError, true, "function");
            partitionManager(withHost("Ensuring that the lease store exists."));
            if (!(yield leaseManager.leaseStoreExists())) {
                const config = {
                    hostName: hostName,
                    operation: () => leaseManager.createLeaseStoreIfNotExists(),
                    retryMessage: "Failure creating lease store for this Event Hub, retrying",
                    finalFailureMessage: "Out of retries for creating lease store for this Event Hub",
                    action: EPHActionStrings.creatingLeaseStore,
                    maxRetries: 5
                };
                yield retry(config);
            }
            if (this.shouldStop())
                return;
            partitionManager(withHost("Ensure the checkpointstore exists."));
            if (!(yield checkpointManager.checkpointStoreExists())) {
                const config = {
                    hostName: hostName,
                    operation: () => checkpointManager.createCheckpointStoreIfNotExists(),
                    retryMessage: "Failure creating checkpoint store for this Event Hub, retrying",
                    finalFailureMessage: "Out of retries for creating checkpoint store for this Event Hub",
                    action: EPHActionStrings.creatingCheckpointStore,
                    maxRetries: 5
                };
                yield retry(config);
            }
            if (this.shouldStop())
                return;
            partitionManager(withHost("Ensure that the leases exist."));
            const leaseConfig = {
                hostName: hostName,
                operation: () => leaseManager.createAllLeasesIfNotExists(this._context.partitionIds),
                retryMessage: "Failure creating lease for partition, retrying",
                finalFailureMessage: "Out of retries for creating lease for partition",
                action: EPHActionStrings.creatingLease,
                maxRetries: 5
            };
            yield retry(leaseConfig);
            if (this.shouldStop())
                return;
            partitionManager(withHost("Ensure that the checkpoint exists."));
            const checkpointConfig = {
                hostName: hostName,
                operation: () => checkpointManager.createAllCheckpointsIfNotExists(this._context.partitionIds),
                retryMessage: "Failure creating checkpoint for partition, retrying",
                finalFailureMessage: "Out of retries for creating checkpoint for partition",
                action: EPHActionStrings.creatingCheckpoint,
                maxRetries: 5
            };
            yield retry(checkpointConfig);
            if (this.shouldStop())
                return;
        });
    }
    /**
     * @ignore
     */
    _scan(isFirst) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHost = this._context.withHost;
            while (!this.shouldStop()) {
                if (isFirst) {
                    partitionManager(withHost("Starting the first scan."));
                }
                const didSteal = yield this._partitionScanner.scan(isFirst);
                partitionManager(withHost("Did we steal any leases in this scan: %s."), didSteal);
                let seconds = didSteal
                    ? this._context.fastScanInterval
                    : this._context.slowScanInterval;
                if (isFirst) {
                    seconds = this._context.startupScanDelay;
                    isFirst = false;
                }
                partitionManager(withHost("Sleeping for %d seconds before starting the next scan."), seconds);
                yield eventHubs.delay(seconds * 1000);
            }
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
const minLeaseDurationInSeconds = 15;
const maxLeaseDurationInSeconds = 60;
const defaultLeaseDurationInSeconds = 30;
const defaultLeaseRenewIntervalInSeconds = 10;
const defaultMaximumExecutionTimeInMs = 120000;
const maximumExecutionTimeInMsForLeaseRenewal = 60000;
const defaultStartupScanDelayInSeconds = 30;
const defaultFastScanIntervalInSeconds = 3;
const defaultSlowScanIntervalInSeconds = 5;
const metadataOwnerName = "owninghost";
const leaseLost = "leaselost";
const leaseIdMismatchWithLeaseOperation = "leaseidmismatchwithleaseoperation";
const leaseIdMismatchWithBlobOperation = "leaseidmismatchwithbloboperation";
const defaultConsumerGroup = "$default";
const packageInfo = {
    name: "@azure/event-processor-host",
    version: "2.1.1"
};

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
var LeaseState;
(function (LeaseState) {
    /**
     * The lease state is not specified.
     */
    LeaseState["unspecified"] = "unspecified";
    /**
     * The lease is in the "available" state.
     */
    LeaseState["available"] = "available";
    /**
     * The lease is in the "leased" state.
     */
    LeaseState["leased"] = "leased";
    /**
     * The lease is in the "expired" state.
     */
    LeaseState["expired"] = "expired";
    /**
     * The lease is in the "breaking" state.
     */
    LeaseState["breaking"] = "breaking";
    /**
     * The lease is in the "broken" state.
     */
    LeaseState["broken"] = "broken";
})(LeaseState || (LeaseState = {}));
/**
 * @ignore
 */
class BlobService {
    constructor(hostName, connectionString) {
        this._beginningOfTime = new Date(1990, 0, 1).toUTCString();
        this._hostName = hostName;
        this._connectionString = connectionString;
        this._storageBlobService = azureStorage.createBlobService(this._connectionString);
        this._storageBlobService.defaultMaximumExecutionTimeInMs = defaultMaximumExecutionTimeInMs;
    }
    /**
     * Ensures that the container and blob exist.
     */
    ensureContainerAndBlobExist(containerName, blobPath) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("containerName", containerName, true, "string");
            validateType("blobPath", blobPath, true, "string");
            const partitionId = path.basename(blobPath);
            try {
                yield this.ensureContainerExists(containerName);
                yield this.ensureBlobExists(containerName, blobPath, "{}");
            }
            catch (err) {
                const msg = `An error occurred while ensuring that the container and blob exists. ` +
                    `It is: \n${err ? err.stack : JSON.stringify(err)}`;
                error("[%s] [%s] %s", this._hostName, partitionId, msg);
                throw new Error(msg);
            }
        });
    }
    ensureContainerExists(containerName) {
        validateType("containerName", containerName, true, "string");
        return new Promise((resolve, reject) => {
            blobService("[%s] Ensuring that the container '%s' exists.", this._hostName, containerName);
            this._storageBlobService.createContainerIfNotExists(containerName, (error$1, result, response) => {
                if (error$1) {
                    error("[%s] An error occurred while ensuring that the container '%s' exists: %O", this._hostName, containerName, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    const containerInfo = { created: result, details: response };
                    blobService("[%s] Result for Container '%s': %O", this._hostName, containerName, containerInfo);
                    resolve(containerInfo);
                }
            });
        });
    }
    doesContainerExist(containerName) {
        validateType("containerName", containerName, true, "string");
        return new Promise((resolve, reject) => {
            this._storageBlobService.doesContainerExist(containerName, (error$1, result) => {
                if (error$1) {
                    error("[%s] An error occurred while determining whether the container " + "'%s' exists: % O.", this._hostName, containerName, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] Does container '%s' exist -> %s.", this._hostName, containerName, result.exists);
                    resolve(result.exists);
                }
            });
        });
    }
    doesBlobExist(containerName, blobPath) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            this._storageBlobService.doesBlobExist(containerName, blobPath, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while determining whether the blob '%s' exists in " +
                        "container '%s': %O", this._hostName, partitionId, blobPath, containerName, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Does blob '%s' exist in container '%s' -> %s.", this._hostName, partitionId, blobPath, containerName, result.exists);
                    resolve(result.exists);
                }
            });
        });
    }
    ensureBlobExists(containerName, blobPath, text) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        validateType("text", text, true, "string");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            const options = {
                accessConditions: {
                    DateUnModifiedSince: this._beginningOfTime
                }
            };
            blobService("[%s] [%s] Ensuring that blob '%s' exists in container '%s'.", this._hostName, partitionId, blobPath, containerName);
            this._storageBlobService.createBlockBlobFromText(containerName, blobPath, text, options, (error$1) => {
                if (error$1) {
                    if (error$1.statusCode === 412) {
                        // Blob already exists.
                        resolve();
                    }
                    else {
                        error("[%s] [%s] An error occurred while ensuring that blob '%s' exists in " +
                            "container '%s': %O", this._hostName, partitionId, blobPath, containerName, getStorageError(error$1));
                        reject(error$1);
                    }
                }
                else {
                    resolve();
                }
            });
        });
    }
    renewLease(containerName, blobPath, leaseId, options) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        validateType("leaseId", leaseId, true, "string");
        validateType("options", options, false, "object");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            if (!options)
                options = {};
            blobService("[%s] [%s] Attempting to renew lease '%s' for blobPath '%s'.", this._hostName, partitionId, leaseId, blobPath);
            this._storageBlobService.renewLease(containerName, blobPath, leaseId, options, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while renewing lease '%s' for blobPath '%s': %O.", this._hostName, partitionId, leaseId, blobPath, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Successfully, renewed lease with leaseId: '%s' for blobPath '%s'.", this._hostName, partitionId, leaseId, blobPath);
                    resolve(result);
                }
            });
        });
    }
    releaseLease(containerName, blobPath, leaseId, options) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        validateType("leaseId", leaseId, true, "string");
        validateType("options", options, false, "object");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            if (!options)
                options = {};
            blobService("[%s] [%s] Attempting to release lease '%s' for blobPath '%s'.", this._hostName, partitionId, leaseId, blobPath);
            this._storageBlobService.releaseLease(containerName, blobPath, leaseId, options, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while releasing lease '%s' for blobPath '%s': %O.", this._hostName, partitionId, leaseId, blobPath, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Successfully, released lease with leaseId: '%s' for blobPath '%s'.", this._hostName, partitionId, leaseId, blobPath);
                    resolve(result);
                }
            });
        });
    }
    updateContent(containerName, blobPath, text, options) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        validateType("text", text, true, "string");
        validateType("options", options, false, "object");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            if (!options)
                options = {};
            blobService("[%s] [%s] Updating content '%s' in the container '%s' of the blob '%s' .", this._hostName, partitionId, text, containerName, blobPath);
            this._storageBlobService.createBlockBlobFromText(containerName, blobPath, text, options, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while updating content '%s' to blobPath '%s': %O.", this._hostName, partitionId, text, blobPath, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Successfully, updated blob content '%s' for blobPath '%s'.", this._hostName, partitionId, text, blobPath);
                    resolve(result);
                }
            });
        });
    }
    getContent(containerName, blobPath, options) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        validateType("options", options, false, "object");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            if (!options)
                options = {};
            blobService("[%s] [%s] Attempting to getcontent from blobPath '%s'.", this._hostName, partitionId, blobPath);
            this._storageBlobService.getBlobToText(containerName, blobPath, options, (error$1, text, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while getting content from blobPath '%s': %O.", this._hostName, partitionId, blobPath, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Successfully, fetched blob content '%s' for blobPath '%s'.", this._hostName, partitionId, text, blobPath);
                    resolve(text);
                }
            });
        });
    }
    changeLease(containerName, blobPath, currentLeaseId, proposedLeaseId) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        validateType("currentLeaseId", currentLeaseId, true, "string");
        validateType("proposedLeaseId", proposedLeaseId, true, "string");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            blobService("[%s] [%s] Attempting to change lease '%s' for blobPath '%s' with new lease '%s'.", this._hostName, partitionId, currentLeaseId, blobPath, proposedLeaseId);
            this._storageBlobService.changeLease(containerName, blobPath, currentLeaseId, proposedLeaseId, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while changing lease '%s' to '%s' for blobPath " +
                        "'%s': %O.", this._hostName, partitionId, currentLeaseId, proposedLeaseId, blobPath, error$1);
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Successfully, changed current lease '%s' with proposed lease " +
                        "'%s' for blobPath '%s'.", this._hostName, partitionId, currentLeaseId, proposedLeaseId, blobPath);
                    resolve(result);
                }
            });
        });
    }
    getBlobProperties(containerName, blobPath) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            blobService("[%s] [%s] Attempting to get blob props for blobPath '%s'.", this._hostName, partitionId, blobPath);
            this._storageBlobService.getBlobProperties(containerName, blobPath, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while getting blob props for blobPath '%s': %O.", this._hostName, partitionId, blobPath, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Successfully, got blob props for blobPath '%s'.", this._hostName, partitionId, blobPath);
                    resolve(result);
                }
            });
        });
    }
    listBlobsSegmented(containerName, options) {
        validateType("containerName", containerName, true, "string");
        if (!options) {
            options = {
                maxResults: 5000,
                include: "metadata"
            };
        }
        return new Promise((resolve, reject) => {
            blobService("[%s] Attempting to list blobs for container '%s'.", this._hostName, containerName);
            this._storageBlobService.listBlobsSegmented(containerName, undefined, options, (error$1, result) => {
                if (error$1) {
                    error("[%s] An error occurred while listing blobs for container '%s': %O.", this._hostName, containerName, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] Successfully, received the list of blobs for container '%s'.", this._hostName, containerName);
                    resolve(result);
                }
            });
        });
    }
    getBlobMetadata(containerName, blobPath) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            blobService("[%s] [%s] Attempting to get blob metadata for blobPath '%s'.", this._hostName, partitionId, blobPath);
            this._storageBlobService.getBlobMetadata(containerName, blobPath, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while getting blob metadata for blobPath '%s': %O.", this._hostName, partitionId, blobPath, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Successfully, got the blob metadata %o for blobPath '%s'.", this._hostName, partitionId, result, blobPath);
                    resolve(result);
                }
            });
        });
    }
    setBlobMetadata(containerName, blobPath, metadata, options) {
        if (!options)
            options = {};
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        validateType("metadata", metadata, true, "object");
        validateType("options", options, true, "object");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            blobService("[%s] [%s] Attempting to set blob metadata %o for blobPath '%s'.", this._hostName, partitionId, metadata, blobPath);
            this._storageBlobService.setBlobMetadata(containerName, blobPath, metadata, options, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while setting blob metadata for blobPath '%s': %O.", this._hostName, partitionId, blobPath, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Successfully, set the blob metadata for blobPath '%s'. " +
                        "The result is: name: %s, metadata: %o, lease: %o", this._hostName, partitionId, blobPath, result.name, result.metadata, result.lease);
                    resolve(result);
                }
            });
        });
    }
    acquireLease(containerName, blobPath, options) {
        validateType("containerName", containerName, true, "string");
        validateType("blobPath", blobPath, true, "string");
        validateType("options", options, false, "object");
        const partitionId = path.basename(blobPath);
        return new Promise((resolve, reject) => {
            if (!options)
                options = {};
            blobService("[%s] [%s] Attempting to acquire lease for blobPath '%s'.", this._hostName, partitionId, blobPath);
            this._storageBlobService.acquireLease(containerName, blobPath, options, (error$1, result) => {
                if (error$1) {
                    error("[%s] [%s] An error occurred while acquiring lease for blobPath '%s': %O.", this._hostName, partitionId, blobPath, getStorageError(error$1));
                    reject(error$1);
                }
                else {
                    blobService("[%s] [%s] Acquired lease '%s' for blobPath '%s.", this._hostName, partitionId, result.id, blobPath);
                    resolve(result);
                }
            });
        });
    }
    deleteBlobIfExists(containerName, blobPath) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("containerName", containerName, true, "string");
            validateType("blobPath", blobPath, true, "string");
            const partitionId = path.basename(blobPath);
            return new Promise((resolve, reject) => {
                blobService("[%s] Attempting to delete blob for blobPath '%s'.", this._hostName, partitionId, blobPath);
                this._storageBlobService.deleteBlobIfExists(containerName, blobPath, (error$1, result) => {
                    if (error$1) {
                        error("[%s] An error occurred while deleting blob for blobPath '%s': %O.", this._hostName, partitionId, blobPath, getStorageError(error$1));
                        reject(error$1);
                    }
                    else {
                        blobService("[%s] [%s] Deleted blob '%s' ->  %s.", this._hostName, partitionId, partitionId, blobPath, result);
                        resolve();
                    }
                });
            });
        });
    }
    deleteContainerIfExists(containerName) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("containerName", containerName, true, "string");
            return new Promise((resolve, reject) => {
                blobService("[%s] Attempting to delete container '%s'.", this._hostName, containerName);
                this._storageBlobService.deleteContainerIfExists(containerName, (error$1, result) => {
                    if (error$1) {
                        error("[%s] An error occurred while deleting container '%s': %O.", this._hostName, containerName, getStorageError(error$1));
                        reject(error$1);
                    }
                    else {
                        blobService("[%s] Deleted container '%s' ->  %s.", this._hostName, containerName, result);
                        resolve();
                    }
                });
            });
        });
    }
    static create(hostName, connectionString) {
        validateType("hostName", hostName, true, "string");
        validateType("connectionString", connectionString, true, "string");
        return new BlobService(hostName, connectionString);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
class AzureBlob {
    constructor(hostName, connectionString, containerName, blob, blobService) {
        this._containerAndBlobExist = false;
        this._blobPath = blob;
        this._containerName = containerName;
        this._blobService = blobService || BlobService.create(hostName, connectionString);
    }
    ensureContainerAndBlobExist() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                if (!this._containerAndBlobExist) {
                    yield this._blobService.ensureContainerAndBlobExist(this._containerName, this._blobPath);
                    this._containerAndBlobExist = true;
                }
            }
            catch (err) {
                const msg = `An error occurred while ensuring that the container and blob exists. ` +
                    `It is: \n${err ? err.stack : JSON.stringify(err)}`;
                throw new Error(msg);
            }
        });
    }
    ensureContainerExists() {
        return this._blobService.ensureContainerExists(this._containerName);
    }
    doesContainerExist() {
        return this._blobService.doesContainerExist(this._containerName);
    }
    doesBlobExist() {
        return this._blobService.doesBlobExist(this._containerName, this._blobPath);
    }
    ensureBlobExists(text) {
        return this._blobService.ensureBlobExists(this._containerName, this._blobPath, text);
    }
    renewLease(leaseId, options) {
        return this._blobService.renewLease(this._containerName, this._blobPath, leaseId, options);
    }
    releaseLease(leaseId, options) {
        return this._blobService.releaseLease(this._containerName, this._blobPath, leaseId, options);
    }
    updateContent(text, options) {
        return this._blobService.updateContent(this._containerName, this._blobPath, text, options);
    }
    getContent(options) {
        return this._blobService.getContent(this._containerName, this._blobPath, options);
    }
    changeLease(currentLeaseId, proposedLeaseId) {
        return this._blobService.changeLease(this._containerName, this._blobPath, currentLeaseId, proposedLeaseId);
    }
    getBlobProperties() {
        return this._blobService.getBlobProperties(this._containerName, this._blobPath);
    }
    getBlobMetadata() {
        return this._blobService.getBlobMetadata(this._containerName, this._blobPath);
    }
    setBlobMetadata(metadata, options) {
        return this._blobService.setBlobMetadata(this._containerName, this._blobPath, metadata, options);
    }
    listBlobsSegmented(options) {
        return this._blobService.listBlobsSegmented(this._containerName, options);
    }
    acquireLease(options) {
        return this._blobService.acquireLease(this._containerName, this._blobPath, options);
    }
    deleteBlobIfExists() {
        return this._blobService.deleteBlobIfExists(this._containerName, this._blobPath);
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * Describes the base lease.
 */
class BaseLease {
    /**
     * @constructor
     * @param info The information required to create a base lease.
     */
    constructor(info) {
        /**
         * @property {boolean} isOwned Indicates wether the lease is owned. `true` if it is owned by
         * someone; `false` otherwise.
         */
        this.isOwned = false;
        this.partitionId = info.partitionId;
        this.owner = info.owner;
    }
    /**
     * Compares possibleOwner against this.owner
     * @param {string} possibleOwner The owner name to check.
     * @returns {boolean} boolean - true if possibleOwner is the same as this.owner, false otherwise.
     */
    isOwnedBy(possibleOwner) {
        return this.owner === possibleOwner;
    }
    /**
     * Gets the lease information.
     * @returns {CompleteLeaseInfo} CompleteLeaseInfo.
     */
    getInfo() {
        const info = {
            partitionId: this.partitionId,
            owner: this.owner
        };
        return info;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes a Complete Lease.
 * @class CompleteLease.
 */
class CompleteLease extends BaseLease {
    /**
     * Creates an instance of the Lease.
     * @constructor
     * @param {CompleteLeaseInfo} info The Lease info.
     */
    constructor(info) {
        super(info);
        this.epoch = info.epoch != undefined ? info.epoch : -1;
    }
    /**
     * Increments the value of epoch by 1.
     * @returns {number} The incremented value of the epoch.
     */
    incrementEpoch() {
        const result = ++this.epoch;
        completeLease("[%s] [%s] New epoch for lease is %s.", this.owner, this.partitionId, result);
        return result;
    }
    /**
     * Gets the lease information.
     * @returns {CompleteLeaseInfo} CompleteLeaseInfo.
     */
    getInfo() {
        const info = super.getInfo();
        info.epoch = this.epoch;
        completeLease("[%s] [%s] Lease info is: %o", this.owner, this.partitionId, info);
        return info;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the lease used with an Azure Blob for storing the checkpoint information.
 */
class AzureBlobLease extends CompleteLease {
    constructor(info) {
        super(info);
        this.offset = info.offset;
        this.sequenceNumber = info.sequenceNumber != undefined ? info.sequenceNumber : 0;
        this.token = info.token || "";
        this.blob = info.blob;
    }
    /**
     * Gets the lease information.
     * @returns {LeaseInfo} LeaseInfo.
     */
    getInfo() {
        const info = super.getInfo();
        info.sequenceNumber = this.sequenceNumber;
        info.token = this.token;
        info.offset = this.offset;
        azurebloblease("[%s] [%s] Lease info is: %o", this.owner, this.partitionId, info);
        return info;
    }
    /**
     * Serializes the lease information.
     * @returns {string} string The serialized lease info.
     */
    serialize() {
        return JSON.stringify(this.getInfo());
    }
    /**
     * Creates a Lease for the given partitionId.
     * @param {string} id The partitionId for which the lease needs to be created.
     * @param {AzureBlob} blob The azure blob reference
     * @returns {CompleteLease} Lease.
     */
    static createFromPartitionId(id, blob) {
        return new AzureBlobLease({
            partitionId: id,
            epoch: -1,
            sequenceNumber: 0,
            owner: "",
            token: "",
            blob: blob
        });
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
var UploadActivity;
(function (UploadActivity) {
    UploadActivity["create"] = "create";
    UploadActivity["acquire"] = "acquire";
    UploadActivity["release"] = "release";
    UploadActivity["update"] = "update";
})(UploadActivity || (UploadActivity = {}));
/**
 * @ignore
 */
class AzureStorageCheckpointLeaseManager {
    constructor(context) {
        this._latestCheckpoint = new Map();
        this._context = context;
        this.leaseDuration = this._context.leaseDuration;
        this.leaseRenewInterval = this._context.leaseRenewInterval;
    }
    getAzureBlob(partitionId) {
        validateType("partitionId", partitionId, true, "string");
        let result = this._context.blobReferenceByPartition[partitionId];
        if (!result) {
            const blobPath = `${this._context.composedBlobPrefix}${partitionId}`;
            result = new AzureBlob(this._context.hostName, this._context.storageConnectionString, this._context.storageContainerName, blobPath, this._context.blobService);
            this._context.blobReferenceByPartition[partitionId] = result;
        }
        return result;
    }
    downloadLease(partitionId, blob) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const text = yield blob.getContent();
                const jsonLease = JSON.parse(text);
                const blobLeaseInfo = Object.assign(Object.assign({}, jsonLease), { blob: blob });
                return new AzureBlobLease(blobLeaseInfo);
            }
            catch (err) {
                const msg = `An error occurred while downloading the lease for blobPath ` +
                    `"${this._context.composedBlobPrefix}${partitionId}". It is: \n` +
                    `${err ? err.stack : JSON.stringify(err)}`;
                error(this._context.withHost(msg));
                throw new Error(msg);
            }
        });
    }
    leaseStoreExists() {
        return this._context.blobService.doesContainerExist(this._context.storageContainerName);
    }
    createLeaseStoreIfNotExists() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this._context.blobService.ensureContainerExists(this._context.storageContainerName);
            return;
        });
    }
    deleteLeaseStore() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const blobService = this._context.blobService;
            const storageContainerName = this._context.storageContainerName;
            try {
                if (blobService) {
                    const listResult = yield blobService.listBlobsSegmented(storageContainerName);
                    const deleteBlobs = [];
                    for (const blob of listResult.entries) {
                        deleteBlobs.push(blobService.deleteBlobIfExists(storageContainerName, blob.name));
                    }
                    yield Promise.all(deleteBlobs);
                    yield blobService.deleteContainerIfExists(storageContainerName);
                }
                else {
                    throw new Error("'blobService' is not defined in the 'hostContext', hence cannot " + "list all the blobs.");
                }
            }
            catch (err) {
                const msg = `An error occurred while deleting the lease store '${storageContainerName}': %O` +
                    `${err ? err.stack : JSON.stringify(err)}`;
                error(this._context.withHost(msg));
                const info = {
                    error: new Error(msg),
                    hostName: this._context.hostName,
                    partitionId: "N/A",
                    action: EPHActionStrings.deletingLeaseStore
                };
                this._context.onEphError(info);
            }
        });
    }
    getLease(partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("partitionId", partitionId, true, "string");
            let result;
            const blob = this.getAzureBlob(partitionId);
            const withHostAndPartition = this._context.withHostAndPartition;
            checkpointLeaseMgr(withHostAndPartition(partitionId, "Getting lease."));
            try {
                if (yield blob.doesBlobExist()) {
                    result = yield this.downloadLease(partitionId, blob);
                }
            }
            catch (err) {
                const msg = `An error occurred while getting lease for partitionId '${partitionId}': \n` +
                    `${err ? err.stack : JSON.stringify(err)}`;
                error(withHostAndPartition(partitionId, msg));
                throw new Error(msg);
            }
            return result;
        });
    }
    getAllLeases() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const result = [];
            const withHost = this._context.withHost;
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                const leaseBlobs = yield this._listBlobs();
                for (const lbi of leaseBlobs) {
                    const name = lbi.name;
                    const partitionId = path.basename(name);
                    const leaseInfo = {
                        partitionId: partitionId,
                        owner: lbi.metadata[metadataOwnerName]
                    };
                    const lease = new BaseLease(leaseInfo);
                    lease.isOwned = (lbi.lease && lbi.lease.state === LeaseState.leased) || false;
                    result.push(lease);
                    checkpointLeaseMgr(withHostAndPartition(partitionId, "BlobResult item from the list " + "of blobs is: name: %s, lease: %o, metadata: %o."), lbi.name, lbi.lease, lbi.metadata);
                }
            }
            catch (err) {
                const info = {
                    error: err,
                    action: EPHActionStrings.gettingAllLeases,
                    hostName: this._context.hostName,
                    partitionId: "N/A"
                };
                this._context.onEphError(info);
            }
            checkpointLeaseMgr(withHost("Number of leases: %d"), result.length);
            return result;
        });
    }
    createAllLeasesIfNotExists(partitionIds) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                const withHost = this._context.withHost;
                const leaseBlobs = yield this._listBlobs();
                if (leaseBlobs.length === partitionIds.length) {
                    checkpointLeaseMgr(withHost("Number of blobs %d === Number of partitionIds %d. " + "Hence no need to create leases."), leaseBlobs.length, partitionIds.length);
                    return;
                }
                else {
                    const createPromises = [];
                    for (const id of partitionIds) {
                        const createPromise = this.createLeaseIfNotExists(id);
                        createPromises.push(createPromise);
                    }
                    yield Promise.all(createPromises);
                }
            }
            catch (err) {
                const info = {
                    error: err,
                    action: EPHActionStrings.creatingAllLeases,
                    hostName: this._context.hostName,
                    partitionId: "N/A"
                };
                this._context.onEphError(info);
                throw err;
            }
        });
    }
    createLeaseIfNotExists(partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("partitionId", partitionId, true, "string");
            const withHostAndPartition = this._context.withHostAndPartition;
            checkpointLeaseMgr(withHostAndPartition(partitionId, "createLeaseIfNotExists."));
            let returnLease;
            try {
                const blob = this.getAzureBlob(partitionId);
                returnLease = AzureBlobLease.createFromPartitionId(partitionId, blob);
                yield this._uploadLease(returnLease, UploadActivity.create);
            }
            catch (error$1) {
                const statusCode = error$1.statusCode;
                const code = error$1.code;
                // https://docs.microsoft.com/en-us/rest/api/storageservices/blob-service-error-codes
                // LeaseIdMissing || BlobAlreadyExists
                if ((statusCode === 412 && code && code.toLowerCase() === "leaseidmissing") ||
                    (statusCode === 409 && code && code.toLowerCase() === "blobalreadyexists")) {
                    returnLease = (yield this.getLease(partitionId));
                }
                else {
                    error(withHostAndPartition(partitionId, "An error occurred while creating lease if " + "it does not exist: %O."), error$1);
                    throw error$1;
                }
            }
            return returnLease;
        });
    }
    deleteLease(lease) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield lease.blob.deleteBlobIfExists();
            }
            catch (err) {
                const msg = `An error occurred while deleting the lease for blobPath ` +
                    `"${this._context.composedBlobPrefix}${lease.partitionId}". It is: \n` +
                    `${err ? err.stack : JSON.stringify(err)}`;
                error(this._context.withHostAndPartition(lease, msg));
                throw new Error(msg);
            }
        });
    }
    acquireLease(lease) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let result = true;
            const newLeaseId = v4_1();
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                // TODO: We are initializing newToken to empty string.
                let newToken = "";
                const blobResult = yield lease.blob.getBlobProperties();
                if (blobResult.lease && blobResult.lease.state && blobResult.lease.state === "leased") {
                    if (!lease.token) {
                        // We reach here in a race condition: when this instance of EventProcessorHost scanned the
                        // lease blobs, this partition was unowned (token is empty) but between then and now, another
                        // instance of EPH has established a lease (getLeaseState() is LEASED). We normally enforce
                        // that we only steal the lease if it is still owned by the instance which owned it when we
                        // scanned, but we can't do that when we don't know who owns it. The safest thing to do is just
                        // fail the acquisition. If that means that one EPH instance gets more partitions than it should,
                        // rebalancing will take care of that quickly enough.
                        return false;
                    }
                    checkpointLeaseMgr(withHostAndPartition(lease, "Need to change lease '%s' -> '%s' " + "for partitionId '%s'."), lease.token, newLeaseId, lease.partitionId);
                    const changeLeaseResult = yield lease.blob.changeLease(lease.token, newLeaseId);
                    newToken = changeLeaseResult.id;
                }
                else {
                    try {
                        const options = {
                            leaseDuration: this.leaseDuration,
                            proposedLeaseId: newLeaseId
                        };
                        const acquireResult = yield lease.blob.acquireLease(options);
                        newToken = acquireResult.id;
                    }
                    catch (err) {
                        const statusCode = err && err.statusCode;
                        const code = err && err.code;
                        if (statusCode === 409 && code && code.toLowerCase() === "leasealreadypresent") {
                            // Either some other host grabbed the lease or checkpoint call renewed it.
                            return false;
                        }
                    }
                }
                lease.token = newToken;
                lease.owner = this._context.hostName;
                // Increment epoch each time lease is acquired or stolen by a new host
                lease.incrementEpoch();
                yield this._uploadLease(lease, UploadActivity.acquire);
            }
            catch (err) {
                if (this._wasLeaseLost(lease.partitionId, err)) {
                    result = false;
                }
                else {
                    throw err;
                }
            }
            return result;
        });
    }
    renewLease(lease) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let result = false;
            try {
                const options = {
                    timeoutIntervalInMs: this.leaseRenewInterval * 1000,
                    maximumExecutionTimeInMs: maximumExecutionTimeInMsForLeaseRenewal
                };
                yield lease.blob.renewLease(lease.token, options);
                result = true;
            }
            catch (err) {
                if (!this._wasLeaseLost(lease.partitionId, err)) {
                    throw err;
                }
            }
            return result;
        });
    }
    releaseLease(lease) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                const leaseId = lease.token;
                checkpointLeaseMgr(withHostAndPartition(lease, "Trying to release the lease."));
                const releasedCopy = new AzureBlobLease(Object.assign(Object.assign({}, lease.getInfo()), { blob: lease.blob }));
                releasedCopy.owner = "";
                releasedCopy.token = "";
                yield this._uploadLease(lease, UploadActivity.release);
                yield lease.blob.releaseLease(leaseId);
            }
            catch (err) {
                if (!this._wasLeaseLost(lease.partitionId, err)) {
                    throw err;
                }
            }
            return;
        });
    }
    updateLease(lease) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            if (lease == undefined) {
                return false;
            }
            if (!lease.token) {
                return false;
            }
            checkpointLeaseMgr(withHostAndPartition(lease, "Let us renew the lease to make sure the " +
                "update with offset '%s' and sequence number %d will go through."), lease.offset, lease.sequenceNumber);
            let result = yield this.renewLease(lease);
            if (result) {
                try {
                    yield this._uploadLease(lease, UploadActivity.update);
                }
                catch (err) {
                    if (this._wasLeaseLost(lease.partitionId, err)) {
                        result = false;
                    }
                    else {
                        throw err;
                    }
                }
            }
            // else could not renew lease due to lease loss. Result is already false, so pass it unchanged
            return result;
        });
    }
    checkpointStoreExists() {
        checkpointLeaseMgr(this._context.withHost("Checking whether the checkpoint store exists."));
        return this.leaseStoreExists();
    }
    deleteCheckpointStore() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this.deleteLeaseStore();
        });
    }
    createCheckpointStoreIfNotExists() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // This is a no-op since this method will be called only creating the lease store.
            // The lease store and the checkpoint store are the same thing.
            return;
        });
    }
    createAllCheckpointsIfNotExists(partitionIds) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("partitionIds", partitionIds, true, "Array");
            // Because we control the caller, we know that this method will only be called after
            // createAllLeasesIfNotExists. In this implementation checkpoints are in the same
            // blobs as leases, so the blobs will already exist if execution reaches here.
            return;
        });
    }
    getCheckpoint(partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("partitionId", partitionId, true, "string");
            const withHostAndPartition = this._context.withHostAndPartition;
            let result;
            checkpointLeaseMgr(withHostAndPartition(partitionId, "Getting checkpoint."));
            const lease = yield this.getLease(partitionId);
            if (lease != undefined && lease.offset) {
                result = exports.CheckpointInfo.createFromLease(lease.getInfo());
            }
            return result;
        });
    }
    updateCheckpoint(lease, checkpoint) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            checkpointLeaseMgr(withHostAndPartition(checkpoint, "Checkpoint at offset '%s' and seqno %d."), checkpoint.offset, checkpoint.sequenceNumber);
            lease.offset = checkpoint.offset;
            lease.sequenceNumber = checkpoint.sequenceNumber;
            try {
                if (yield this.updateLease(lease)) {
                    return;
                }
                else {
                    const msg = `Lease lost while updating the checkpoint for partitionId ` +
                        `'${checkpoint.partitionId}'.Hence could not update it.`;
                    error(withHostAndPartition(lease, msg));
                    throw new Error(msg);
                }
            }
            catch (err) {
                const info = {
                    action: EPHActionStrings.updatingCheckpoint,
                    error: err,
                    hostName: this._context.hostName,
                    partitionId: checkpoint.partitionId
                };
                this._context.onEphError(info);
            }
        });
    }
    deleteCheckpoint(partitionId) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            validateType("partitionId", partitionId, true, "string");
            // This is a no-op to avoid deleting leases accidentally.
        });
    }
    _listBlobs() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const blobService = this._context.blobService;
            const withHost = this._context.withHost;
            if (blobService) {
                const listResult = yield blobService.listBlobsSegmented(this._context.storageContainerName);
                checkpointLeaseMgr(withHost("Number of blobs: %d"), listResult.entries.length);
                return listResult.entries;
            }
            else {
                throw new Error("'blobService' is not defined in the 'hostContext', hence cannot " + "list all the blobs.");
            }
        });
    }
    _uploadLease(lease, activity, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const partitionId = lease.partitionId;
            const blob = lease.blob;
            const withHostAndPartition = this._context.withHostAndPartition;
            if (activity !== UploadActivity.create) {
                // It is possible for AzureBlobLease objects in memory to have stale offset/sequence number
                // fields if a checkpoint was written but PartitionManager hasn't done its ten-second sweep
                // which downloads new copies of all the leases. This can happen because we're trying to
                // maintain the fiction that checkpoints and leases are separate -- which they can be in
                // other implementations -- even though they are completely intertwined in this
                // implementation. To prevent writing stale checkpoint data to the store, merge the
                // checkpoint data from the most recently written checkpoint into this write, if needed.
                if (this._latestCheckpoint.has(partitionId)) {
                    const cached = this._latestCheckpoint.get(partitionId);
                    if (cached.sequenceNumber > lease.sequenceNumber || lease.offset == undefined) {
                        (lease.offset = cached.offset), (lease.sequenceNumber = cached.sequenceNumber);
                        checkpointLeaseMgr(withHostAndPartition(lease, "Updating stale offset/seqno with " + "new values %s/%d while uploading lease."), lease.offset, lease.sequenceNumber);
                    }
                    else if (lease.offset != undefined) {
                        this._latestCheckpoint.set(partitionId, exports.CheckpointInfo.createFromLease(lease.getInfo()));
                    }
                }
            }
            const jsonToUpload = lease.serialize();
            if (!options) {
                options = {
                    leaseId: lease.token
                };
            }
            if (!options.metadata)
                options.metadata = {};
            // - For "acquire" and "update" activities, the metadata must be set, since that is the time
            // when the host actually owns the lease. If metadata is not set for update activity
            // (i.e. while checkpointing), then the metadata is wiped off (over-written).
            // This causes problems for the partition scanner while trying to determine the lease owner.
            // - For "release" activity the metadata needs to be deleted/unset, since the intention is to
            // not own the lease anymore (due to lease being lost or the receiver shutting down). Hence,
            // setting the metadata as an empty object.
            // - For "create" activity, the intention is to create a lease if it does not exist, but not own
            // it. The lease state will be available and the status will be unlocked. Hence setting the
            // metadata as an empty object.
            if (activity === UploadActivity.acquire || activity === UploadActivity.update) {
                options.metadata[metadataOwnerName] = lease.owner || this._context.hostName;
            }
            checkpointLeaseMgr(withHostAndPartition(lease, "Trying to upload raw JSON for activity " + "'%s': %s, with options: %o"), activity, jsonToUpload, options);
            yield blob.updateContent(jsonToUpload, options);
        });
    }
    _wasLeaseLost(partitionId, err) {
        let result = false;
        const statusCode = err.statusCode;
        const code = err.code;
        const withHostAndPartition = this._context.withHostAndPartition;
        // conflict OR precondition failed.
        if ((statusCode && statusCode === 409) || statusCode === 412) {
            if (!code ||
                (code &&
                    (code.toLowerCase() === leaseLost ||
                        code.toLowerCase() === leaseIdMismatchWithLeaseOperation ||
                        code.toLowerCase() === leaseIdMismatchWithBlobOperation))) {
                result = true;
            }
        }
        error(withHostAndPartition(partitionId, "Was lease lost -> %s, err: %O."), result, getStorageError(err));
        return result;
    }
}

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * @ignore
 */
var HostContext;
(function (HostContext) {
    function _validateLeaseDurationAndRenewInterval(duration, interval) {
        validateType("leaseDuration", duration, true, "number");
        validateType("leaseRenewInterval", interval, true, "number");
        if (duration <= interval) {
            throw new Error(`Lease duration ${duration} needs to be greater than lease ` + `renew interval ${interval}.`);
        }
        if (duration > maxLeaseDurationInSeconds || duration < minLeaseDurationInSeconds) {
            throw new Error(`Lease duration needs to be between ${minLeaseDurationInSeconds} ` +
                `seconds and ${maxLeaseDurationInSeconds} seconds. The given value is: ${duration} seconds.`);
        }
    }
    function _validatestorageContainerName(name) {
        if (!name || name.match(/^[a-z0-9](([a-z0-9\-[^\-])){1,61}[a-z0-9]$/gi) === null) {
            throw new Error(`Azure Storage lease container name "${name}" is invalid. Please check ` +
                `naming conventions at https://msdn.microsoft.com/en-us/library/azure/dd135715.aspx`);
        }
    }
    function _eitherStorageConnectionStringOrCheckpointLeaseManager(options) {
        validateType("options", options, true, "object");
        const checkpointManager = options.checkpointManager;
        const leaseManager = options.leaseManager;
        const storageConnectionString = options.storageConnectionString;
        if (storageConnectionString) {
            if (checkpointManager || leaseManager) {
                throw new Error("Either provide ('checkpointManager' and 'leaseManager') or " +
                    "provide 'storageConnectionString'.");
            }
        }
        else if (!(checkpointManager && leaseManager)) {
            throw new Error("Either provide ('checkpointManager' and 'leaseManager') or " +
                "provide 'storageConnectionString'.");
        }
    }
    function _createBase(hostName, options) {
        validateType("hostName", hostName, true, "string");
        const onEphErrorFunc = () => {
            // do nothing
        };
        const config = eventHubs.EventHubConnectionConfig.create(options.eventHubConnectionString, options.eventHubPath);
        // set defaults
        if (!options.consumerGroup)
            options.consumerGroup = defaultConsumerGroup;
        if (!options.eventHubPath)
            options.eventHubPath = config.entityPath;
        if (!options.onEphError)
            options.onEphError = onEphErrorFunc;
        if (!options.dataTransformer)
            options.dataTransformer = new eventHubs.DefaultDataTransformer();
        if (!options.startupScanDelay)
            options.startupScanDelay = defaultStartupScanDelayInSeconds;
        if (!options.fastScanInterval)
            options.fastScanInterval = defaultFastScanIntervalInSeconds;
        if (!options.slowScanInterval)
            options.slowScanInterval = defaultSlowScanIntervalInSeconds;
        validateType("options", options, true, "object");
        validateType("options.eventHubPath", options.eventHubPath, true, "string");
        validateType("options.eventHubConnectionString", options.eventHubConnectionString, true, "string");
        validateType("options.storageConnectionString", options.storageConnectionString, false, "string");
        validateType("options.initialOffset", options.initialOffset, false, "object");
        validateType("options.consumerGroup", options.consumerGroup, false, "string");
        validateType("options.storageContainerName", options.storageContainerName, false, "string");
        validateType("options.storageBlobPrefix", options.storageBlobPrefix, false, "string");
        validateType("options.onEphError", options.onEphError, false, "function");
        _eitherStorageConnectionStringOrCheckpointLeaseManager(options);
        if (options.leaseManager) {
            options.leaseDuration = options.leaseManager.leaseDuration;
            options.leaseRenewInterval = options.leaseManager.leaseRenewInterval;
        }
        if (!options.leaseRenewInterval)
            options.leaseRenewInterval = defaultLeaseRenewIntervalInSeconds;
        if (!options.leaseDuration)
            options.leaseDuration = defaultLeaseDurationInSeconds;
        validateType("options.leaseRenewInterval", options.leaseRenewInterval, false, "number");
        validateType("options.leaseDuration", options.leaseDuration, false, "number");
        const context = {
            hostName: hostName,
            checkpointLock: new AsyncLock({ maxPending: 100000 }),
            checkpointLockId: `checkpoint-${v4_1()}`,
            eventHubConnectionString: options.eventHubConnectionString,
            connectionConfig: config,
            eventHubPath: options.eventHubPath,
            tokenProvider: options.tokenProvider,
            blobReferenceByPartition: {},
            partitionIds: [],
            pumps: new Map(),
            consumerGroup: options.consumerGroup,
            storageContainerName: options.storageContainerName,
            leaseRenewInterval: options.leaseRenewInterval,
            leaseDuration: options.leaseDuration,
            initialOffset: options.initialOffset,
            storageBlobPrefix: options.storageBlobPrefix,
            composedBlobPrefix: options.storageBlobPrefix
                ? `${options.storageBlobPrefix.trim()}${options.consumerGroup}/`
                : `${options.consumerGroup}/`,
            onEphError: options.onEphError,
            startupScanDelay: options.startupScanDelay,
            fastScanInterval: options.fastScanInterval,
            slowScanInterval: options.slowScanInterval,
            userAgent: getUserAgent(options),
            withHost: (msg) => {
                return `[${hostName}] ${msg}`;
            },
            withHostAndPartition: (partition, msg) => {
                let id = "N/A";
                if (typeof partition === "string") {
                    id = partition;
                }
                else if (typeof partition === "object") {
                    id = partition.partitionId;
                }
                return `[${hostName}] [${id}] ${msg}`;
            }
        };
        if (options.storageConnectionString) {
            context.storageConnectionString = options.storageConnectionString;
            context.blobService = BlobService.create(hostName, options.storageConnectionString);
        }
        _validateLeaseDurationAndRenewInterval(context.leaseDuration, context.leaseRenewInterval);
        if (context.storageContainerName)
            _validatestorageContainerName(context.storageContainerName);
        return context;
    }
    function _createWithCheckpointLeaseManager(hostName, options) {
        const ctxt = _createBase(hostName, options);
        const checkpointLeaseManager = new AzureStorageCheckpointLeaseManager(ctxt);
        ctxt.leaseManager = options.leaseManager || checkpointLeaseManager;
        ctxt.checkpointManager = options.checkpointManager || checkpointLeaseManager;
        ctxt.getEventHubClient = () => {
            if (ctxt.tokenProvider) {
                return eventHubs.EventHubClient.createFromTokenProvider(ctxt.connectionConfig.host, ctxt.eventHubPath, ctxt.tokenProvider, {
                    userAgent: ctxt.userAgent,
                    webSocket: options && options.webSocket,
                    webSocketConstructorOptions: options && options.webSocketConstructorOptions
                });
            }
            else {
                return eventHubs.EventHubClient.createFromConnectionString(ctxt.eventHubConnectionString, ctxt.eventHubPath, {
                    userAgent: ctxt.userAgent,
                    webSocket: options && options.webSocket,
                    webSocketConstructorOptions: options && options.webSocketConstructorOptions
                });
            }
        };
        ctxt.getHubRuntimeInformation = () => tslib.__awaiter(this, void 0, void 0, function* () {
            const client = ctxt.getEventHubClient();
            try {
                return yield client.getHubRuntimeInformation();
            }
            finally {
                client.close().catch( /* do nothing */);
            }
        });
        ctxt.getPartitionInformation = (id) => tslib.__awaiter(this, void 0, void 0, function* () {
            const client = ctxt.getEventHubClient();
            try {
                return yield client.getPartitionInformation(id);
            }
            finally {
                client.close().catch( /* do nothing */);
            }
        });
        ctxt.getPartitionIds = () => tslib.__awaiter(this, void 0, void 0, function* () {
            if (!ctxt.partitionIds.length) {
                const client = ctxt.getEventHubClient();
                try {
                    ctxt.partitionIds = yield client.getPartitionIds();
                }
                finally {
                    client.close().catch( /* do nothing */);
                }
            }
            return ctxt.partitionIds;
        });
        return ctxt;
    }
    function _createWithPumpManager(hostName, options) {
        const context = _createWithCheckpointLeaseManager(hostName, options);
        context.pumpManager = new PumpManager(context);
        return context;
    }
    /**
     * @property {string} userAgent The user agent string for the EventHubs client.
     * See guideline at https://github.com/Azure/azure-sdk/blob/master/docs/design/Telemetry.mdk
     */
    const userAgent = `azsdk-js-azureeventprocessorhost/${packageInfo.version} (NODE-VERSION ${process.version}; ${os.type()} ${os.release()})`;
    /**
     * @ignore
     */
    function getUserAgent(options) {
        const finalUserAgent = options.userAgent ? `${userAgent},${options.userAgent}` : userAgent;
        return finalUserAgent;
    }
    HostContext.getUserAgent = getUserAgent;
    /**
     * @ignore
     */
    function create(hostName, options) {
        const context = _createWithPumpManager(hostName, options);
        const hostContext = context;
        hostContext.partitionManager = new PartitionManager(context);
        hostContext.partitionScanner = new PartitionScanner(context);
        return hostContext;
    }
    HostContext.create = create;
})(HostContext || (HostContext = {}));

// Copyright (c) Microsoft Corporation. All rights reserved.
/**
 * Describes the Event Processor Host to process events from an EventHub.
 * @class EventProcessorHost
 */
class EventProcessorHost {
    /**
     * Creates a new host to process events from an Event Hub.
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {EventHubClient} eventHubClient The EventHub client
     * @param {EventProcessorOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     */
    constructor(hostName, options) {
        if (!options)
            options = {};
        this._context = HostContext.create(hostName, options);
    }
    /**
     * Provides the host name for the Event processor host.
     */
    get hostName() {
        return this._context.hostName;
    }
    /**
     * Provides the consumer group name for the Event processor host.
     */
    get consumerGroup() {
        return this._context.consumerGroup;
    }
    /**
     * Provides the eventhub runtime information.
     * @returns {Promise<EventHubRuntimeInformation>}
     */
    getHubRuntimeInformation() {
        return this._context.getHubRuntimeInformation();
    }
    /**
     * Provides information about the specified partition.
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     *
     * @returns {EventHubPartitionRuntimeInformation} EventHubPartitionRuntimeInformation
     */
    getPartitionInformation(partitionId) {
        return this._context.getPartitionInformation(partitionId);
    }
    /**
     * Provides an array of partitionIds.
     * @returns {Promise<string[]>}
     */
    getPartitionIds() {
        return this._context.getPartitionIds();
    }
    /**
     * Provides a list of partitions the EPH is currently receiving messages from.
     *
     * The EPH will try to grab leases for more partitions during each scan that happens once every
     * (configured) lease renew seconds. The number of EPH instances that are being run
     * simultaneously to receive messages from the same consumer group within an event hub also
     * influences the number of partitions that this instance of EPH is actively receiving messages
     * from.
     *
     * @returns {Array<string>} Array<string> List of partitions that this EPH instance is currently
     * receiving messages from.
     */
    get receivingFromPartitions() {
        return Array.from(this._context.pumps.keys());
    }
    /**
     * Starts the event processor host, fetching the list of partitions, and attempting to grab leases
     * For each successful lease, it will get the details from the blob and start a receiver at the
     * point where it left off previously.
     *
     * @return {Promise<void>}
     */
    start(onMessage, onError) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._context.partitionManager.start(onMessage, onError);
            }
            catch (err) {
                error(this._context.withHost("An error occurred while starting the EPH: %O"), err);
                this._context.onEphError(err);
                throw err;
            }
        });
    }
    /**
     * Stops the EventProcessorHost from processing messages.
     * @return {Promise<void>}
     */
    stop() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            try {
                yield this._context.partitionManager.stop();
            }
            catch (err) {
                error(this._context.withHost("An error occurred while stopping the EPH: %O"), err);
                this._context.onEphError(err);
                throw err;
            }
        });
    }
    /**
     * Convenience method for generating unique host name.
     *
     * @param {string} [prefix] String to use as the beginning of the name. Default value: "js-host".
     * @return {string} A unique host name
     */
    static createHostName(prefix) {
        if (!prefix)
            prefix = "js-host";
        return `${prefix}-${v4_1()}`;
    }
    /**
     * Creates an EventProcessorHost instance from the EventHub connection string.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {string} storageContainerName Azure Storage container name for use by built-in lease
     * and checkpoint manager.
     * @param {string} eventHubConnectionString Connection string for the Event Hub to receive from.
     * Example: 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;
     * SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {FromConnectionStringOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromConnectionString(hostName, storageConnectionString, storageContainerName, eventHubConnectionString, options) {
        if (!options)
            options = {};
        validateType("hostName", hostName, true, "string");
        validateType("storageConnectionString", storageConnectionString, true, "string");
        validateType("storageContainerName", storageContainerName, true, "string");
        validateType("eventHubConnectionString", eventHubConnectionString, true, "string");
        validateType("options", options, false, "object");
        const ephOptions = Object.assign(Object.assign({}, options), { storageConnectionString: storageConnectionString, storageContainerName: storageContainerName, eventHubConnectionString: eventHubConnectionString });
        return new EventProcessorHost(hostName, ephOptions);
    }
    /**
     * Creates an EventProcessorHost instance from the EventHub connection string with the provided
     * checkpoint manager and lease manager.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} eventHubConnectionString Connection string for the Event Hub to receive from.
     * Example: 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;
     * SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.
     * @param {LeaseManager} leaseManager A manager to manage leases.
     * @param {FromConnectionStringOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromConnectionStringWithCustomCheckpointAndLeaseManager(hostName, eventHubConnectionString, checkpointManager, leaseManager, options) {
        if (!options)
            options = {};
        validateType("hostName", hostName, true, "string");
        validateType("eventHubConnectionString", eventHubConnectionString, true, "string");
        validateType("checkpointManager", checkpointManager, true, "object");
        validateType("leaseManager", leaseManager, true, "object");
        validateType("options", options, false, "object");
        const ephOptions = Object.assign(Object.assign({}, options), { eventHubConnectionString: eventHubConnectionString, checkpointManager: checkpointManager, leaseManager: leaseManager });
        return new EventProcessorHost(hostName, ephOptions);
    }
    /**
     * Creates an EventProcessorHost instance from a TokenProvider.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {string} storageContainerName Azure Storage container name for use by built-in lease
     * and checkpoint manager.
     * @param {string} namespace Fully qualified domain name for Event Hubs.
     * Example: "{your-sb-namespace}.servicebus.windows.net"
     * @param {string} eventHubPath The name of the EventHub.
     * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.
     * @param {FromTokenProviderOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromTokenProvider(hostName, storageConnectionString, storageContainerName, namespace, eventHubPath, tokenProvider, options) {
        if (!options)
            options = {};
        validateType("hostName", hostName, true, "string");
        validateType("storageConnectionString", storageConnectionString, true, "string");
        validateType("storageContainerName", storageContainerName, true, "string");
        validateType("namespace", namespace, true, "string");
        validateType("eventHubPath", eventHubPath, true, "string");
        validateType("tokenProvider", tokenProvider, true, "object");
        validateType("options", options, false, "object");
        if (!namespace.endsWith("/"))
            namespace += "/";
        const connectionString = `Endpoint=sb://${namespace};SharedAccessKeyName=defaultKeyName;` +
            `SharedAccessKey=defaultKeyValue;EntityPath=${eventHubPath}`;
        const ephOptions = Object.assign(Object.assign({}, options), { tokenProvider: tokenProvider, storageConnectionString: storageConnectionString, storageContainerName: storageContainerName, eventHubPath: eventHubPath, eventHubConnectionString: connectionString });
        return new EventProcessorHost(hostName, ephOptions);
    }
    /**
     * Creates an EventProcessorHost instance from a TokenProvider with the provided checkpoint manager
     * and lease manager.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} namespace Fully qualified domain name for Event Hubs.
     * Example: "{your-sb-namespace}.servicebus.windows.net"
     * @param {string} eventHubPath The name of the EventHub.
     * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.
     * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.
     * @param {LeaseManager} leaseManager A manager to manage leases.
     * @param {FromTokenProviderOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromTokenProviderWithCustomCheckpointAndLeaseManager(hostName, namespace, eventHubPath, tokenProvider, checkpointManager, leaseManager, options) {
        if (!options)
            options = {};
        validateType("hostName", hostName, true, "string");
        validateType("namespace", namespace, true, "string");
        validateType("eventHubPath", eventHubPath, true, "string");
        validateType("tokenProvider", tokenProvider, true, "object");
        validateType("checkpointManager", checkpointManager, true, "object");
        validateType("leaseManager", leaseManager, true, "object");
        validateType("options", options, false, "object");
        if (!namespace.endsWith("/"))
            namespace += "/";
        const connectionString = `Endpoint=sb://${namespace};SharedAccessKeyName=defaultKeyName;` +
            `SharedAccessKey=defaultKeyValue;EntityPath=${eventHubPath}`;
        const ephOptions = Object.assign(Object.assign({}, options), { tokenProvider: tokenProvider, eventHubPath: eventHubPath, eventHubConnectionString: connectionString, checkpointManager: checkpointManager, leaseManager: leaseManager });
        return new EventProcessorHost(hostName, ephOptions);
    }
    /**
     * Creates an EventProcessorHost instance from AAD token credentials.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {string} storageContainerName Azure Storage container name for use by built-in lease
     * and checkpoint manager.
     * @param {string} namespace Fully qualified domain name for Event Hubs.
     * Example: "{your-sb-namespace}.servicebus.windows.net"
     * @param {string} eventHubPath The name of the EventHub.
     * @param {TokenCredentials} credentials - The AAD Token credentials. It can be one of the
     * following: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials
     * | MSITokenCredentials.
     * @param {FromTokenProviderOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromAadTokenCredentials(hostName, storageConnectionString, storageContainerName, namespace, eventHubPath, credentials, options) {
        if (!options)
            options = {};
        validateType("hostName", hostName, true, "string");
        validateType("storageConnectionString", storageConnectionString, true, "string");
        validateType("storageContainerName", storageContainerName, true, "string");
        validateType("namespace", namespace, true, "string");
        validateType("eventHubPath", eventHubPath, true, "string");
        validateType("credentials", credentials, true, "object");
        validateType("options", options, false, "object");
        if (!namespace.endsWith("/"))
            namespace += "/";
        const connectionString = `Endpoint=sb://${namespace};SharedAccessKeyName=defaultKeyName;` +
            `SharedAccessKey=defaultKeyValue;EntityPath=${eventHubPath}`;
        const ephOptions = Object.assign(Object.assign({}, options), { tokenProvider: new eventHubs.AadTokenProvider(credentials), storageConnectionString: storageConnectionString, storageContainerName: storageContainerName, eventHubPath: eventHubPath, eventHubConnectionString: connectionString });
        return new EventProcessorHost(hostName, ephOptions);
    }
    /**
     * Creates an EventProcessorHost instance from AAD token credentials with the given checkpoint manager
     * and lease manager.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} namespace Fully qualified domain name for Event Hubs.
     * Example: "{your-sb-namespace}.servicebus.windows.net"
     * @param {string} eventHubPath The name of the EventHub.
     * @param {TokenCredentials} credentials - The AAD Token credentials. It can be one of the
     * following: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials
     * | MSITokenCredentials.
     * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.
     * @param {LeaseManager} leaseManager A manager to manage leases.
     * @param {FromTokenProviderOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromAadTokenCredentialsWithCustomCheckpointAndLeaseManager(hostName, namespace, eventHubPath, credentials, checkpointManager, leaseManager, options) {
        if (!options)
            options = {};
        validateType("hostName", hostName, true, "string");
        validateType("namespace", namespace, true, "string");
        validateType("eventHubPath", eventHubPath, true, "string");
        validateType("credentials", credentials, true, "object");
        validateType("checkpointManager", checkpointManager, true, "object");
        validateType("leaseManager", leaseManager, true, "object");
        validateType("options", options, false, "object");
        if (!namespace.endsWith("/"))
            namespace += "/";
        const connectionString = `Endpoint=sb://${namespace};SharedAccessKeyName=defaultKeyName;` +
            `SharedAccessKey=defaultKeyValue;EntityPath=${eventHubPath}`;
        const ephOptions = Object.assign(Object.assign({}, options), { tokenProvider: new eventHubs.AadTokenProvider(credentials), eventHubPath: eventHubPath, eventHubConnectionString: connectionString, checkpointManager: checkpointManager, leaseManager: leaseManager });
        return new EventProcessorHost(hostName, ephOptions);
    }
    /**
     * Creates an EventProcessorHost instance from the IotHub connection string.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {string} storageContainerName Azure Storage container name for use by built-in lease
     * and checkpoint manager.
     * @param {string} iotHubConnectionString Connection string for the IotHub.
     * Example: 'Endpoint=iot-host-name;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {FromIotHubConnectionStringOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromIotHubConnectionString(hostName, storageConnectionString, storageContainerName, iotHubConnectionString, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            validateType("hostName", hostName, true, "string");
            validateType("storageConnectionString", storageConnectionString, true, "string");
            validateType("storageContainerName", storageContainerName, true, "string");
            validateType("iotHubConnectionString", iotHubConnectionString, true, "string");
            validateType("options", options, false, "object");
            const client = yield eventHubs.EventHubClient.createFromIotHubConnectionString(iotHubConnectionString);
            /* tslint:disable:no-string-literal */
            const eventHubConnectionString = client["_context"].config.connectionString;
            const ephOptions = Object.assign(Object.assign({}, options), { storageConnectionString: storageConnectionString, storageContainerName: storageContainerName, eventHubConnectionString: eventHubConnectionString, eventHubPath: client.eventhubName });
            return new EventProcessorHost(hostName, ephOptions);
        });
    }
    /**
     * Creates an EventProcessorHost instance from the IotHub connection string with the given
     * checkpoint manager and lease manager.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} iotHubConnectionString Connection string for the IotHub.
     * Example: 'Endpoint=iot-host-name;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.
     * @param {LeaseManager} leaseManager A manager to manage leases.
     * @param {FromIotHubConnectionStringOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromIotHubConnectionStringWithCustomCheckpointAndLeaseManager(hostName, iotHubConnectionString, checkpointManager, leaseManager, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (!options)
                options = {};
            validateType("hostName", hostName, true, "string");
            validateType("iotHubConnectionString", iotHubConnectionString, true, "string");
            validateType("checkpointManager", checkpointManager, true, "object");
            validateType("leaseManager", leaseManager, true, "object");
            validateType("options", options, false, "object");
            const client = yield eventHubs.EventHubClient.createFromIotHubConnectionString(iotHubConnectionString);
            /* tslint:disable:no-string-literal */
            const eventHubConnectionString = client["_context"].config.connectionString;
            const ephOptions = Object.assign(Object.assign({}, options), { eventHubConnectionString: eventHubConnectionString, checkpointManager: checkpointManager, leaseManager: leaseManager, eventHubPath: client.eventhubName });
            return new EventProcessorHost(hostName, ephOptions);
        });
    }
}

Object.defineProperty(exports, 'EventData', {
  enumerable: true,
  get: function () {
    return eventHubs.EventData;
  }
});
Object.defineProperty(exports, 'EventPosition', {
  enumerable: true,
  get: function () {
    return eventHubs.EventPosition;
  }
});
Object.defineProperty(exports, 'MessagingError', {
  enumerable: true,
  get: function () {
    return eventHubs.MessagingError;
  }
});
Object.defineProperty(exports, 'aadEventHubsAudience', {
  enumerable: true,
  get: function () {
    return eventHubs.aadEventHubsAudience;
  }
});
Object.defineProperty(exports, 'delay', {
  enumerable: true,
  get: function () {
    return eventHubs.delay;
  }
});
exports.BaseLease = BaseLease;
exports.CompleteLease = CompleteLease;
exports.EventProcessorHost = EventProcessorHost;
exports.PartitionContext = PartitionContext;
//# sourceMappingURL=index.js.map
