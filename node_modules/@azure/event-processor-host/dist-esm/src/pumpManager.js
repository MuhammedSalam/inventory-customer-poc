// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as log from "./log";
import { PartitionPump } from "./partitionPump";
import { CloseReason } from "./modelTypes";
import { EPHActionStrings } from "./util/utils";
/**
 * @ignore
 */
export class PumpManager {
    constructor(context) {
        this._context = context;
    }
    addPump(lease) {
        return __awaiter(this, void 0, void 0, function* () {
            const hostName = this._context.hostName;
            const partitionId = lease.partitionId;
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                const capturedPump = this._context.pumps.get(partitionId);
                if (capturedPump) {
                    const isOpen = capturedPump.isOpen();
                    if (!isOpen) {
                        log.error(withHostAndPartition(partitionId, "The existing pump is open -> %s."), isOpen);
                        yield this.removePump(partitionId, CloseReason.shutdown);
                    }
                    else {
                        log.pumpManager(withHostAndPartition(partitionId, "Updating lease for pump since it" + "is open -> %s."), partitionId, isOpen);
                        capturedPump.lease = lease;
                    }
                }
                else {
                    log.pumpManager(withHostAndPartition(partitionId, "Creating a new pump with lease %o."), lease.getInfo());
                    const pump = new PartitionPump(this._context, lease, this._context.onMessage, this._context.onError);
                    yield pump.start();
                }
            }
            catch (err) {
                const msg = `An error occurred while adding/updating a pump for partitionId ` +
                    `'${partitionId}': ${err ? err.stack : JSON.stringify(err)}`;
                log.error(withHostAndPartition(partitionId, "%s."), msg);
                this._context.onEphError({
                    hostName: hostName,
                    partitionId: partitionId,
                    error: new Error(msg),
                    action: EPHActionStrings.partitionReceiverManagement
                });
            }
        });
    }
    removePump(partitionId, reason) {
        return __awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                const capturedPump = this._context.pumps.get(partitionId);
                if (capturedPump) {
                    log.pumpManager(withHostAndPartition(partitionId, "Stopping the pump."));
                    yield capturedPump.stop(reason);
                }
                else {
                    log.pumpManager(withHostAndPartition(partitionId, "No pump was found, to remove."));
                }
            }
            catch (err) {
                const msg = `An error occurred while removing a pump for partitionId '${partitionId}': ` +
                    `${err ? err.stack : JSON.stringify(err)}`;
                log.error(withHostAndPartition(partitionId, "%s."), msg);
                this._context.onEphError({
                    hostName: this._context.hostName,
                    partitionId: partitionId,
                    error: new Error(msg),
                    action: EPHActionStrings.partitionReceiverManagement
                });
            }
        });
    }
    removeAllPumps(reason) {
        return __awaiter(this, void 0, void 0, function* () {
            const withHost = this._context.withHost;
            const tasks = [];
            for (const id of this._context.pumps.keys()) {
                tasks.push(this.removePump(id, reason));
            }
            log.partitionManager(withHost("Removing all the pumps due to reason %s."), reason);
            yield Promise.all(tasks);
        });
    }
}
//# sourceMappingURL=pumpManager.js.map