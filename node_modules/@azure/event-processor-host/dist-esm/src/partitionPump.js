// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as log from "./log";
import { ErrorNameConditionMapper } from "@azure/event-hubs";
import { PartitionContext } from "./partitionContext";
import { CloseReason } from "./modelTypes";
import { EPHActionStrings } from "./util/utils";
/**
 * @ignore
 */
export class PartitionPump {
    constructor(context, lease, onMessage, onError) {
        this._context = context;
        this._lease = lease;
        this._partitionContext = new PartitionContext(this._context, lease.partitionId, lease);
        this._onMessage = onMessage;
        this._onError = onError;
    }
    get lease() {
        return this._lease;
    }
    set lease(newLease) {
        this._lease = newLease;
        if (this._partitionContext) {
            this._partitionContext.lease = this._lease;
        }
    }
    isOpen() {
        if (this._receiveHandler && this._receiveHandler.isReceiverOpen) {
            return true;
        }
        else {
            return false;
        }
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            yield this._createNewReceiver();
            yield this._scheduleLeaseRenewer();
            log.partitionPump(withHostAndPartition(this._lease, "Successfully started the receiver and scheduled lease renewer."));
        });
    }
    stop(reason) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._removeReceiver(reason);
        });
    }
    _createNewReceiver() {
        return __awaiter(this, void 0, void 0, function* () {
            const partitionId = this._partitionContext.partitionId;
            const withHostAndPartition = this._context.withHostAndPartition;
            try {
                this._client = this._context.getEventHubClient();
            }
            catch (err) {
                log.error(withHostAndPartition(partitionId, "An error occurred while creating " + "the eventhub client: %O."), err);
                throw err;
            }
            log.partitionPump(withHostAndPartition(partitionId, "Getting the initial offset."));
            const eventPosition = yield this._partitionContext.getInitialOffset();
            this._context.pumps.set(partitionId, this);
            log.partitionPump(withHostAndPartition(partitionId, "Added the pump to the internal map."));
            let receiveHandler;
            const rcvrOptions = {
                consumerGroup: this._context.consumerGroup,
                eventPosition: eventPosition,
                epoch: this._lease.epoch
            };
            const onMessage = (eventData) => {
                this._partitionContext.setOffsetAndSequenceNumber(eventData);
                this._onMessage(this._partitionContext, eventData);
            };
            const onError = (error) => __awaiter(this, void 0, void 0, function* () {
                log.error(withHostAndPartition(partitionId, "Receiver '%s' received an error: %O."), receiveHandler.address, error);
                // Let the user know about the error only if it is not ReceiverDisconnectedError.
                // This error happens when another instance of EPH connects a receiver with a higher epoch
                // value to a partition in the same consumer group that this receiver was connected to.
                // This happens due to lease being stolen or current lease expiring, which is expected.
                // Hence not reporting suxh errors to the user will try to make it less confusing for the user.
                if (!this._isReceiverDisconnectedError(error)) {
                    this._onError(error);
                }
                try {
                    yield this._removeReceiver(CloseReason.shutdown);
                }
                catch (err) {
                    log.error(withHostAndPartition(partitionId, "Since we received an error %O " +
                        "on the error handler for receiver with address '%s', we tried closing it. However, " +
                        "error occurred while closing it and it is: %O."), error, receiveHandler.address, err);
                }
            });
            log.partitionPump(withHostAndPartition(partitionId, "Trying to create receiver in " + "consumergroup: '%s' with epoch %d from offset: %s."), rcvrOptions.consumerGroup, rcvrOptions.epoch, eventPosition.getExpression());
            receiveHandler = this._client.receive(partitionId, onMessage, onError, rcvrOptions);
            this._receiveHandler = receiveHandler;
            log.partitionPump(withHostAndPartition(partitionId, "Created receiver '%s' with eventPosition: %s"), receiveHandler.address, eventPosition.getExpression());
        });
    }
    _leaseRenewer() {
        return __awaiter(this, void 0, void 0, function* () {
            const withHostAndPartition = this._context.withHostAndPartition;
            let result = true;
            let error;
            log.partitionPump(withHostAndPartition(this._lease, "Lease renewer is active after " + "%d seconds. Trying to renew the lease"), this._context.leaseRenewInterval);
            try {
                result = yield this._context.leaseManager.renewLease(this._lease);
                if (result) {
                    log.partitionPump(withHostAndPartition(this._lease, "Successfully renewed the lease."));
                }
            }
            catch (err) {
                const msg = `An error occurred while renewing the lease for partitionId ` +
                    `'${this._lease.partitionId}': ${err ? err.stack : JSON.stringify(err)}`;
                error = new Error(msg);
                this._context.onEphError({
                    hostName: this._context.hostName,
                    partitionId: this._lease.partitionId,
                    error: error,
                    action: EPHActionStrings.renewingLease
                });
                log.error(withHostAndPartition(this._lease, msg));
            }
            if (!result) {
                log.error(withHostAndPartition(this._lease, "Failed to renew the lease, result: %s. " + "Shutting down the receiver."), result);
                yield this._removeReceiver(CloseReason.leaseLost);
            }
            else {
                this._scheduleLeaseRenewer();
            }
        });
    }
    _scheduleLeaseRenewer() {
        const withHostAndPartition = this._context.withHostAndPartition;
        const renewalTime = this._context.leaseRenewInterval * 1000;
        log.partitionPump(withHostAndPartition(this._lease, "Scheduling lease renewal in %d seconds."), this._context.leaseRenewInterval);
        this._leaseRenewalTimer = setTimeout(() => __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._leaseRenewer();
            }
            catch (err) {
                log.error(withHostAndPartition(this._lease, "An error occurred in the _leaseRenewer(): %O"), err);
            }
        }), renewalTime);
    }
    _removeReceiver(reason) {
        return __awaiter(this, void 0, void 0, function* () {
            const receiveHandler = this._receiveHandler;
            const partitionContext = this._partitionContext;
            const partitionId = partitionContext.partitionId;
            const leaseId = this._lease.token;
            const withHostAndPartition = this._context.withHostAndPartition;
            if (receiveHandler && this._client) {
                try {
                    this._context.pumps.delete(partitionId);
                    log.partitionPump(withHostAndPartition(partitionId, "Deleted the pump from internal map."));
                    clearTimeout(this._leaseRenewalTimer);
                    log.partitionPump(withHostAndPartition(partitionId, "Removing receiver '%s', due to reason '%s'."), receiveHandler.address, partitionId, reason);
                    yield this._client.close();
                    log.partitionPump(withHostAndPartition(partitionId, "Successfully stopped the receiver '%s' for partitionId '%s' due to reason '%s'."), receiveHandler.address, partitionId, reason);
                }
                catch (err) {
                    const msg = `An error occurred while closing the receiver '${receiveHandler.address}' : ` +
                        `${err ? err.stack : JSON.stringify(err)}`;
                    log.error(withHostAndPartition(partitionId, "%s"), msg);
                }
                this._receiveHandler = undefined;
                this._client = undefined;
                // Release the lease if it was not lost.
                if (reason !== CloseReason.leaseLost) {
                    try {
                        log.partitionPump(withHostAndPartition(partitionContext, "Releasing lease %s after closing the receiver '%s' due to reason '%s'."), leaseId, receiveHandler.address, reason);
                        yield this._context.leaseManager.releaseLease(partitionContext.lease);
                    }
                    catch (err) {
                        const msg = `An error occurred while releasing the lease ${leaseId} ` +
                            `the receiver '${receiveHandler.address}' : ${err ? err.stack : JSON.stringify(err)} `;
                        log.error(withHostAndPartition(partitionId, "%s"), msg);
                        throw err;
                    }
                }
            }
            else {
                log.partitionPump(withHostAndPartition(partitionId, "No receiver was found to remove."));
            }
        });
    }
    _isReceiverDisconnectedError(error) {
        const partitionId = this._partitionContext.partitionId;
        const withHostAndPartition = this._context.withHostAndPartition;
        let result = false;
        if (error) {
            // condition is "amqp:link:stolen"
            if (error.condition === ErrorNameConditionMapper.ReceiverDisconnectedError) {
                result = true;
            }
            else if (error.message.match(/.*New receiver with higher epoch.*/i) !== null) {
                result = true;
                log.error(withHostAndPartition(partitionId, "It looks like the error should have " +
                    "been a 'ReceiverDisconnectedError', however it was not translated correctly: %O."), error);
            }
        }
        return result;
    }
}
//# sourceMappingURL=partitionPump.js.map