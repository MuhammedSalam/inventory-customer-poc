// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as log from "../log";
/**
 * Generates a random number between the given interval
 * @param {number} min Min number of the range (inclusive).
 * @param {number} max Max number of the range (inclusive).
 */
export function randomNumberFromInterval(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
}
/**
 * Validates the type and requiredness of a given parameter.
 * @param paramName The name of the parameter.
 * @param paramValue The parameter value
 * @param type The type of the parameter
 */
export function validateType(paramName, paramValue, required, type) {
    if (required && paramValue == undefined) {
        throw new TypeError(`${paramName} is required. Given value: ${paramValue}. Hence it cannot be null or undefined.`);
    }
    if (paramValue != undefined) {
        if (type === "Array") {
            if (!Array.isArray(paramValue)) {
                throw new TypeError(`${paramName} must be of type "${type}".`);
            }
        }
        else if (type === "Date") {
            if (!(paramValue instanceof Date)) {
                throw new TypeError(`${paramName} must be of type "${type}".`);
            }
        }
        else if (type === "string" ||
            type === "number" ||
            type === "boolean" ||
            type === "object" ||
            type === "function") {
            if (typeof paramValue !== type) {
                throw new TypeError(`${paramName} must be of type "${type}".`);
            }
        }
        else {
            throw new Error(`Invalid argument. type "${type}" is not a valid type. Valid values are: ` +
                `"string", "number", "boolean", "Array", "object", "Date", "function"`);
        }
    }
}
/**
 * @ignore
 */
export function getStorageError(err) {
    return {
        name: err.name,
        message: err.message,
        statusCode: err.statusCode,
        code: err.code,
        requestId: err.requestId
    };
}
/**
 * @ignore
 */
export var EPHActionStrings;
(function (EPHActionStrings) {
    EPHActionStrings["acquireLease"] = "Acquire Lease";
    EPHActionStrings["gettingPartitionIds"] = "Getting PartitionIds";
    EPHActionStrings["gettingAllLeases"] = "Getting All Leases";
    EPHActionStrings["creatingAllLeases"] = "Creating All Leases";
    EPHActionStrings["scanningLeases"] = "Scanning leases";
    EPHActionStrings["checkingLeases"] = "Checking Leases";
    EPHActionStrings["checkingExpiredLeases"] = "Checking Expired Leases";
    EPHActionStrings["renewingLease"] = "Renewing Lease";
    EPHActionStrings["stealingLease"] = "Stealing Lease";
    EPHActionStrings["creatingLease"] = "Creating Lease";
    EPHActionStrings["creatingCheckpoint"] = "Creating Checkpoint";
    EPHActionStrings["updatingCheckpoint"] = "Updating Checkpoint";
    EPHActionStrings["creatingCheckpointStore"] = "Creating Checkpoint Store";
    EPHActionStrings["creatingEventProcessor"] = "Creating Event Processor";
    EPHActionStrings["creatingLeaseStore"] = "Creating Lease Store";
    EPHActionStrings["initializingStores"] = "Initializing Stores";
    EPHActionStrings["partitionManagerCleanup"] = "Partition Manager Cleanup";
    EPHActionStrings["partitionManagerMainLoop"] = "Partition Manager Main Loop";
    EPHActionStrings["partitionReceiverManagement"] = "Partition Receiver Management";
    EPHActionStrings["deletingLeaseStore"] = "Deleting Lease Store";
})(EPHActionStrings || (EPHActionStrings = {}));
/**
 * @ignore
 */
export function retry(config) {
    return __awaiter(this, void 0, void 0, function* () {
        let createdOK = false;
        let retryCount = 0;
        let result = undefined;
        let innerError = undefined;
        do {
            try {
                result = yield config.operation();
                createdOK = true;
                if (config.partitionId) {
                    log.util("[%s] Retry attempt: %d. Action '%s' for partitionId: '%s' suceeded.", config.hostName, retryCount, config.action, config.partitionId);
                }
                else {
                    log.util("[%s] Retry attempt: %d. Action '%s' suceeded.", config.hostName, retryCount, config.action);
                }
            }
            catch (err) {
                innerError = err;
                if (config.partitionId) {
                    log.error("[%s] An error occurred. Retry attempt: %d. PartitionId: '%s'. %s: %O", config.hostName, config.partitionId, retryCount, config.retryMessage, err);
                }
                else {
                    log.error("[%s] An error occurred. Retry attempt: %d. %s: %O", config.hostName, retryCount, config.retryMessage, err);
                }
                retryCount++;
            }
        } while (!createdOK && retryCount < config.maxRetries);
        if (!createdOK) {
            let msg;
            if (innerError) {
                msg =
                    `${config.finalFailureMessage} while performing the action "${config.action}" ` +
                        `due to ${innerError.stack ? innerError.stack : JSON.stringify(innerError)}`;
            }
            else {
                msg = `${config.finalFailureMessage} while performing the action "${config.action}"`;
            }
            log.error("[%s] %s", config.hostName, msg);
            const info = {
                action: config.action,
                hostName: config.hostName,
                partitionId: config.partitionId || "N/A",
                error: new Error(msg)
            };
            throw info;
        }
        return result;
    });
}
//# sourceMappingURL=utils.js.map