// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import { validateType, retry, EPHActionStrings } from "./util/utils";
import { delay } from "@azure/event-hubs";
import * as log from "./log";
import { CloseReason } from "./modelTypes";
import { PartitionScanner } from "./partitionScanner";
/**
 * @ignore
 */
export class PartitionManager {
    constructor(context) {
        this._isCancelRequested = false;
        this._isRunning = false;
        this._context = context;
        this._partitionScanner = new PartitionScanner(this._context);
    }
    /**
     * @ignore
     */
    start(onMessage, onError) {
        return __awaiter(this, void 0, void 0, function* () {
            validateType("onMessage", onMessage, true, "function");
            validateType("onError", onError, true, "function");
            if (this._isRunning) {
                throw new Error("A partition manager cannot be started multiple times.");
            }
            try {
                this._reset();
                this._isRunning = true;
                this._context.onMessage = onMessage;
                this._context.onError = onError;
                yield this._cachePartitionIds();
                yield this._initializeStores();
                this._runTask = this._run();
            }
            catch (err) {
                this._isRunning = false;
                throw err;
            }
        });
    }
    /**
     * @ignore
     */
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            const withHost = this._context.withHost;
            this._isCancelRequested = true;
            const localRunTask = this._runTask;
            if (localRunTask) {
                try {
                    yield localRunTask;
                }
                catch (err) {
                    const msg = `An error occurred while stopping the run task: ` +
                        `${err ? err.stack : JSON.stringify(err)}.`;
                    log.error(withHost("%s"), msg);
                }
                finally {
                    this._isRunning = false;
                }
            }
        });
    }
    /**
     * @ignore
     */
    shouldStop() {
        if (this._isCancelRequested) {
            log.partitionManager(this._context.withHost("Cancellation was requested -> %s. " + "Hence stopping further execution."), this._isCancelRequested);
        }
        return this._isCancelRequested;
    }
    /**
     * @ignore
     */
    _reset() {
        const withHost = this._context.withHost;
        log.partitionManager(withHost("Resetting the partition manager."));
        this._context.blobReferenceByPartition = {};
        this._context.onMessage = undefined;
        this._context.onError = undefined;
        this._isRunning = false;
        this._isCancelRequested = false;
    }
    /**
     * @ignore
     */
    _run() {
        return __awaiter(this, void 0, void 0, function* () {
            const withHost = this._context.withHost;
            try {
                yield this._scan(true);
            }
            catch (err) {
                const msg = `An error occurred in the main loop of the partition ` +
                    `manager: ${err ? err.stack : JSON.stringify(err)}. Hence shutting down.`;
                log.error(withHost("%s"), msg);
                this._context.onEphError({
                    hostName: this._context.hostName,
                    partitionId: "N/A",
                    error: err,
                    action: EPHActionStrings.partitionManagerMainLoop
                });
            }
            try {
                // clean up
                log.partitionManager(withHost("Shutting down all the receivers."));
                yield this._context.pumpManager.removeAllPumps(CloseReason.shutdown);
            }
            catch (err) {
                const msg = `An error occurred while shutting down the partition ` +
                    `manager: ${err ? err.stack : JSON.stringify(err)}.`;
                log.error(withHost("%s"), msg);
                this._context.onEphError({
                    hostName: this._context.hostName,
                    partitionId: "N/A",
                    error: err,
                    action: EPHActionStrings.partitionManagerCleanup
                });
            }
        });
    }
    /**
     * @ignore
     */
    _cachePartitionIds() {
        return __awaiter(this, void 0, void 0, function* () {
            const hostName = this._context.hostName;
            const withHost = this._context.withHost;
            if (!this._context.partitionIds.length) {
                log.partitionManager(withHost("Get the list of partition ids."));
                const config = {
                    hostName: hostName,
                    operation: () => this._context.getPartitionIds(),
                    retryMessage: "Failure getting partition ids for this Event Hub, retrying",
                    finalFailureMessage: "Out of retries for getting partition ids for this Event Hub",
                    action: EPHActionStrings.gettingPartitionIds,
                    maxRetries: 5
                };
                yield retry(config);
            }
        });
    }
    /**
     * @ignore
     */
    _initializeStores() {
        return __awaiter(this, void 0, void 0, function* () {
            const hostName = this._context.hostName;
            const withHost = this._context.withHost;
            const leaseManager = this._context.leaseManager;
            const checkpointManager = this._context.checkpointManager;
            validateType("this._context.onMessage", this._context.onMessage, true, "function");
            validateType("this._context.onError", this._context.onError, true, "function");
            log.partitionManager(withHost("Ensuring that the lease store exists."));
            if (!(yield leaseManager.leaseStoreExists())) {
                const config = {
                    hostName: hostName,
                    operation: () => leaseManager.createLeaseStoreIfNotExists(),
                    retryMessage: "Failure creating lease store for this Event Hub, retrying",
                    finalFailureMessage: "Out of retries for creating lease store for this Event Hub",
                    action: EPHActionStrings.creatingLeaseStore,
                    maxRetries: 5
                };
                yield retry(config);
            }
            if (this.shouldStop())
                return;
            log.partitionManager(withHost("Ensure the checkpointstore exists."));
            if (!(yield checkpointManager.checkpointStoreExists())) {
                const config = {
                    hostName: hostName,
                    operation: () => checkpointManager.createCheckpointStoreIfNotExists(),
                    retryMessage: "Failure creating checkpoint store for this Event Hub, retrying",
                    finalFailureMessage: "Out of retries for creating checkpoint store for this Event Hub",
                    action: EPHActionStrings.creatingCheckpointStore,
                    maxRetries: 5
                };
                yield retry(config);
            }
            if (this.shouldStop())
                return;
            log.partitionManager(withHost("Ensure that the leases exist."));
            const leaseConfig = {
                hostName: hostName,
                operation: () => leaseManager.createAllLeasesIfNotExists(this._context.partitionIds),
                retryMessage: "Failure creating lease for partition, retrying",
                finalFailureMessage: "Out of retries for creating lease for partition",
                action: EPHActionStrings.creatingLease,
                maxRetries: 5
            };
            yield retry(leaseConfig);
            if (this.shouldStop())
                return;
            log.partitionManager(withHost("Ensure that the checkpoint exists."));
            const checkpointConfig = {
                hostName: hostName,
                operation: () => checkpointManager.createAllCheckpointsIfNotExists(this._context.partitionIds),
                retryMessage: "Failure creating checkpoint for partition, retrying",
                finalFailureMessage: "Out of retries for creating checkpoint for partition",
                action: EPHActionStrings.creatingCheckpoint,
                maxRetries: 5
            };
            yield retry(checkpointConfig);
            if (this.shouldStop())
                return;
        });
    }
    /**
     * @ignore
     */
    _scan(isFirst) {
        return __awaiter(this, void 0, void 0, function* () {
            const withHost = this._context.withHost;
            while (!this.shouldStop()) {
                if (isFirst) {
                    log.partitionManager(withHost("Starting the first scan."));
                }
                const didSteal = yield this._partitionScanner.scan(isFirst);
                log.partitionManager(withHost("Did we steal any leases in this scan: %s."), didSteal);
                let seconds = didSteal
                    ? this._context.fastScanInterval
                    : this._context.slowScanInterval;
                if (isFirst) {
                    seconds = this._context.startupScanDelay;
                    isFirst = false;
                }
                log.partitionManager(withHost("Sleeping for %d seconds before starting the next scan."), seconds);
                yield delay(seconds * 1000);
            }
        });
    }
}
//# sourceMappingURL=partitionManager.js.map