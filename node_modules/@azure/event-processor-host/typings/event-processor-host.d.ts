import { aadEventHubsAudience } from '@azure/event-hubs';
import { ApplicationTokenCredentials } from '@azure/ms-rest-nodeauth';
import AsyncLock from 'async-lock';
import { BlobService as BlobService_2 } from 'azure-storage';
import { ClientOptionsBase } from '@azure/event-hubs';
import { DataTransformer } from '@azure/event-hubs';
import { delay } from '@azure/event-hubs';
import { DeviceTokenCredentials } from '@azure/ms-rest-nodeauth';
import { Dictionary } from '@azure/event-hubs';
import { EventData } from '@azure/event-hubs';
import { EventHubClient } from '@azure/event-hubs';
import { EventHubConnectionConfig } from '@azure/event-hubs';
import { EventHubPartitionRuntimeInformation } from '@azure/event-hubs';
import { EventHubRuntimeInformation } from '@azure/event-hubs';
import { EventPosition } from '@azure/event-hubs';
import { MessagingError } from '@azure/event-hubs';
import { MSITokenCredentials } from '@azure/ms-rest-nodeauth';
import { OnError } from '@azure/event-hubs';
import { ServiceResponse } from 'azure-storage';
import { TokenProvider } from '@azure/event-hubs';
import { UserTokenCredentials } from '@azure/ms-rest-nodeauth';
export { aadEventHubsAudience }

/**
 * @ignore
 */
declare class AzureBlob {
    private _blobService;
    private _containerName;
    private _blobPath;
    private _containerAndBlobExist;
    constructor(hostName: string, connectionString: string, containerName: string, blob: string, blobService?: BlobService);
    ensureContainerAndBlobExist(): Promise<void>;
    ensureContainerExists(): Promise<CreateContainerResult>;
    doesContainerExist(): Promise<boolean>;
    doesBlobExist(): Promise<boolean>;
    ensureBlobExists(text: string): Promise<void>;
    renewLease(leaseId: string, options: BlobService_2.LeaseRequestOptions): Promise<BlobService_2.LeaseResult>;
    releaseLease(leaseId: string, options?: BlobService_2.LeaseRequestOptions): Promise<BlobService_2.LeaseResult>;
    updateContent(text: string, options?: BlobService_2.CreateBlobRequestOptions): Promise<BlobService_2.BlobResult>;
    getContent(options?: BlobService_2.GetBlobRequestOptions): Promise<string>;
    changeLease(currentLeaseId: string, proposedLeaseId: string): Promise<BlobService_2.LeaseResult>;
    getBlobProperties(): Promise<BlobService_2.BlobResult>;
    getBlobMetadata(): Promise<BlobService_2.BlobResult>;
    setBlobMetadata(metadata: Dictionary<string>, options?: BlobService_2.BlobRequestOptions): Promise<BlobService_2.BlobResult>;
    listBlobsSegmented(options?: BlobService_2.ListBlobsSegmentedRequestOptions): Promise<BlobService_2.ListBlobsResult>;
    acquireLease(options: BlobService_2.AcquireLeaseRequestOptions): Promise<BlobService_2.LeaseResult>;
    deleteBlobIfExists(): Promise<void>;
}

/**
 * @ignore
 */
declare interface BaseHostContext {
    hostName: string;
    checkpointLock: AsyncLock;
    checkpointLockId: string;
    consumerGroup: string;
    eventHubPath: string;
    storageContainerName?: string;
    eventHubConnectionString: string;
    connectionConfig: EventHubConnectionConfig;
    onEphError: OnEphError;
    leaseRenewInterval: number;
    leaseDuration: number;
    partitionIds: string[];
    blobReferenceByPartition: Dictionary<AzureBlob>;
    storageConnectionString?: string;
    tokenProvider?: TokenProvider;
    initialOffset?: EventPosition;
    storageBlobPrefix?: string;
    blobService?: BlobService;
    composedBlobPrefix: string;
    onMessage?: OnReceivedMessage;
    onError?: OnReceivedError;
    startupScanDelay?: number;
    fastScanInterval?: number;
    slowScanInterval?: number;
    pumps: Map<string, PartitionPump>;
    userAgent: string;
    withHost(msg: string): string;
    withHostAndPartition(partition: string | {
        partitionId: string;
    }, msg: string): string;
}

/**
 * Describes the base lease.
 */
export declare class BaseLease implements BaseLeaseInfo {
    /**
     * @property {string} partitionId The associated partitionId for which the lease is held.
     * @readonly
     */
    readonly partitionId: string;
    /**
     * @property {string} owner The host owner for the partition.
     */
    owner: string;
    /**
     * @property {boolean} isOwned Indicates wether the lease is owned. `true` if it is owned by
     * someone; `false` otherwise.
     */
    isOwned: boolean;
    /**
     * @constructor
     * @param info The information required to create a base lease.
     */
    constructor(info: BaseLeaseInfo);
    /**
     * Compares possibleOwner against this.owner
     * @param {string} possibleOwner The owner name to check.
     * @returns {boolean} boolean - true if possibleOwner is the same as this.owner, false otherwise.
     */
    isOwnedBy(possibleOwner: string): boolean;
    /**
     * Gets the lease information.
     * @returns {CompleteLeaseInfo} CompleteLeaseInfo.
     */
    getInfo(): BaseLeaseInfo;
}

/**
 * Describes the basic information required in a lease.
 */
export declare interface BaseLeaseInfo {
    /**
     * @property {string} partitionId The associated partitionId for which the lease is held.
     */
    partitionId: string;
    /**
     * @property {string} owner The host owner for the partition.
     */
    owner: string;
}

/**
 * @ignore
 */
declare class BlobService {
    private _hostName;
    private _connectionString;
    private _storageBlobService;
    private _beginningOfTime;
    constructor(hostName: string, connectionString: string);
    /**
     * Ensures that the container and blob exist.
     */
    ensureContainerAndBlobExist(containerName: string, blobPath: string): Promise<void>;
    ensureContainerExists(containerName: string): Promise<CreateContainerResult>;
    doesContainerExist(containerName: string): Promise<boolean>;
    doesBlobExist(containerName: string, blobPath: string): Promise<boolean>;
    ensureBlobExists(containerName: string, blobPath: string, text: string): Promise<void>;
    renewLease(containerName: string, blobPath: string, leaseId: string, options: BlobService_2.LeaseRequestOptions): Promise<BlobService_2.LeaseResult>;
    releaseLease(containerName: string, blobPath: string, leaseId: string, options?: BlobService_2.LeaseRequestOptions): Promise<BlobService_2.LeaseResult>;
    updateContent(containerName: string, blobPath: string, text: string, options?: BlobService_2.CreateBlobRequestOptions): Promise<BlobService_2.BlobResult>;
    getContent(containerName: string, blobPath: string, options?: BlobService_2.GetBlobRequestOptions): Promise<string>;
    changeLease(containerName: string, blobPath: string, currentLeaseId: string, proposedLeaseId: string): Promise<BlobService_2.LeaseResult>;
    getBlobProperties(containerName: string, blobPath: string): Promise<BlobService_2.BlobResult>;
    listBlobsSegmented(containerName: string, options?: BlobService_2.ListBlobsSegmentedRequestOptions): Promise<BlobService_2.ListBlobsResult>;
    getBlobMetadata(containerName: string, blobPath: string): Promise<BlobService_2.BlobResult>;
    setBlobMetadata(containerName: string, blobPath: string, metadata: Dictionary<string>, options?: BlobService_2.BlobRequestOptions): Promise<BlobService_2.BlobResult>;
    acquireLease(containerName: string, blobPath: string, options: BlobService_2.AcquireLeaseRequestOptions): Promise<BlobService_2.LeaseResult>;
    deleteBlobIfExists(containerName: string, blobPath: string): Promise<void>;
    deleteContainerIfExists(containerName: string): Promise<void>;
    static create(hostName: string, connectionString: string): BlobService;
}

/**
 * Describes the checkoint information.
 * @interface CheckpointInfo
 */
export declare interface CheckpointInfo {
    /**
     * @property {string} partitionId The EventHub partition id.
     */
    partitionId: string;
    /**
     * @property {string} offset The offset of the event to be checked in.
     */
    offset: string;
    /**
     * @property {string} sequenceNumber The sequence number of the event to be checked in.
     */
    sequenceNumber: number;
}

/**
 * Describes the checkoint information.
 * @namespace CheckpointInfo
 */
export declare namespace CheckpointInfo {
    /**
     * Creates the checkpoint info
     * @param {string} partitionId The partition id for the checkpoint
     * @param {string} [offset] The offset of the event to be checked in.
     * @param {number} [sequenceNumber] The sequence number of the event to be checked in.
     * @return {CheckpointInfo} CheckpointInfo
     */
    export function create(partitionId: string, offset?: string, sequenceNumber?: number): CheckpointInfo;
    /**
     * Creates the checkpoint info
     * @param {LeaseInfo} lease The lease info from which the checkpoint info needs to created.
     * @return {CheckpointInfo} CheckpointInfo
     */
    export function createFromLease(lease: LeaseInfo): CheckpointInfo;
    /**
     * Creates the checkpoint info.
     * @param {string} partitionId The partition id for the checkpoint
     * @param {EventData} eventData The event data from which the checkpoint info needs to created.
     * @return {CheckpointInfo} CheckpointInfo
     */
    export function createFromEventData(partitionId: string, eventData: EventData): CheckpointInfo;
}

/**
 * @interface CheckpointManager
 * If you wish to have EventProcessorHost store checkpoints somewhere other than Azure Storage,
 * you can write your own checkpoint manager using this interface.
 *
 * The Azure Storage managers use the same storage for both lease and checkpoints, so both the
 * interfaces are implemented by the same class. You are free to do the same thing if you have
 * a unified store for both types of data.
 *
 * This interface does not specify initialization methods because we have no way of knowing what
 * information your implementation will require.
 */
export declare interface CheckpointManager {
    /**
     * Does the checkpoint store exist?
     * @returns {Promise<boolean>} Promise<boolean> `true` if it exists, `false` if it does not exist.
     */
    checkpointStoreExists(): Promise<boolean>;
    /**
     * Create the checkpoint store if it doesn't exist. Does nothing if it exists.
     * @returns {Promise<boolean>} Promise<void> resolves with `undefined`; rejects with an `Error`.
     */
    createCheckpointStoreIfNotExists(): Promise<void>;
    /**
     * Deletes the checkpoint store.
     * @returns {Promise<void>} Promise<void> resolves with `undefined`; rejects with an `Error`.
     */
    deleteCheckpointStore(): Promise<void>;
    /**
     * Creates the checkpoint HOLDERs for the given partitions. Does nothing for any checkpoint
     * HOLDERs that already exist.
     *
     * The semantics of this are complicated because it is possible to use the same store for both
     * leases and checkpoints (the Azure Storage implementation does so) and it is required to
     * have a lease for every partition but it is not required to have a checkpoint for a partition.
     * It is a valid scenario to never use checkpoints at all, so it is important for the store to
     * distinguish between creating the structure(s) that will hold a checkpoint and actually creating
     * a checkpoint (storing an offset/sequence number pair in the structure).
     *
     * @param {string[]} partitionIds  List of partitions to create checkpoint HOLDERs for.
     * @returns {Promise<void>} Promise<void> resolves with `undefined`; rejects with an `Error`.
     */
    createAllCheckpointsIfNotExists(partitionIds: string[]): Promise<void>;
    /**
     * Gets the checkpoint info associated with the given partition. Could return undefined if no
     * checkpoint has been created for that partition.
     * @param {string} partitionId The partitionId to get the checkpoint info for.
     * @returns {Promise<CheckpointInfo | undefined>} Promise<CheckpointInfo | undefined> Checkpoint
     * info for the given partition, or undefined if none has been previously stored.
     */
    getCheckpoint(partitionId: string): Promise<CheckpointInfo | undefined>;
    /**
     * Update the checkpoint in the store with the offset/sequenceNumber in the provided checkpoint.
     * @param {CompleteLease} lease Partition information against which to perform a checkpoint.
     * @param {CheckpointInfo} checkpoint offset/sequeceNumber to update the store with
     * @returns {Promise<boolean>} Promise<void> resolves with `undefined`; rejects with an `Error`.
     */
    updateCheckpoint(lease: CompleteLease, checkpoint: CheckpointInfo): Promise<void>;
    /**
     * Delete the stored checkpoint for the given partition. If there is no stored checkpoint for the
     * given partition, that is treated as success. Deleting the checkpoint HOLDER is allowed
     * but not required; your implementation is free to do whichever is more convenient.
     * @param {string} partitionId The partitionId to delete the checkpoint from the store.
     * @returns {Promise<void>} Promise<void> resolves with `undefined`; rejects with an `Error`.
     */
    deleteCheckpoint(partitionId: string): Promise<void>;
}

/**
 * @ignore
 */
declare enum CloseReason {
    leaseLost = "LeaseLost",
    shutdown = "ShutDown"
}

/**
 * Describes a Complete Lease.
 * @class CompleteLease.
 */
export declare class CompleteLease extends BaseLease {
    /**
     * @property {number} epoch The epoch(time) of the lease, which is a value you can use to
     * determine the most recent owner of a partition between competing nodes.
     */
    epoch: number;
    /**
     * Creates an instance of the Lease.
     * @constructor
     * @param {CompleteLeaseInfo} info The Lease info.
     */
    constructor(info: CompleteLeaseInfo);
    /**
     * Increments the value of epoch by 1.
     * @returns {number} The incremented value of the epoch.
     */
    incrementEpoch(): number;
    /**
     * Gets the lease information.
     * @returns {CompleteLeaseInfo} CompleteLeaseInfo.
     */
    getInfo(): CompleteLeaseInfo;
}

/**
 * Describes the properties of a Complete Lease.
 * @interface CompleteLeaseInfo
 */
export declare interface CompleteLeaseInfo extends BaseLeaseInfo {
    /**
     * @property {number} epoch The epoch(time) of the lease, which is a value you can use to
     * determine the most recent owner of a partition between competing nodes.
     */
    epoch: number;
}

/**
 * @ignore
 */
declare interface CreateContainerResult {
    created: BlobService_2.ContainerResult;
    details: ServiceResponse;
}
export { DataTransformer }
export { delay }

/**
 * Provides information about internal errors that occur while managing partitions or leases for
 * the partitions.
 * @interface EPHDiagnosticInfo
 */
export declare interface EPHDiagnosticInfo {
    /**
     * @property {string} hostName The name of the host that experienced the error. Allows
     * distinguishing the error source if multiple hosts in a single process.
     */
    hostName: string;
    /**
     * @property {string} partitionId The partitionId that experienced the error. Allows
     * distinguishing the error source if multiple hosts in a single process.
     */
    partitionId: string;
    /**
     * @property {string} action A short string that indicates what general activity threw the
     * error.
     */
    action: string;
    /**
     * @property {any} error The error that was thrown.
     */
    error: any;
}
export { EventData }
export { EventHubPartitionRuntimeInformation }
export { EventHubRuntimeInformation }
export { EventPosition }

/**
 * Describes the Event Processor Host to process events from an EventHub.
 * @class EventProcessorHost
 */
export declare class EventProcessorHost {
    /**
     * @property {ProcessorContextWithLeaseManager} _context The processor context.
     * @private
     */
    private _context;
    /**
     * Creates a new host to process events from an Event Hub.
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {EventHubClient} eventHubClient The EventHub client
     * @param {EventProcessorOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     */
    constructor(hostName: string, options?: EventProcessorHostOptions);
    /**
     * Provides the host name for the Event processor host.
     */
    readonly hostName: string;
    /**
     * Provides the consumer group name for the Event processor host.
     */
    readonly consumerGroup: string;
    /**
     * Provides the eventhub runtime information.
     * @returns {Promise<EventHubRuntimeInformation>}
     */
    getHubRuntimeInformation(): Promise<EventHubRuntimeInformation>;
    /**
     * Provides information about the specified partition.
     * @param {(string|number)} partitionId Partition ID for which partition information is required.
     *
     * @returns {EventHubPartitionRuntimeInformation} EventHubPartitionRuntimeInformation
     */
    getPartitionInformation(partitionId: string | number): Promise<EventHubPartitionRuntimeInformation>;
    /**
     * Provides an array of partitionIds.
     * @returns {Promise<string[]>}
     */
    getPartitionIds(): Promise<string[]>;
    /**
     * Provides a list of partitions the EPH is currently receiving messages from.
     *
     * The EPH will try to grab leases for more partitions during each scan that happens once every
     * (configured) lease renew seconds. The number of EPH instances that are being run
     * simultaneously to receive messages from the same consumer group within an event hub also
     * influences the number of partitions that this instance of EPH is actively receiving messages
     * from.
     *
     * @returns {Array<string>} Array<string> List of partitions that this EPH instance is currently
     * receiving messages from.
     */
    readonly receivingFromPartitions: string[];
    /**
     * Starts the event processor host, fetching the list of partitions, and attempting to grab leases
     * For each successful lease, it will get the details from the blob and start a receiver at the
     * point where it left off previously.
     *
     * @return {Promise<void>}
     */
    start(onMessage: OnReceivedMessage, onError: OnReceivedError): Promise<void>;
    /**
     * Stops the EventProcessorHost from processing messages.
     * @return {Promise<void>}
     */
    stop(): Promise<void>;
    /**
     * Convenience method for generating unique host name.
     *
     * @param {string} [prefix] String to use as the beginning of the name. Default value: "js-host".
     * @return {string} A unique host name
     */
    static createHostName(prefix?: string): string;
    /**
     * Creates an EventProcessorHost instance from the EventHub connection string.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {string} storageContainerName Azure Storage container name for use by built-in lease
     * and checkpoint manager.
     * @param {string} eventHubConnectionString Connection string for the Event Hub to receive from.
     * Example: 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;
     * SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {FromConnectionStringOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromConnectionString(hostName: string, storageConnectionString: string, storageContainerName: string, eventHubConnectionString: string, options?: FromConnectionStringOptions): EventProcessorHost;
    /**
     * Creates an EventProcessorHost instance from the EventHub connection string with the provided
     * checkpoint manager and lease manager.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} eventHubConnectionString Connection string for the Event Hub to receive from.
     * Example: 'Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;
     * SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.
     * @param {LeaseManager} leaseManager A manager to manage leases.
     * @param {FromConnectionStringOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromConnectionStringWithCustomCheckpointAndLeaseManager(hostName: string, eventHubConnectionString: string, checkpointManager: CheckpointManager, leaseManager: LeaseManager, options?: FromConnectionStringOptions): EventProcessorHost;
    /**
     * Creates an EventProcessorHost instance from a TokenProvider.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {string} storageContainerName Azure Storage container name for use by built-in lease
     * and checkpoint manager.
     * @param {string} namespace Fully qualified domain name for Event Hubs.
     * Example: "{your-sb-namespace}.servicebus.windows.net"
     * @param {string} eventHubPath The name of the EventHub.
     * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.
     * @param {FromTokenProviderOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromTokenProvider(hostName: string, storageConnectionString: string, storageContainerName: string, namespace: string, eventHubPath: string, tokenProvider: TokenProvider, options?: FromTokenProviderOptions): EventProcessorHost;
    /**
     * Creates an EventProcessorHost instance from a TokenProvider with the provided checkpoint manager
     * and lease manager.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} namespace Fully qualified domain name for Event Hubs.
     * Example: "{your-sb-namespace}.servicebus.windows.net"
     * @param {string} eventHubPath The name of the EventHub.
     * @param {TokenProvider} tokenProvider - Your token provider that implements the TokenProvider interface.
     * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.
     * @param {LeaseManager} leaseManager A manager to manage leases.
     * @param {FromTokenProviderOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromTokenProviderWithCustomCheckpointAndLeaseManager(hostName: string, namespace: string, eventHubPath: string, tokenProvider: TokenProvider, checkpointManager: CheckpointManager, leaseManager: LeaseManager, options?: FromTokenProviderOptions): EventProcessorHost;
    /**
     * Creates an EventProcessorHost instance from AAD token credentials.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {string} storageContainerName Azure Storage container name for use by built-in lease
     * and checkpoint manager.
     * @param {string} namespace Fully qualified domain name for Event Hubs.
     * Example: "{your-sb-namespace}.servicebus.windows.net"
     * @param {string} eventHubPath The name of the EventHub.
     * @param {TokenCredentials} credentials - The AAD Token credentials. It can be one of the
     * following: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials
     * | MSITokenCredentials.
     * @param {FromTokenProviderOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromAadTokenCredentials(hostName: string, storageConnectionString: string, storageContainerName: string, namespace: string, eventHubPath: string, credentials: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | MSITokenCredentials, options?: FromTokenProviderOptions): EventProcessorHost;
    /**
     * Creates an EventProcessorHost instance from AAD token credentials with the given checkpoint manager
     * and lease manager.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} namespace Fully qualified domain name for Event Hubs.
     * Example: "{your-sb-namespace}.servicebus.windows.net"
     * @param {string} eventHubPath The name of the EventHub.
     * @param {TokenCredentials} credentials - The AAD Token credentials. It can be one of the
     * following: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials
     * | MSITokenCredentials.
     * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.
     * @param {LeaseManager} leaseManager A manager to manage leases.
     * @param {FromTokenProviderOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromAadTokenCredentialsWithCustomCheckpointAndLeaseManager(hostName: string, namespace: string, eventHubPath: string, credentials: ApplicationTokenCredentials | UserTokenCredentials | DeviceTokenCredentials | MSITokenCredentials, checkpointManager: CheckpointManager, leaseManager: LeaseManager, options?: FromTokenProviderOptions): EventProcessorHost;
    /**
     * Creates an EventProcessorHost instance from the IotHub connection string.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} storageConnectionString Connection string to Azure Storage account used for
     * leases and checkpointing. Example DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net
     * @param {string} storageContainerName Azure Storage container name for use by built-in lease
     * and checkpoint manager.
     * @param {string} iotHubConnectionString Connection string for the IotHub.
     * Example: 'Endpoint=iot-host-name;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {FromIotHubConnectionStringOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromIotHubConnectionString(hostName: string, storageConnectionString: string, storageContainerName: string, iotHubConnectionString: string, options?: FromIotHubConnectionStringOptions): Promise<EventProcessorHost>;
    /**
     * Creates an EventProcessorHost instance from the IotHub connection string with the given
     * checkpoint manager and lease manager.
     *
     * @param {string} hostName Name of the processor host. MUST BE UNIQUE.
     * Strongly recommend including a Guid or a prefix with a guid to ensure uniqueness. You can use
     * `EventProcessorHost.createHostName("your-prefix")`; Default: `js-host-${uuid()}`.
     * @param {string} iotHubConnectionString Connection string for the IotHub.
     * Example: 'Endpoint=iot-host-name;SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key'
     * @param {CheckpointManager} checkpointManager A manager to manage checkpoints.
     * @param {LeaseManager} leaseManager A manager to manage leases.
     * @param {FromIotHubConnectionStringOptions} [options] Optional parameters for creating an
     * EventProcessorHost.
     *
     * @returns {EventProcessorHost} EventProcessorHost
     */
    static createFromIotHubConnectionStringWithCustomCheckpointAndLeaseManager(hostName: string, iotHubConnectionString: string, checkpointManager: CheckpointManager, leaseManager: LeaseManager, options?: FromIotHubConnectionStringOptions): Promise<EventProcessorHost>;
}

/**
 * Describes the optional parameters that can be provided for creating an EventProcessorHost.
 * @interface EventProcessorHostOptions
 */
export declare interface EventProcessorHostOptions extends FromConnectionStringOptions {
    /**
     * @property {string} [eventHubConnectionString] Connection string for the Event Hub to receive
     * from. Example: "Endpoint=sb://my-servicebus-namespace.servicebus.windows.net/;
     * SharedAccessKeyName=my-SA-name;SharedAccessKey=my-SA-key".
     */
    eventHubConnectionString?: string;
    /**
     * @property {string} [storageConnectionString] Connection string to Azure Storage account used
     * for leases and checkpointing. Example "DefaultEndpointsProtocol=https;AccountName=<account-name>;
     * AccountKey=<account-key>;EndpointSuffix=core.windows.net"
     */
    storageConnectionString?: string;
    /**
     * @property {string} [storageContainerName] Azure Storage container name for use by built-in
     * lease and checkpoint manager.
     */
    storageContainerName?: string;
    /**
     * @property {CheckpointManager} [checkpointManager] A manager to manage checkpoints.
     * Default: **`AzureStorageCheckpointLeaseManager`**.
     */
    checkpointManager?: CheckpointManager;
    /**
     * @property {LeaseManager} [LeaseManager] A manager to manage leases. Default:
     * **`AzureStorageCheckpointLeaseManager`**.
     */
    leaseManager?: LeaseManager;
    /**
     * @property {TokenProvider} [tokenProvider] An instance of the token provider interface that
     * provides the token for authentication. Default value: **`SasTokenProvider`**.
     */
    tokenProvider?: TokenProvider;
}

/**
 * Describes the optional parameters that can be provided for creating an EventProcessorHost while
 * creating from the eventhub connection string.
 * @interface FromConnectionStringOptions
 */
export declare interface FromConnectionStringOptions extends FromTokenProviderOptions {
    /**
     * @property {string} [eventHubPath] The name of the EventHub. This is optional if the
     * EventHub connection string contains EntityPath=hub-name else an Error will be thrown.
     */
    eventHubPath?: string;
}

/**
 * Describes the optional parameters that can be provided for creating an EventProcessorHost while
 * creating from an iothub connectionstring.
 * @interface FromIotHubConnectionStringOptions
 */
declare type FromIotHubConnectionStringOptions = FromTokenProviderOptions;

/**
 * Describes the optional parameters that can be provided for creating an EventProcessorHost while
 * creating from the given token provider
 * @interface FromTokenProviderOptions
 */
export declare interface FromTokenProviderOptions extends ClientOptionsBase {
    /**
     * @property {EventPosition} initialOffset This is only used when then receiver is being created
     * for the very first time and there is no checkpoint data in the blob. For this option to be
     * effective please make sure to provide a new hostName that was not used previously.
     */
    initialOffset?: EventPosition;
    /**
     * @property {string} [consumerGroup] The name of the consumer group within the Event Hub. Default
     * value: **`"$default"`**.
     */
    consumerGroup?: string;
    /**
     * @property {string} [storageBlobPrefix] Prefix used when naming blobs within the storage
     * container.
     */
    storageBlobPrefix?: string;
    /**
     * @property {OnEphError} [onEphError] Error handler that can be provided to receive notifcation
     * for general errors.
     *
     * Errors which occur while processing events from a particular EventHub partition are delivered
     * to the `onError` handler provided in the `start()` method. This handler is called on
     * occasions when an error occurs while managing partitions or leases for the partitions.
     */
    onEphError?: OnEphError;
    /**
     * @property {number} [leaseRenewInterval] The sleep interval **`in seconds`** between scans.
     * Default: **`10` seconds**.
     *
     * Allows a lease manager implementation to specify to PartitionManager how often it should
     * scan leases and renew them. In order to redistribute leases in a timely fashion after a host
     * ceases operating, we recommend a relatively short interval, such as ten seconds. Obviously it
     * should be less than half of the lease length, to prevent accidental expiration.
     *
     * If `Leasemanager` is provided when creating the EventProcessorHost then this value will be ignored.
     */
    leaseRenewInterval?: number;
    /**
     * @property {number} [leaseDuration] Duration of a lease **`in seconds`** before it expires
     * unless renewed. Default: **`30` seconds**, Min Value: **`15` seconds**,
     * Max value: **`60` seconds**.
     *
     * If `Leasemanager` is provided when creating the EventProcessorHost then this value will be ignored.
     */
    leaseDuration?: number;
    /**
     * @property {number} [startupScanDelay] The delay time **`in seconds`** between the first scan
     * for available partitions and the second. This is part of a startup optimization which allows
     * individual hosts to become visible to other hosts, and thereby get a more accurate count
     * of the number of hosts in the system, before they try to estimate how many partitions they
     * should own. Default: **`30` seconds**.
     */
    startupScanDelay?: number;
    /**
     * @property {number} [fastScanInterval] There are two possible interval times between scans for
     * available partitions, fast and slow. The fast (short) interval **`in seconds`** is used after
     * a scan in which lease stealing has occurred, to promote quicker rebalancing.
     * Default: **`3` seconds**.
     */
    fastScanInterval?: number;
    /**
     * @property {number} [slowScanInterval] The slow (long) interval **`in seconds`** is used
     * after a scan in which lease stealing did not occur, to reduce unnecessary scanning when
     * the system is in steady state. Default: **`5` seconds**.
     */
    slowScanInterval?: number;
}

/**
 * @ignore
 */
declare interface HostContextWithCheckpointLeaseManager extends BaseHostContext {
    leaseManager: LeaseManager;
    checkpointManager: CheckpointManager;
    getEventHubClient(): EventHubClient;
    getHubRuntimeInformation(): Promise<EventHubRuntimeInformation>;
    getPartitionInformation(partitionId: string | number): Promise<EventHubPartitionRuntimeInformation>;
    getPartitionIds(): Promise<string[]>;
}

/**
 * Describes the properties of a lease.
 * @interface LeaseInfo
 */
declare interface LeaseInfo extends CompleteLeaseInfo {
    /**
     * @property {string} token The lease token that manages concurrency between hosts. You can use
     * this token to guarantee single access to any resource needed by the EPH.
     */
    token: string;
    /**
     * @property {string} sequenceNumber The sequence number of the event to be checked in.
     */
    sequenceNumber: number;
    /**
     * @property {string} offset The offset of the event to be checked in.
     */
    offset?: string;
}

/**
 * @interface LeaseManager
 * If you wish to have EventProcessorHost store leases somewhere other than Azure Storage,
 * you can write your own lease manager using this interface.
 *
 * The Azure Storage managers use the same storage for both lease and checkpoints, so both
 * interfaces are implemented by the same class. You are free to do the same thing if you have
 * a unified store for both types of data.
 *
 * This interface does not specify initialization methods because we have no way of knowing what
 * information your implementation will require.
 */
export declare interface LeaseManager {
    /**
     * @property {number} leaseRenewInterval The sleep interval **in seconds** between scans.
     *
     * Allows a lease manager implementation to specify to PartitionManager how often it should
     * scan leases and renew them. In order to redistribute leases in a timely fashion after a host
     * ceases operating, we recommend a relatively short interval, such as ten seconds. Obviously it
     * should be less than half of the lease length, to prevent accidental expiration.
     */
    leaseRenewInterval: number;
    /**
     * @property {number} leaseDuration Duration of a lease **in seconds** before it expires
     * unless renewed.
     */
    leaseDuration: number;
    /**
     * Does the lease store exist?
     * @returns {Promise<boolean>} Promise<boolean> `true` if it exists, `false` if it does not exist.
     */
    leaseStoreExists(): Promise<boolean>;
    /**
     * Create the lease store if it doesn't exist. Do nothing if it does exist.
     * @returns {Promise<void>} Promise<void>  resolves with `undefined`; rejects with an `Error`.
     */
    createLeaseStoreIfNotExists(): Promise<void>;
    /**
     * Delete lease store.
     * @returns {Promise<void>} Promise<void> resolves with `undefined`; rejects with an `Error`.
     */
    deleteLeaseStore(): Promise<void>;
    /**
     * Gets the lease info for the specified partition. Can return `undefined` if no lease has been
     * created in the store for the specified partition.
     * @param {string} partitionId Partition id to get the lease for.
     * @returns {Promise<CompleteLease | undefined>} Promise<Lease | undefined>
     */
    getLease(partitionId: string): Promise<CompleteLease | undefined>;
    /**
     * Returns lightweight BaseLease for all leases, which includes name of owning host and whether
     * lease is expired. An implementation is free to return CompleteLease or its own class derived
     * from CompleteLease, but it is important that getAllLeases run as fast as possible. If it is
     * faster to obtain only the information required for a BaseLease, we heavily recommend doing that.
     * @returns {Promise<BaseLease[]>} Promise<BaseLease[]>
     */
    getAllLeases(): Promise<BaseLease[]>;
    /**
     * Create in the store the lease info for the given partition, if it does not exist. Do nothing
     * if it does exist in the store already.
     *
     * @param {string[]} partitionIds ids of partitions to create lease info for
     * @returns {Promise<void>} Promise<void> undefined on success, rejects on error.
     */
    createAllLeasesIfNotExists(partitionIds: string[]): Promise<void>;
    /**
     * Delete the lease info for the given partition from the store. If there is no stored lease for
     * the given partition, that is treated as success.
     *
     * @param {CompleteLease} lease Lease info for the desired partition as previously obtained from
     * `getLease()`.
     * @returns {Promise<void>} Promise<void> resolves with `undefined`; rejects with an `Error`.
     */
    deleteLease(lease: CompleteLease): Promise<void>;
    /**
     * Acquire the lease on the desired partition for this EventProcessorHost.
     *
     * Note that it is legal to acquire a lease that is already owned by another host.
     * Lease-stealing is how partitions are redistributed when additional hosts are started.
     *
     * The existing Azure Storage implementation can experience races between two host instances
     * attempting to acquire or steal the lease at the same time. To avoid situations where two host
     * instances both believe that they own the lease, acquisition can fail without errors by
     * returning false and should do so when there is any doubt -- the worst that can happen is that
     * no host instance owns the lease for a short time. This is qualitatively different from,
     * for example, the underlying store throwing an access exception, which is an error.
     *
     * @param {CompleteLease} lease Lease info for the desired partition as previously obtained from
     * `getLease()`.
     * @returns {Promise<boolean>} Promise<boolean> `true` if acquired successfully; `false` otherwise.
     */
    acquireLease(lease: CompleteLease): Promise<boolean>;
    /**
     * Renew a lease currently held by this host.
     *
     * If the lease has been taken by another host instance (either stolen or after expiration)
     * or explicitly released, renewLease must return false. With the Azure Storage-based
     * implementation, it IS possible to renew an expired lease that has not been taken by another
     * host, so your implementation can allow that or not, whichever is convenient. If it does not,
     * renewLease should return false.
     *
     * @param {CompleteLease} lease lease to be renewed.
     * @returns {Promise<boolean>} Promise<boolean> `true` if renewed successfully; `false` otherwise.
     */
    renewLease(lease: CompleteLease): Promise<boolean>;
    /**
     * Give up a lease currently held by this host.
     *
     * If the lease has been stolen, or expired, releasing it is unnecessary, and will fail if
     * attempted.
     *
     * @param {CompleteLease} lease Lease info for the desired partition as previously obtained from
     * `getLease()`.
     * @returns {Promise<void>} Promise<void> resolves with `undefined`; rejects with an `Error`.
     */
    releaseLease(lease: CompleteLease): Promise<void>;
    /**
     * Update the store with the information in the provided lease.
     *
     * It is necessary to currently hold a lease in order to update it. If the lease has been stolen,
     * or expired, or released, it cannot be updated. Lease manager implementations should renew the
     * lease before performing the update to avoid lease expiration during the process.
     *
     * @param {CompleteLease} lease New lease information to be stored.
     * @returns {Promise<boolean>} Promise<boolean> `true` if updated successfully; `false` otherwise.
     */
    updateLease(lease: CompleteLease): Promise<boolean>;
}
export { MessagingError }

/**
 * Describes the error handler signature to receive notifcation for general errors.
 *
 * Errors which occur while processing events from a particular EventHub partition are delivered
 * to the `onError` handler provided in the `start()` method. This handler is called on
 * occasions when an error occurs while managing partitions or leases for the partitions.
 * @function
 */
export declare type OnEphError = (error: EPHDiagnosticInfo) => void;
export { OnError }

/**
 * Describes the message handler signature for errors that occur while receiving messages from an
 * EventHub.
 * @function
 */
export declare type OnReceivedError = (error: MessagingError | Error) => void;

/**
 * Describes the message handler signature for messages received from an EventHub.
 * @function
 */
export declare type OnReceivedMessage = (context: PartitionContext, eventData: EventData) => void;

/**
 * Describes the Partition Context.
 * @class PartitionContext
 */
export declare class PartitionContext {
    /**
     * @property {Lease} lease The most recdent checkpointed lease with the partitionId.
     */
    lease: CompleteLease;
    /**
     * @property {string} partitionId The eventhub partition id.
     * @readonly
     */
    readonly partitionId: string;
    /**
     * @property {string} owner The host/owner of the partition.
     * @readonly
     */
    readonly owner: string;
    /**
     * @property {string} eventhubPath The path of the eventhub
     * @readonly
     */
    readonly eventhubPath: string;
    /**
     * @property {string} consumerGroup The name of the consumer group.
     * @readonly
     */
    readonly consumerGroup: string;
    private _context;
    private _offset;
    private _sequenceNumber;
    /**
     * Creates a new PartitionContext.
     * @param {string} partitionId The eventhub partition id.
     * @param {string} owner The name of the owner.
     * @param {CompleteLease} lease The lease object.
     */
    constructor(context: HostContextWithCheckpointLeaseManager, partitionId: string, lease: CompleteLease);
    /**
     * Sets the offset and sequence number of the partition context from the provided EventData.
     * @param {EventData} eventData The event data `received` from the EventHubReceiver.
     */
    setOffsetAndSequenceNumber(eventData: EventData): void;
    /**
     * Writes the current offset and sequenceNumber to the checkpoint store via the checkpoint manager.
     *
     * The checkpoint data is structured as a JSON payload (example):
     * `{ "partitionId":"0","owner":"ephtest","token":"48e209e3-55f0-41b8-a8dd-d9c09ff6c35a",
     * "epoch":1,"offset":"","SequenceNumber":0 }`.
     *
     * @return {Promise<void>}
     */
    checkpoint(): Promise<void>;
    /**
     * Writes the current offset and sequenceNumber to the checkpoint store via the checkpoint manager.
     *
     * The checkpoint data is structured as a JSON payload (example):
     * `{ "partitionId":"0","owner":"ephtest","token":"48e209e3-55f0-41b8-a8dd-d9c09ff6c35a",
     * "epoch":1,"offset":"","SequenceNumber":0 }`.
     *
     * @param {EventData} eventData The event data received from the EventHubReceiver.
     * @return {Promise<void>}
     */
    checkpointFromEventData(eventData: EventData): Promise<void>;
    /**
     * @ignore
     */
    getInitialOffset(): Promise<EventPosition>;
    /**
     * @ignore
     */
    private _persistCheckpoint;
}

/**
 * @ignore
 */
declare class PartitionPump {
    private _context;
    private _lease;
    private _partitionContext;
    private _onMessage;
    private _onError;
    private _client?;
    private _receiveHandler?;
    private _leaseRenewalTimer?;
    constructor(context: HostContextWithCheckpointLeaseManager, lease: CompleteLease, onMessage: OnReceivedMessage, onError: OnReceivedError);
    lease: CompleteLease;
    isOpen(): boolean;
    start(): Promise<void>;
    stop(reason: CloseReason): Promise<void>;
    private _createNewReceiver;
    private _leaseRenewer;
    private _scheduleLeaseRenewer;
    private _removeReceiver;
    private _isReceiverDisconnectedError;
}

export { }
